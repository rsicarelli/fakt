// Copyright (C) 2025 Rodrigo Sicarelli
// SPDX-License-Identifier: Apache-2.0
package com.rsicarelli.fakt.compiler.ir.generation

import com.rsicarelli.fakt.codegen.extensions.generateCompleteFake
import com.rsicarelli.fakt.codegen.extensions.generateFactoryFunction
import com.rsicarelli.fakt.codegen.model.CodeFile
import com.rsicarelli.fakt.compiler.core.types.TypeResolution
import com.rsicarelli.fakt.compiler.ir.analysis.ClassAnalysis
import com.rsicarelli.fakt.compiler.ir.analysis.InterfaceAnalysis

/**
 * Holds the generated code pieces from the implementation generator.
 *
 * @property implementationFile CodeFile with package, imports, and implementation class
 * @property factoryFunction Generated factory function code (string)
 */
internal data class GeneratedFakeCode(
    val implementationFile: CodeFile,
    val factoryFunction: String,
)

/**
 * Implementation generator for fake classes and factory functions.
 *
 * Uses type-safe DSL for clean, composable code generation.
 */
internal class ImplementationGenerator(
    private val typeResolver: TypeResolution,
) {
    /**
     * Generates fake implementation and factory for an interface.
     *
     * Returns implementation CodeFile and factory function string.
     *
     * @param analysis The analyzed interface metadata
     * @param packageName The package name for the generated code
     * @param imports Additional imports required by the interface (from ImportResolver)
     * @return GeneratedFakeCode with CodeFile and factory string
     */
    fun generateImplementation(
        analysis: InterfaceAnalysis,
        packageName: String,
        imports: List<String> = emptyList(),
    ): GeneratedFakeCode {
        // Map IR analysis to codegen models
        val (methods, properties) = analysis.toCodegenSpecs(typeResolver)

        // Generate implementation using DSL
        val implementationFile = generateCompleteFake(
            packageName = packageName,
            interfaceName = analysis.interfaceName,
            methods = methods,
            properties = properties,
            imports = imports,
            header = "Generated by Fakt\n// Interface: ${analysis.interfaceName}",
            typeParameters = analysis.typeParameters
        )

        // Generate factory function (currently as string)
        val factoryFunction = generateFactoryFunction(
            interfaceName = analysis.interfaceName,
            typeParameters = analysis.typeParameters
        )

        return GeneratedFakeCode(
            implementationFile = implementationFile,
            factoryFunction = factoryFunction
        )
    }

    /**
     * Generates fake implementation and factory for a class.
     *
     * Returns implementation CodeFile and factory function string.
     *
     * @param analysis The analyzed class metadata
     * @param packageName The package name for the generated code
     * @param imports Additional imports required by the class (from ImportResolver)
     * @return GeneratedFakeCode with CodeFile and factory string
     */
    fun generateClassFake(
        analysis: ClassAnalysis,
        packageName: String,
        imports: List<String> = emptyList(),
    ): GeneratedFakeCode {
        // Convert abstract and open members to method specs (keeping track of which are abstract)
        val abstractMethodSpecs = analysis.abstractMethods.map { function ->
            function.toMethodSpec(typeResolver).copy(isAbstract = true)
        }
        val openMethodSpecs = analysis.openMethods.map { function ->
            function.toMethodSpec(typeResolver).copy(isAbstract = false)
        }
        val methodSpecs = abstractMethodSpecs + openMethodSpecs

        // Convert abstract and open properties (keeping track of which are abstract)
        val abstractPropertySpecs = analysis.abstractProperties.map { property ->
            property.toPropertySpec(typeResolver).copy(isAbstract = true)
        }
        val openPropertySpecs = analysis.openProperties.map { property ->
            property.toPropertySpec(typeResolver).copy(isAbstract = false)
        }
        val propertySpecs = abstractPropertySpecs + openPropertySpecs

        // Generate implementation using DSL
        val implementationFile = generateCompleteFake(
            packageName = packageName,
            interfaceName = analysis.className,
            methods = methodSpecs,
            properties = propertySpecs,
            imports = imports,
            header = "Generated by Fakt\n// Class: ${analysis.className}",
            typeParameters = analysis.typeParameters,
            isClass = true
        )

        // Generate factory function (currently as string)
        val factoryFunction = generateFactoryFunction(
            interfaceName = analysis.className,
            typeParameters = analysis.typeParameters
        )

        return GeneratedFakeCode(
            implementationFile = implementationFile,
            factoryFunction = factoryFunction
        )
    }
}
