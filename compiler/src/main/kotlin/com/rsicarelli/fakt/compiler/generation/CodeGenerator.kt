// Copyright (C) 2025 Rodrigo Sicarelli
// SPDX-License-Identifier: Apache-2.0
package com.rsicarelli.fakt.compiler.generation

import com.rsicarelli.fakt.compiler.analysis.InterfaceAnalysis
import com.rsicarelli.fakt.compiler.sourceset.SourceSetMapper
import com.rsicarelli.fakt.compiler.types.ImportResolver
import com.rsicarelli.fakt.compiler.types.TypeResolver
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.kotlinFqName
import org.jetbrains.kotlin.ir.util.packageFqName
import java.io.File

/**
 * Handles code generation for fake implementations.
 * Orchestrates the generation of implementation classes, factory functions, and configuration DSLs.
 *
 * @since 1.0.0
 */
@OptIn(UnsafeDuringIrConstructionAPI::class)
internal class CodeGenerator(
    private val typeResolver: TypeResolver,
    private val importResolver: ImportResolver,
    private val sourceSetMapper: SourceSetMapper,
    private val implementationGenerator: ImplementationGenerator,
    private val factoryGenerator: FactoryGenerator,
    private val configurationDslGenerator: ConfigurationDslGenerator,
    private val messageCollector: MessageCollector?
) {

    /**
     * Generates complete fake implementation including class, factory, and configuration DSL.
     *
     * @param sourceInterface The interface to generate a fake for
     * @param analysis The analyzed interface metadata
     * @param moduleFragment The module context for output directory resolution
     */
    fun generateWorkingFakeImplementation(
        sourceInterface: IrClass,
        analysis: InterfaceAnalysis,
        moduleFragment: IrModuleFragment
    ) {
        val interfaceName = analysis.interfaceName
        val fakeClassName = "Fake${interfaceName}Impl"
        val packageName = sourceInterface.packageFqName?.asString() ?: ""

        messageCollector?.reportInfo("KtFakes: Generating fake for interface $interfaceName")

        try {
            // Generate the implementation class
            val implementationCode = implementationGenerator.generateImplementation(analysis, fakeClassName)

            // Generate the factory function
            val factoryCode = factoryGenerator.generateFactoryFunction(analysis, fakeClassName, packageName)

            // Generate the configuration DSL
            val configDslCode = configurationDslGenerator.generateConfigurationDsl(analysis, fakeClassName, packageName)

            // Write generated code to output directory, preserving package structure
            writeGeneratedCode(
                moduleFragment = moduleFragment,
                packageName = packageName,
                fakeClassName = fakeClassName,
                interfaceName = interfaceName,
                analysis = analysis,
                implementationCode = implementationCode,
                factoryCode = factoryCode,
                configDslCode = configDslCode
            )

            messageCollector?.reportInfo("KtFakes: Successfully generated fake for $interfaceName -> $fakeClassName")

        } catch (e: Exception) {
            messageCollector?.reportError("KtFakes: Failed to generate fake for $interfaceName: ${e.message}")
            throw e
        }
    }

    /**
     * Writes the generated code to the appropriate output file.
     */
    private fun writeGeneratedCode(
        moduleFragment: IrModuleFragment,
        packageName: String,
        fakeClassName: String,
        interfaceName: String,
        analysis: InterfaceAnalysis,
        implementationCode: String,
        factoryCode: String,
        configDslCode: String
    ) {
        val outputDir = sourceSetMapper.getGeneratedSourcesDir(moduleFragment)

        // Create subdirectories matching the package structure
        val packagePath = packageName.replace('.', '/')
        val packageDir = outputDir.resolve(packagePath)
        packageDir.mkdirs()
        val outputFile = packageDir.resolve("${fakeClassName}.kt")

        // Collect all required imports from the interface analysis
        val requiredImports = importResolver.collectRequiredImports(analysis, packageName)

        val fullCode = buildString {
            appendLine("// Generated by KtFakes - NoGenerics Pattern")
            appendLine("// Interface: $interfaceName")
            appendLine("package $packageName")
            appendLine()

            // Add required imports
            if (requiredImports.isNotEmpty()) {
                requiredImports.sorted().forEach { import ->
                    appendLine("import $import")
                }
                appendLine()
            }

            // Add implementation class
            append(implementationCode)
            appendLine()
            appendLine()

            // Add factory function
            append(factoryCode)
            appendLine()
            appendLine()

            // Add configuration DSL
            append(configDslCode)
            appendLine()
        }

        outputFile.writeText(fullCode)

        messageCollector?.reportInfo("KtFakes: Generated fake written to: ${outputFile.absolutePath}")
    }

    private fun MessageCollector.reportInfo(message: String) {
        this.report(
            org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO,
            message,
            null
        )
    }

    private fun MessageCollector.reportError(message: String) {
        this.report(
            org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR,
            message,
            null
        )
    }
}
