// Copyright (C) 2025 Rodrigo Sicarelli
// SPDX-License-Identifier: Apache-2.0
package com.rsicarelli.fakt.compiler.ir.generation

import com.rsicarelli.fakt.codegen.extensions.generateCompleteFake
import com.rsicarelli.fakt.codegen.extensions.generateFactoryFunction
import com.rsicarelli.fakt.codegen.model.CodeFile
import com.rsicarelli.fakt.compiler.core.types.TypeResolution
import com.rsicarelli.fakt.compiler.ir.analysis.ClassAnalysis
import com.rsicarelli.fakt.compiler.ir.analysis.InterfaceAnalysis

/**
 * Holds the generated code pieces from V2 generator.
 *
 * @property implementationFile CodeFile with package, imports, and implementation class
 * @property factoryFunction Generated factory function code (string)
 */
internal data class GeneratedCodeV2(
    val implementationFile: CodeFile,
    val factoryFunction: String,
)

/**
 * V2: DSL-based implementation generator.
 *
 * Replaces 1367 lines of string concatenation with type-safe DSL.
 * Uses the codegen-v2 library for clean, composable code generation.
 * Now includes factory function generation.
 */
internal class ImplementationGeneratorV2(
    private val typeResolver: TypeResolution,
) {
    /**
     * Generates fake implementation and factory for an interface using DSL.
     *
     * Returns implementation CodeFile and factory function string.
     *
     * @param analysis The analyzed interface metadata
     * @param packageName The package name for the generated code
     * @param imports Additional imports required by the interface (from ImportResolver)
     * @return GeneratedCodeV2 with CodeFile and factory string
     */
    fun generateImplementation(
        analysis: InterfaceAnalysis,
        packageName: String,
        imports: List<String> = emptyList(),
    ): GeneratedCodeV2 {
        // Map IR analysis to codegen models
        val (methods, properties) = analysis.toCodegenSpecs(typeResolver)

        // Generate implementation using DSL
        val implementationFile = generateCompleteFake(
            packageName = packageName,
            interfaceName = analysis.interfaceName,
            methods = methods,
            properties = properties,
            imports = imports,
            header = "Generated by Fakt\n// Interface: ${analysis.interfaceName}",
            typeParameters = analysis.typeParameters
        )

        // Generate factory function (currently as string)
        val factoryFunction = generateFactoryFunction(
            interfaceName = analysis.interfaceName,
            typeParameters = analysis.typeParameters
        )

        return GeneratedCodeV2(
            implementationFile = implementationFile,
            factoryFunction = factoryFunction
        )
    }

    /**
     * Generates fake implementation and factory for a class using DSL.
     *
     * Returns implementation CodeFile and factory function string.
     *
     * @param analysis The analyzed class metadata
     * @param packageName The package name for the generated code
     * @param imports Additional imports required by the class (from ImportResolver)
     * @return GeneratedCodeV2 with CodeFile and factory string
     */
    fun generateClassFake(
        analysis: ClassAnalysis,
        packageName: String,
        imports: List<String> = emptyList(),
    ): GeneratedCodeV2 {
        // Combine abstract and open members
        val allFunctions = analysis.abstractMethods + analysis.openMethods
        val allProperties = analysis.abstractProperties + analysis.openProperties

        // Convert to method/property specs
        val methodSpecs = allFunctions.map { it.toMethodSpec(typeResolver) }
        val propertySpecs = allProperties.map { it.toPropertySpec(typeResolver) }

        // Generate implementation using DSL
        val implementationFile = generateCompleteFake(
            packageName = packageName,
            interfaceName = analysis.className,
            methods = methodSpecs,
            properties = propertySpecs,
            imports = imports,
            header = "Generated by Fakt\n// Class: ${analysis.className}",
            typeParameters = analysis.typeParameters,
            isClass = true
        )

        // Generate factory function (currently as string)
        val factoryFunction = generateFactoryFunction(
            interfaceName = analysis.className,
            typeParameters = analysis.typeParameters
        )

        return GeneratedCodeV2(
            implementationFile = implementationFile,
            factoryFunction = factoryFunction
        )
    }
}
