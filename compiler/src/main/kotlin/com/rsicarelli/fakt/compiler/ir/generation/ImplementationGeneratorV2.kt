// Copyright (C) 2025 Rodrigo Sicarelli
// SPDX-License-Identifier: Apache-2.0
package com.rsicarelli.fakt.compiler.ir.generation

import com.rsicarelli.fakt.codegen.extensions.generateCompleteFake
import com.rsicarelli.fakt.codegen.extensions.generateFactoryFunction
import com.rsicarelli.fakt.codegen.model.CodeFile
import com.rsicarelli.fakt.compiler.core.types.TypeResolution
import com.rsicarelli.fakt.compiler.ir.analysis.ClassAnalysis
import com.rsicarelli.fakt.compiler.ir.analysis.InterfaceAnalysis

/**
 * Holds the generated code pieces from V2 generator.
 *
 * @property implementationFile CodeFile with package, imports, and implementation class
 * @property factoryFunction Generated factory function code (string)
 */
internal data class GeneratedCodeV2(
    val implementationFile: CodeFile,
    val factoryFunction: String,
)

/**
 * V2: DSL-based implementation generator.
 *
 * Replaces 1367 lines of string concatenation with type-safe DSL.
 * Uses the codegen-v2 library for clean, composable code generation.
 * Now includes factory function generation.
 */
internal class ImplementationGeneratorV2(
    private val typeResolver: TypeResolution,
) {
    /**
     * Generates fake implementation and factory for an interface using DSL.
     *
     * Returns implementation CodeFile and factory function string.
     *
     * @param analysis The analyzed interface metadata
     * @param packageName The package name for the generated code
     * @param imports Additional imports required by the interface (from ImportResolver)
     * @return GeneratedCodeV2 with CodeFile and factory string
     */
    fun generateImplementation(
        analysis: InterfaceAnalysis,
        packageName: String,
        imports: List<String> = emptyList(),
    ): GeneratedCodeV2 {
        // Map IR analysis to codegen models
        val (methods, properties) = analysis.toCodegenSpecs(typeResolver)

        // Generate implementation using DSL
        val implementationFile = generateCompleteFake(
            packageName = packageName,
            interfaceName = analysis.interfaceName,
            methods = methods,
            properties = properties,
            imports = imports,
            header = "Generated by Fakt\n// Interface: ${analysis.interfaceName}",
            typeParameters = analysis.typeParameters
        )

        // Generate factory function (currently as string)
        val factoryFunction = generateFactoryFunction(
            interfaceName = analysis.interfaceName,
            typeParameters = analysis.typeParameters
        )

        return GeneratedCodeV2(
            implementationFile = implementationFile,
            factoryFunction = factoryFunction
        )
    }

    /**
     * Generates fake implementation and factory for a class using DSL.
     *
     * Returns implementation CodeFile and factory function string.
     *
     * @param analysis The analyzed class metadata
     * @param packageName The package name for the generated code
     * @param imports Additional imports required by the class (from ImportResolver)
     * @return GeneratedCodeV2 with CodeFile and factory string
     */
    fun generateClassFake(
        analysis: ClassAnalysis,
        packageName: String,
        imports: List<String> = emptyList(),
    ): GeneratedCodeV2 {
        // Convert abstract and open members to method specs (keeping track of which are abstract)
        val abstractMethodSpecs = analysis.abstractMethods.map { function ->
            function.toMethodSpec(typeResolver).copy(isAbstract = true)
        }
        val openMethodSpecs = analysis.openMethods.map { function ->
            function.toMethodSpec(typeResolver).copy(isAbstract = false)
        }
        val methodSpecs = abstractMethodSpecs + openMethodSpecs

        // Convert abstract and open properties (keeping track of which are abstract)
        val abstractPropertySpecs = analysis.abstractProperties.map { property ->
            property.toPropertySpec(typeResolver).copy(isAbstract = true)
        }
        val openPropertySpecs = analysis.openProperties.map { property ->
            property.toPropertySpec(typeResolver).copy(isAbstract = false)
        }
        val propertySpecs = abstractPropertySpecs + openPropertySpecs

        // Generate implementation using DSL
        val implementationFile = generateCompleteFake(
            packageName = packageName,
            interfaceName = analysis.className,
            methods = methodSpecs,
            properties = propertySpecs,
            imports = imports,
            header = "Generated by Fakt\n// Class: ${analysis.className}",
            typeParameters = analysis.typeParameters,
            isClass = true
        )

        // Generate factory function (currently as string)
        val factoryFunction = generateFactoryFunction(
            interfaceName = analysis.className,
            typeParameters = analysis.typeParameters
        )

        return GeneratedCodeV2(
            implementationFile = implementationFile,
            factoryFunction = factoryFunction
        )
    }
}
