// Copyright (C) 2025 Rodrigo Sicarelli
// SPDX-License-Identifier: Apache-2.0
package dev.rsicarelli.ktfake.compiler.irnative.analysis

import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.declarations.impl.*
import org.jetbrains.kotlin.ir.expressions.impl.IrConstructorCallImpl
import org.jetbrains.kotlin.ir.symbols.impl.*
import org.jetbrains.kotlin.ir.types.impl.IrSimpleTypeImpl
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.Nested
import kotlin.test.*

/**
 * Tests for IrInterfaceAnalyzer following BDD naming conventions.
 * 
 * Tests dynamic interface analysis using vanilla JUnit5 with descriptive names:
 * - GIVEN: Context of @Fake annotated interfaces
 * - WHEN: Analysis operations are performed
 * - THEN: Expected analysis results are produced
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class IrInterfaceAnalyzerTest {

    private val analyzer = SimpleInterfaceAnalyzer()

    @Nested
    inner class FakeInterfaceDiscovery {

        @Test
        fun `GIVEN interface with @Fake annotation WHEN discovering fake interfaces THEN should find annotated interface`() {
            // Given - interface with @Fake annotation
            val fakeInterface = createTestInterface("UserService") {
                addFakeAnnotation()
            }
            val regularInterface = createTestInterface("RegularService")
            
            val moduleClasses = listOf(fakeInterface, regularInterface)

            // When
            val discoveredInterfaces = analyzer.discoverFakeInterfaces(moduleClasses)

            // Then
            assertEquals(1, discoveredInterfaces.size)
            assertEquals("UserService", discoveredInterfaces.first().name.asString())
        }

        @Test 
        fun `GIVEN multiple interfaces with @Fake annotations WHEN discovering THEN should find all annotated interfaces`() {
            // Given - multiple @Fake interfaces
            val userService = createTestInterface("UserService") {
                addFakeAnnotation()
            }
            val paymentService = createTestInterface("PaymentService") {
                addFakeAnnotation()
            }
            val regularService = createTestInterface("RegularService")

            val moduleClasses = listOf(userService, paymentService, regularService)

            // When
            val discoveredInterfaces = analyzer.discoverFakeInterfaces(moduleClasses)

            // Then
            assertEquals(2, discoveredInterfaces.size)
            val names = discoveredInterfaces.map { it.name.asString() }
            assertTrue(names.contains("UserService"))
            assertTrue(names.contains("PaymentService"))
            assertFalse(names.contains("RegularService"))
        }

        @Test
        fun `GIVEN object with @Fake annotation WHEN discovering THEN should not find object types`() {
            // Given - object with @Fake (not allowed)
            val fakeObject = createTestClass("UserService", ClassKind.OBJECT) {
                addFakeAnnotation()
            }

            val moduleClasses = listOf(fakeObject)

            // When
            val discoveredInterfaces = analyzer.discoverFakeInterfaces(moduleClasses)

            // Then
            assertEquals(0, discoveredInterfaces.size, "Objects should not be discovered as fake interfaces")
        }
    }

    @Nested
    inner class InterfaceAnalysis {

        @Test
        fun `GIVEN simple interface WHEN analyzing THEN should extract basic information`() {
            // Given - simple interface
            val testInterface = createTestInterface("UserService") {
                addFakeAnnotation()
                addMethod("getUser", "kotlin.String", listOf("id" to "kotlin.String"))
            }

            // When
            val analysis = analyzer.analyzeInterface(testInterface)

            // Then
            assertEquals("UserService", analysis.interfaceName)
            assertEquals(testInterface, analysis.sourceInterface)
            assertFalse(analysis.annotations.trackCalls)
            assertTrue(analysis.annotations.concurrent)
        }

        // Properties and generics tests will be added after basic functionality works
    }

    @Nested
    inner class InterfaceValidation {

        @Test
        fun `GIVEN valid interface WHEN validating THEN should return valid result`() {
            // Given - valid interface
            val validInterface = createTestInterface("UserService") {
                addFakeAnnotation()
                addMethod("getUser", "kotlin.String", listOf("id" to "kotlin.String"))
            }

            // When
            val validationResult = analyzer.validateInterface(validInterface)

            // Then
            assertTrue(validationResult is ValidationResult.Valid)
        }

        @Test
        fun `GIVEN object with @Fake annotation WHEN validating THEN should return error about thread safety`() {
            // Given - object with @Fake (violates thread-safety rule)
            val objectWithFake = createTestClass("UserService", ClassKind.OBJECT) {
                addFakeAnnotation()
            }

            // When
            val validationResult = analyzer.validateInterface(objectWithFake)

            // Then
            assertTrue(validationResult is ValidationResult.Invalid)
            val errors = (validationResult as ValidationResult.Invalid).errors
            assertTrue(errors.any { it.contains("thread safety") })
        }

        @Test
        fun `GIVEN empty interface WHEN validating THEN should return error about no content`() {
            // Given - empty interface (no methods or properties)
            val emptyInterface = createTestInterface("EmptyService") {
                addFakeAnnotation()
                // No methods or properties added
            }

            // When
            val validationResult = analyzer.validateInterface(emptyInterface)

            // Then
            assertTrue(validationResult is ValidationResult.Invalid)
            val errors = (validationResult as ValidationResult.Invalid).errors
            assertTrue(errors.any { it.contains("no methods or properties") })
        }
    }

    // Test builders for creating IR test data (following testing guidelines)
    private fun createTestInterface(name: String, configure: TestInterfaceBuilder.() -> Unit = {}): IrClass {
        return TestInterfaceBuilder(name, ClassKind.INTERFACE).apply(configure).build()
    }

    private fun createTestClass(name: String, kind: ClassKind, configure: TestInterfaceBuilder.() -> Unit = {}): IrClass {
        return TestInterfaceBuilder(name, kind).apply(configure).build()
    }
}

/**
 * Test builder for creating IR test data following testing guidelines.
 * Provides clean DSL for test data creation.
 */
private class TestInterfaceBuilder(
    private val name: String, 
    private val kind: ClassKind = ClassKind.INTERFACE
) {
    private val annotations = mutableListOf<IrConstructorCall>()
    private val methods = mutableListOf<IrSimpleFunction>()
    private val properties = mutableListOf<IrProperty>()
    private val typeParameters = mutableListOf<IrTypeParameter>()

    fun addFakeAnnotation() {
        // Create mock @Fake annotation
        val fakeAnnotationType = IrSimpleTypeImpl(
            classifier = IrClassSymbolImpl(),
            nullability = org.jetbrains.kotlin.ir.types.SimpleTypeNullability.NOT_SPECIFIED,
            arguments = emptyList(),
            annotations = emptyList()
        )
        
        // Set the class FQ name for the fake annotation type
        (fakeAnnotationType.classifier as IrClassSymbolImpl).apply {
            // Mock the classFqName property
        }
        
        val annotation = IrConstructorCallImpl(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            type = fakeAnnotationType,
            symbol = IrConstructorSymbolImpl(),
            typeArgumentsCount = 0,
            constructorTypeArgumentsCount = 0,
            valueArgumentsCount = 0
        )
        
        annotations.add(annotation)
    }

    fun addMethod(
        methodName: String, 
        returnType: String, 
        parameters: List<Pair<String, String>> = emptyList(),
        isSuspend: Boolean = false
    ) {
        val method = IrFunctionImpl(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            origin = IrDeclarationOrigin.DEFINED,
            symbol = IrSimpleFunctionSymbolImpl(),
            name = Name.identifier(methodName),
            visibility = DescriptorVisibilities.PUBLIC,
            modality = Modality.ABSTRACT,
            returnType = createMockType(returnType),
            isInline = false,
            isExternal = false,
            isTailrec = false,
            isSuspend = isSuspend,
            isOperator = false,
            isInfix = false,
            isExpect = false,
            isFakeOverride = false
        )

        // Add parameters
        parameters.forEachIndexed { index, (paramName, paramType) ->
            val parameter = IrValueParameterImpl(
                startOffset = UNDEFINED_OFFSET,
                endOffset = UNDEFINED_OFFSET,
                origin = IrDeclarationOrigin.DEFINED,
                symbol = IrValueParameterSymbolImpl(),
                name = Name.identifier(paramName),
                index = index,
                type = createMockType(paramType),
                varargElementType = null,
                isCrossinline = false,
                isNoinline = false,
                isHidden = false,
                isAssignable = false
            )
            method.valueParameters = method.valueParameters + parameter
        }

        methods.add(method)
    }

    fun addSuspendMethod(methodName: String, returnType: String, parameters: List<Pair<String, String>> = emptyList()) {
        addMethod(methodName, returnType, parameters, isSuspend = true)
    }

    fun addProperty(name: String, type: String, hasGetter: Boolean = true, hasSetter: Boolean = false) {
        val property = IrPropertyImpl(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            origin = IrDeclarationOrigin.DEFINED,
            symbol = IrPropertySymbolImpl(),
            name = Name.identifier(name),
            visibility = DescriptorVisibilities.PUBLIC,
            modality = Modality.ABSTRACT,
            isVar = hasSetter,
            isConst = false,
            isLateinit = false,
            isDelegated = false,
            isExternal = false,
            isExpect = false,
            isFakeOverride = false
        )

        if (hasGetter) {
            val getter = IrFunctionImpl(
                startOffset = UNDEFINED_OFFSET,
                endOffset = UNDEFINED_OFFSET,
                origin = IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR,
                symbol = IrSimpleFunctionSymbolImpl(),
                name = Name.special("<get-$name>"),
                visibility = DescriptorVisibilities.PUBLIC,
                modality = Modality.ABSTRACT,
                returnType = createMockType(type),
                isInline = false,
                isExternal = false,
                isTailrec = false,
                isSuspend = false,
                isOperator = false,
                isInfix = false,
                isExpected = false,
                isFakeOverride = false
            )
            property.getter = getter
        }

        properties.add(property)
    }

    fun addGenericParameter(paramName: String) {
        val typeParam = IrTypeParameterImpl(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            origin = IrDeclarationOrigin.DEFINED,
            symbol = IrTypeParameterSymbolImpl(),
            name = Name.identifier(paramName),
            index = typeParameters.size,
            isReified = false,
            variance = org.jetbrains.kotlin.types.Variance.INVARIANT
        )
        typeParameters.add(typeParam)
    }

    fun build(): IrClass {
        val irClass = IrClassImpl(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            origin = IrDeclarationOrigin.DEFINED,
            symbol = IrClassSymbolImpl(),
            name = Name.identifier(name),
            kind = kind,
            visibility = DescriptorVisibilities.PUBLIC,
            modality = Modality.ABSTRACT,
            isCompanion = false,
            isInner = false,
            isData = false,
            isExternal = false,
            isValue = false,
            isExpect = false,
            isFun = false,
            hasEnumEntries = false
        )

        // Add annotations
        irClass.annotations = annotations

        // Add declarations
        irClass.declarations = methods.map { it as IrDeclaration } + properties.map { it as IrDeclaration }
        
        // Add type parameters
        irClass.typeParameters = typeParameters

        return irClass
    }

    private fun createMockType(typeName: String): org.jetbrains.kotlin.ir.types.IrType {
        return IrSimpleTypeImpl(
            classifier = IrClassSymbolImpl(),
            nullability = org.jetbrains.kotlin.ir.types.SimpleTypeNullability.NOT_SPECIFIED,
            arguments = emptyList(),
            annotations = emptyList()
        )
    }
}