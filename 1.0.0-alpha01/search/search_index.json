{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Fakt","text":"<p>Compile-time type-safe test fakes for Kotlin Multiplatform</p> <p> </p> <p>Fakt generates type-safe test fakes at compile-time. No reflection. No production dependencies. Just clean fakes that break when your interfaces change.</p> <pre><code>@Fake\ninterface Analytics {\n    fun track(event: String)\n}\n\nval fake = fakeAnalytics {\n    track { event -&gt; println(\"Tracked: $event\") }\n}\n</code></pre>"},{"location":"index.html#why-fakt","title":"Why Fakt?","text":"<p>Writing test fakes manually is tedious and error-prone. You write 50+ lines of boilerplate for every interface, manage non-thread-safe call counters, and refactoring interfaces won\u2019t break tests at compile-time. Runtime mocking frameworks like MockK and Mockito avoid the boilerplate but introduce severe performance penalties and don\u2019t work on Native/WASM targets.</p> <p>Fakt solves both problems with compile-time code generation that works everywhere Kotlin compiles.</p> <p>Read the full story \u2192</p>"},{"location":"index.html#features","title":"\u2728 Features","text":"<ul> <li>\u2705 Universal KMP support - Works on all Kotlin targets without reflection</li> <li>\u2705 Zero production overhead - Test-only code generation, no runtime dependencies</li> <li>\u2705 Thread-safe call tracking - Built-in StateFlow-based reactive counters</li> <li>\u2705 Full language support - Suspend functions, generics, properties, inheritance</li> <li>\u2705 Smart defaults - Identity functions for generics, Result.success for Results</li> <li>\u2705 IR-level generation - Direct compiler plugin for performance and compatibility</li> </ul> <p>Complete feature reference \u2192</p>"},{"location":"index.html#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Quick Start:</p> <ol> <li>Getting Started - Install Fakt and create your first fake in 5 minutes</li> <li>Basic Usage - Core patterns and techniques</li> <li>Testing Patterns - Best practices for using fakes in tests</li> </ol> <p>Usage Guides:</p> <ul> <li>Suspend Functions - Working with coroutines and async code</li> <li>Generics - Generic interfaces and type parameters</li> <li>Properties - Faking val and var properties</li> <li>Call Tracking - StateFlow-based reactive counters</li> </ul> <p>Advanced Topics:</p> <ul> <li>Multi-Module Setup - Cross-module fakes with collector modules</li> <li>Configuration - Plugin configuration and log levels</li> <li>Performance - Build times, caching, and optimization</li> <li>Migration from Mocks - Migrating from MockK or Mockito</li> </ul> <p>Reference:</p> <ul> <li>API Reference - Complete generated API documentation</li> <li>Limitations - Known limitations and workarounds</li> <li>Compatibility - Platform and version requirements</li> <li>FAQ - Frequently asked questions</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"index.html#platform-support","title":"\ud83c\udf10 Platform Support","text":"<p>Fakt works on all Kotlin Multiplatform targets without reflection: JVM, Android, iOS, macOS, Linux, Windows, JavaScript, WebAssembly, watchOS, tvOS.</p> <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p> <p>Full compatibility matrix \u2192</p>"},{"location":"index.html#requirements","title":"Requirements","text":"<ul> <li>Kotlin: 2.2.20+</li> <li>Gradle: 8.0+</li> <li>JVM: 11+</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>Fakt is licensed under the Apache License 2.0.</p> <pre><code>Copyright (C) 2025 Rodrigo Sicarelli\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"faq.html","title":"Frequently Asked Questions","text":"<p>Common questions about Fakt, answered with honesty and technical context.</p>"},{"location":"faq.html#stability-safety","title":"Stability &amp; Safety","text":""},{"location":"faq.html#is-fakt-safe-to-use-in-production-testing","title":"Is Fakt safe to use in production testing?","text":"<p>Short answer: Yes. Fakt is functionally stable and ready for production use in test suites.</p> <p>Longer answer: Fakt follows a two-phase FIR \u2192 IR compilation architecture inspired by production compiler plugins like Metro. While the Kotlin compiler plugin API is not a stable API (marked <code>@UnsafeApi</code>), Fakt:</p> <ul> <li>Generates code at compile-time with zero runtime dependencies</li> <li>Has been tested across Kotlin 2.2.20+ and all KMP targets</li> <li>Uses forward compatibility patterns (N+.2 version support)</li> <li>Is versioned as 1.0.0-SNAPSHOT to signal pre-1.0 status</li> </ul> <p>Generated fakes are production-quality code that compiles to native binaries without reflection.</p> <p>Compiler Plugin API Stability</p> <p>The Kotlin compiler plugin API can change between Kotlin versions. Fakt is tested against each Kotlin release and updated as needed. Pin your Kotlin version in production CI/CD.</p>"},{"location":"faq.html#why-100-snapshot-instead-of-100","title":"Why \u201c1.0.0-SNAPSHOT\u201d instead of \u201c1.0.0\u201d?","text":"<p>SNAPSHOT signals real-world validation in progress, not \u201cbroken.\u201d The API is functionally complete and production-ready. We prioritize honesty over marketing\u20141.0.0 will follow community feedback and battle-testing.</p>"},{"location":"faq.html#comparison-with-other-tools","title":"Comparison with Other Tools","text":""},{"location":"faq.html#why-not-use-mockk-or-mockito","title":"Why not use MockK or Mockito?","text":"<p>MockK and Mockito are runtime mocking frameworks using reflection (JVM/Android only). Fakt generates fakes at compile-time using Kotlin IR:</p> <ul> <li>\u2705 Works on ALL KMP targets (iOS, Native, JS, WASM) without reflection</li> <li>\u2705 Zero runtime cost, compile-time type safety</li> <li>\u2705 Generated code you can read and debug</li> </ul> <p>Use MockK/Mockito when: You need dynamic mocking or are on JVM-only projects.</p> <p>Use Fakt when: Building Kotlin Multiplatform projects or want zero-runtime-cost test doubles.</p> <p>See Why Fakt for detailed comparison.</p>"},{"location":"faq.html#how-does-fakt-compare-to-hand-written-fakes","title":"How does Fakt compare to hand-written fakes?","text":"<p>Fakt generates the same code you\u2019d write manually, but faster and without mistakes:</p> Aspect Hand-Written Fakes Fakt Fakes Boilerplate ~50 lines per interface Auto-generated Call tracking Manual (<code>var count = 0</code>) StateFlow (thread-safe) Refactoring safety Breaks silently Breaks at compile-time Maintenance Scales with codebase Zero maintenance Customization Full control DSL configuration <p>Fakt doesn\u2019t replace hand-written fakes for complex scenarios (stateful mocks, partial implementations). It eliminates boilerplate for the 80% case.</p>"},{"location":"faq.html#feature-support","title":"Feature Support","text":""},{"location":"faq.html#does-fakt-support-generics","title":"Does Fakt support generics?","text":"<p>Yes. Class-level, method-level, generic constraints, and variance are all supported. See Features: Generics for detailed examples.</p>"},{"location":"faq.html#does-fakt-support-suspend-functions","title":"Does Fakt support suspend functions?","text":"<p>Yes. Suspend functions preserve coroutine semantics. See Suspend Functions for details.</p>"},{"location":"faq.html#does-fakt-support-properties-valvar","title":"Does Fakt support properties (val/var)?","text":"<p>Yes. Both read-only (<code>val</code>) and mutable (<code>var</code>) properties with call tracking. See Features: Properties for examples.</p>"},{"location":"faq.html#can-i-fake-data-classes-or-sealed-classes","title":"Can I fake data classes or sealed classes?","text":"<p>No. Fakt only generates fakes for interfaces, abstract classes, and open classes. Data/sealed classes work fine as parameter/return types. See Limitations for details and workarounds.</p>"},{"location":"faq.html#performance","title":"Performance","text":""},{"location":"faq.html#what-about-performance-impact-on-build-times","title":"What about performance impact on build times?","text":"<p>Fakt uses intelligent caching across KMP targets. First target compilation typically adds ~40ms for 100+ interfaces. Subsequent targets (JVM, iOS, Android) hit cache and add ~1ms each.</p> <p>For large projects (1000+ interfaces), expect:</p> <ul> <li>First compilation: ~200-400ms</li> <li>Cached targets: near-zero overhead (~1-2ms each)</li> </ul> <p>Example from a real KMP project:</p> <pre><code>DISCOVERY: 1ms (100 interfaces, 21 classes)\nGENERATION: 39ms (121 new fakes, avg 333\u00b5s/fake)\nTOTAL: 40ms (iosArm64 first compilation)\n\ncompileKotlinJvm:     1ms (121 from cache)\ncompileKotlinAndroid: 1ms (121 from cache)\n</code></pre> <p>See Performance Guide for detailed benchmarks and telemetry configuration.</p>"},{"location":"faq.html#multi-module-projects","title":"Multi-Module Projects","text":""},{"location":"faq.html#does-fakt-work-with-multi-module-projects","title":"Does Fakt work with multi-module projects?","text":"<p>Yes, with experimental multi-module support:</p> <pre><code>// Producer module: :core:analytics/build.gradle.kts\n@Fake\ninterface Analytics\n\n// Collector module: :core:analytics-fakes/build.gradle.kts\nplugins {\n    id(\"com.rsicarelli.fakt\")\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\n// Consumer module: :app/build.gradle.kts\ndependencies {\n    commonTest {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre> <p>For comprehensive documentation, see: - Multi-Module Overview - Architecture and when to use - Getting Started - Step-by-step setup guide - kmp-multi-module sample - Working example</p> <p>Experimental Feature</p> <p>Multi-module support is marked <code>@ExperimentalFaktMultiModule</code>. It works but the API may change before 1.0.</p>"},{"location":"faq.html#troubleshooting","title":"Troubleshooting","text":"<p>For common issues and solutions, see the Troubleshooting Guide:</p> <ul> <li>Generated fakes not appearing in IDE</li> <li>Unresolved reference: fakeXxx</li> <li>Compilation errors</li> <li>Multi-module issues</li> </ul>"},{"location":"faq.html#contributing-reporting-issues","title":"Contributing &amp; Reporting Issues","text":""},{"location":"faq.html#how-can-i-contribute-to-fakt","title":"How can I contribute to Fakt?","text":"<p>Contributions are welcome! Please:</p> <ol> <li>Follow GIVEN-WHEN-THEN testing standard</li> <li>Ensure all generated code compiles without errors</li> <li>Test both single-platform and KMP scenarios</li> <li>Run <code>make format</code> before committing</li> </ol> <p>See Contributing Guide for development workflows.</p>"},{"location":"faq.html#where-do-i-report-bugs","title":"Where do I report bugs?","text":"<p>Report issues on GitHub Issues. Please include:</p> <ul> <li>Kotlin version</li> <li>Fakt version</li> <li>KMP targets (if applicable)</li> <li>Minimal reproduction (interface + error message)</li> <li>Full compilation logs (<code>./gradlew build --info</code>)</li> </ul>"},{"location":"faq.html#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Troubleshooting - Common issues and solutions</li> <li>GitHub Discussions - Ask the community</li> <li>GitHub Issues - Report bugs</li> </ul>"},{"location":"troubleshooting.html","title":"Troubleshooting","text":"<p>Common issues and solutions for single-module and multi-module setups.</p>"},{"location":"troubleshooting.html#general-issues","title":"General Issues","text":""},{"location":"troubleshooting.html#generated-fakes-not-appearing","title":"Generated Fakes Not Appearing","text":"<p>Symptoms: IDE doesn\u2019t recognize <code>fakeXxx()</code> factory functions</p> <p>Solutions:</p> <ol> <li>Rebuild the project: <code>./gradlew clean build</code></li> <li>Invalidate IDE caches: File \u2192 Invalidate Caches \u2192 Invalidate and Restart</li> <li>Check build directory: Fakes are in <code>build/generated/fakt/commonTest/kotlin/</code></li> <li>Verify Gradle sync: Ensure Gradle sync completed successfully</li> </ol>"},{"location":"troubleshooting.html#unresolved-reference-fakexxx","title":"Unresolved Reference: fakeXxx","text":"<p>Common causes:</p> <ol> <li>Missing build step: Run <code>./gradlew build</code> first</li> <li>Wrong source set: Import from test code (<code>src/commonTest/</code>), not main</li> <li>Package mismatch: Generated fakes are in the same package as the interface</li> <li>Gradle sync issue: Re-sync Gradle in your IDE</li> </ol>"},{"location":"troubleshooting.html#compilation-fails-with-irtypealiassymbol-not-found","title":"Compilation Fails with \u201cIrTypeAliasSymbol not found\u201d","text":"<p>Causes:</p> <ol> <li>Kotlin version mismatch: Ensure you\u2019re on Kotlin 2.2.20+</li> <li>Fakt version incompatibility: Update Fakt to match your Kotlin version</li> </ol> <p>Solution:</p> <pre><code>// gradle/libs.versions.toml\n[versions]\nkotlin = \"2.2.20\"\nfakt = \"1.0.0-SNAPSHOT\"\n</code></pre>"},{"location":"troubleshooting.html#build-is-slow","title":"Build is Slow","text":"<p>Solutions:</p> <ol> <li> <p>Use LogLevel.QUIET in CI/CD: <pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)\n}\n</code></pre></p> </li> <li> <p>Check cache hit rate with <code>LogLevel.INFO</code></p> </li> <li> <p>Verify incremental compilation is enabled</p> </li> </ol>"},{"location":"troubleshooting.html#multi-module-issues","title":"Multi-Module Issues","text":""},{"location":"troubleshooting.html#diagnosis-tools","title":"Diagnosis Tools","text":"<p>Enable Debug Logging:</p> <pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.DEBUG)\n}\n</code></pre> <p>Rebuild to see detailed output:</p> <pre><code>./gradlew :core:analytics-fakes:clean :core:analytics-fakes:build --info\n</code></pre> <p>Check Task Execution:</p> <pre><code># View task dependency graph\n./gradlew :core:analytics-fakes:build --dry-run\n\n# Use build scans\n./gradlew build --scan\n</code></pre>"},{"location":"troubleshooting.html#issue-1-no-fakes-found-in-source-module","title":"Issue 1: \u201cNo fakes found in source module\u201d","text":"<p>Error: <pre><code>No fakes found in source module 'analytics'.\nVerify that source module has @Fake annotated interfaces.\n</code></pre></p> <p>Causes: 1. Source module has no <code>@Fake</code> interfaces 2. Fakes not generated (compilation failed) 3. Wrong module path in <code>collectFakesFrom()</code></p> <p>Diagnosis:</p> <pre><code># Check for @Fake annotations\ngrep -r \"@Fake\" core/analytics/src/\n\n# Verify fakes were generated\nls core/analytics/build/generated/fakt/\n\n# Check for compilation errors\n./gradlew :core:analytics:build\n</code></pre> <p>Solutions:</p> <pre><code>// \u2705 CORRECT: Collect from producer (has @Fake interfaces)\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\n// \u274c WRONG: Collecting from collector (no @Fake interfaces)\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analyticsFakes)  // Wrong!\n}\n</code></pre>"},{"location":"troubleshooting.html#issue-2-unresolved-reference-fakexxx-multi-module","title":"Issue 2: \u201cUnresolved reference: fakeXxx\u201d (Multi-Module)","text":"<p>Error: <pre><code>// In test file\nval fake = fakeAnalytics { }  // \u2190 Unresolved reference\n</code></pre></p> <p>Causes: 1. Consumer doesn\u2019t depend on collector module 2. Collector module not built 3. IDE not synced 4. Wrong import</p> <p>Diagnosis:</p> <pre><code># Check dependency in consumer\ngrep \"analyticsFakes\" app/build.gradle.kts\n\n# Verify collector was built\nls core/analytics-fakes/build/generated/collected-fakes/\n\n# Check for factory function\ngrep -r \"fun fakeAnalytics\" core/analytics-fakes/build/\n</code></pre> <p>Solutions:</p> <pre><code>// 1. Add dependency to consumer\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n\n// 2. Sync Gradle and rebuild\n./gradlew --refresh-dependencies build\n\n// 3. Invalidate IDE caches\n// File \u2192 Invalidate Caches \u2192 Invalidate and Restart\n</code></pre>"},{"location":"troubleshooting.html#issue-3-targets-mismatch","title":"Issue 3: Targets Mismatch","text":"<p>Error: <pre><code>Cannot find source set 'iosMain' for target 'iosX64'\n</code></pre></p> <p>Cause: Collector has different targets than producer</p> <p>Diagnosis:</p> <pre><code>// Check producer targets\n// core/analytics/build.gradle.kts\nkotlin {\n    jvm()\n    iosArm64()  // \u2190 Producer has this\n}\n\n// Check collector targets\n// core/analytics-fakes/build.gradle.kts\nkotlin {\n    jvm()\n    // Missing: iosArm64()  \u2190 Collector doesn't!\n}\n</code></pre> <p>Solution: Collector MUST have ALL producer\u2019s targets</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nkotlin {\n    jvm()\n    iosArm64()  // \u2705 Added\n    iosX64()\n    iosSimulatorArm64()\n}\n</code></pre>"},{"location":"troubleshooting.html#issue-4-wrong-platform-placement","title":"Issue 4: Wrong Platform Placement","text":"<p>Symptom: Fake ends up in wrong source set (e.g., <code>commonMain</code> instead of <code>jvmMain</code>)</p> <p>Cause: Package doesn\u2019t contain platform identifier</p> <p>Diagnosis:</p> <pre><code>// Check generated fake's package\n// core/analytics/build/generated/fakt/jvmTest/kotlin/DatabaseFake.kt\npackage com.example.database  // \u2190 No \"jvm\" segment!\n</code></pre> <p>Solution: Use platform identifier in package name</p> <pre><code>// \u2705 CORRECT: Platform in package\npackage com.example.jvm.database  // \u2192 jvmMain/\npackage com.example.ios.camera    // \u2192 iosMain/\n\n// \u274c WRONG: No platform identifier\npackage com.example.database  // \u2192 commonMain/ (fallback)\n</code></pre>"},{"location":"troubleshooting.html#issue-5-circular-dependencies","title":"Issue 5: Circular Dependencies","text":"<p>Error: <pre><code>Circular dependency between:\n:features:payment\n:features:user\n</code></pre></p> <p>Cause: Feature A fakes need Feature B, Feature B fakes need Feature A</p> <p>Solution: Extract shared interfaces to core modules</p> <pre><code>Before (circular):\nfeatures/payment \u2192 features/user\nfeatures/user \u2192 features/payment\n\nAfter (fixed):\ncore/payment-api @Fake interface PaymentProvider\ncore/user-api @Fake interface UserProvider\n\nfeatures/payment \u2192 core/payment-api, core/user-api\nfeatures/user \u2192 core/user-api, core/payment-api\n</code></pre>"},{"location":"troubleshooting.html#issue-6-missing-transitive-dependencies","title":"Issue 6: Missing Transitive Dependencies","text":"<p>Error: <pre><code>// In test\nval fake = fakeAnalytics { }  // Compiles\n\n// But runtime error:\nNoClassDefFoundError: kotlinx/coroutines/CoroutineScope\n</code></pre></p> <p>Cause: Collector didn\u2019t declare coroutines dependency</p> <p>Solution:</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nkotlin {\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)\n        implementation(libs.coroutines)  // \u2705 Add this\n    }\n}\n</code></pre> <p>How to identify needed dependencies:</p> <pre><code># Inspect generated code\ncat core/analytics-fakes/build/generated/collected-fakes/commonMain/kotlin/FakeAnalyticsImpl.kt\n\n# Look for imports:\nimport kotlinx.coroutines.*  # \u2192 Need coroutines\nimport kotlinx.serialization.*  # \u2192 Need serialization\n</code></pre>"},{"location":"troubleshooting.html#issue-7-ide-not-finding-fakes","title":"Issue 7: IDE Not Finding Fakes","text":"<p>Symptom: Autocomplete doesn\u2019t suggest <code>fakeXxx()</code>, but code compiles</p> <p>Causes: 1. IDE not synced with Gradle 2. Generated sources not indexed 3. Stale IDE caches</p> <p>Solutions:</p> <pre><code># 1. Reload Gradle projects\n# File \u2192 Reload All Gradle Projects\n\n# 2. Invalidate caches\n# File \u2192 Invalidate Caches \u2192 Invalidate and Restart\n\n# 3. Rebuild project\n./gradlew clean build\n\n# 4. Check generated sources are registered\nls core/analytics-fakes/build/generated/collected-fakes/\n</code></pre>"},{"location":"troubleshooting.html#issue-8-configuration-cache-failures","title":"Issue 8: Configuration Cache Failures","text":"<p>Error: <pre><code>Configuration cache problems found:\n- field 'project' from type 'FaktGradleSubplugin'\n</code></pre></p> <p>Cause: Using configuration cache with older Fakt version</p> <p>Solution: Update to Fakt 1.0.0-SNAPSHOT+ (configuration cache compatible)</p> <pre><code>// gradle.properties\norg.gradle.configuration-cache=true\n</code></pre>"},{"location":"troubleshooting.html#error-messages-reference","title":"Error Messages Reference","text":""},{"location":"troubleshooting.html#source-project-not-found","title":"\u201cSource project not found\u201d","text":"<pre><code>Source project ':core:analytics' not found.\nVerify module exists and is included in settings.gradle.kts.\n</code></pre> <p>Fix: Add module to <code>settings.gradle.kts</code></p> <pre><code>include(\":core:analytics\")\n</code></pre>"},{"location":"troubleshooting.html#collector-and-producer-targets-mismatch","title":"\u201cCollector and producer targets mismatch\u201d","text":"<pre><code>Collector has targets [jvm, js] but producer has [jvm, ios].\nAll producer targets must be present in collector.\n</code></pre> <p>Fix: Add missing targets to collector</p> <pre><code>kotlin {\n    jvm()\n    js()\n    iosArm64()  // \u2705 Add this\n}\n</code></pre>"},{"location":"troubleshooting.html#optin-annotation-missing","title":"\u201c@OptIn annotation missing\u201d","text":"<pre><code>Multi-module APIs require opt-in with @OptIn(ExperimentalFaktMultiModule::class)\n</code></pre> <p>Fix: Add opt-in annotation</p> <pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"troubleshooting.html#advanced-debugging","title":"Advanced Debugging","text":""},{"location":"troubleshooting.html#enable-trace-logging","title":"Enable TRACE Logging","text":"<pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.TRACE)\n}\n</code></pre> <p>Shows: - File-by-file collection - Platform detection reasoning - IR generation details - Task execution timing</p>"},{"location":"troubleshooting.html#task-dependency-visualization","title":"Task Dependency Visualization","text":"<pre><code># Show task graph\n./gradlew :app:test --dry-run\n\n# Execution timeline\n./gradlew :app:test --scan\n# \u2192 View timeline in build scan\n</code></pre>"},{"location":"troubleshooting.html#inspect-generated-code","title":"Inspect Generated Code","text":"<pre><code># View collected fake\ncat core/analytics-fakes/build/generated/collected-fakes/commonMain/kotlin/com/example/FakeAnalyticsImpl.kt\n\n# Compare with original\ncat core/analytics/build/generated/fakt/commonTest/kotlin/com/example/FakeAnalyticsImpl.kt\n</code></pre>"},{"location":"troubleshooting.html#verification-checklist","title":"Verification Checklist","text":"<p>Before reporting issues, verify:</p> <p>Single-Module: - [ ] Interface has <code>@Fake</code> annotation - [ ] Project builds successfully (<code>./gradlew build</code>) - [ ] Fakes generated (<code>ls build/generated/fakt/</code>) - [ ] Gradle synced in IDE - [ ] Using Kotlin 2.2.20+</p> <p>Multi-Module: - [ ] Producer module has <code>@Fake</code> annotated interfaces - [ ] Producer builds successfully (<code>./gradlew :core:analytics:build</code>) - [ ] Fakes generated in producer (<code>ls core/analytics/build/generated/fakt/</code>) - [ ] Collector depends on producer with correct path - [ ] Collector has ALL producer\u2019s KMP targets - [ ] Collector declares transitive dependencies - [ ] Consumer depends on collector module - [ ] Gradle synced in IDE - [ ] Using Fakt 1.0.0-SNAPSHOT+ - [ ] Kotlin 2.2.20+</p>"},{"location":"troubleshooting.html#getting-help","title":"Getting Help","text":"<p>If issues persist:</p> <ol> <li>Enable DEBUG logging and capture output</li> <li>Create minimal reproduction (single module or producer + collector + consumer)</li> <li>Report on GitHub: github.com/rsicarelli/fakt/issues</li> </ol> <p>Include in report: - Fakt version - Kotlin version - Gradle version - KMP targets (if applicable) - Full error message - DEBUG/TRACE log output - Minimal reproduction repository</p>"},{"location":"troubleshooting.html#see-also","title":"See Also","text":"<ul> <li>FAQ - Frequently asked questions</li> <li>Multi-Module Setup - Multi-module architecture overview</li> <li>Multi-Module Getting Started - Setup guide</li> <li>Configuration - Plugin options (coming soon)</li> </ul>"},{"location":"deployment/index.html","title":"Deployment &amp; Release Management","text":"<p>Automated CI/CD pipeline for seamless Fakt releases to Maven Central</p> <p>Fakt uses a sophisticated, automated deployment pipeline that ensures reliable releases while maintaining semantic versioning and comprehensive documentation.</p>"},{"location":"deployment/index.html#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<p>Our deployment system follows a single source of truth approach:</p> <pre><code>gradle.properties:VERSION_NAME \u2192 Maven Central + GitHub Releases\n</code></pre> <p>All version information flows from <code>gradle.properties:VERSION_NAME</code>, ensuring consistency across the entire ecosystem.</p>"},{"location":"deployment/index.html#continuous-integration-deployment","title":"\ud83e\udd16 Continuous Integration &amp; Deployment","text":""},{"location":"deployment/index.html#continuous-deploy-automated","title":"Continuous Deploy (Automated)","text":"<p>Trigger: Every merge to <code>main</code> branch Target: Maven Central (SNAPSHOT repository) Workflow: <code>.github/workflows/continuous-deploy.yml</code></p> <pre><code>graph LR\n    A[PR Merged] \u2192 B[Detect SNAPSHOT] \u2192 C[Publish to Maven Central] \u2192 D[\u2705 Available]\n</code></pre> <p>Process: 1. Validation: Ensures <code>VERSION_NAME</code> contains <code>-SNAPSHOT</code> 2. Publishing: Automatic upload to Maven Central staging 3. Availability: SNAPSHOT immediately available for consumption</p> <p>Example: <pre><code># gradle.properties\nVERSION_NAME=1.0.0-SNAPSHOT\n\n# After merge \u2192 Available as:\n# com.rsicarelli.fakt:runtime:1.0.0-SNAPSHOT\n# com.rsicarelli.fakt:compiler:1.0.0-SNAPSHOT\n</code></pre></p>"},{"location":"deployment/index.html#manual-releases-semantic-versioning","title":"Manual Releases (Semantic Versioning)","text":"<p>Trigger: Manual workflow dispatch Target: Maven Central (release repository) + GitHub Releases Workflow: <code>.github/workflows/publish-release.yml</code></p> <pre><code>graph TD\n    A[Manual Trigger] \u2192 B[Choose Version Bump] \u2192 C[Update Version] \u2192 D[Sync Documentation]\n    D \u2192 E[Publish to Maven Central] \u2192 F[Create Git Tag] \u2192 G[GitHub Release]\n    G \u2192 H[Auto-bump to next SNAPSHOT]\n</code></pre> <p>Supported Bump Types: - <code>major</code>: Breaking changes (1.0.0 \u2192 2.0.0) - <code>minor</code>: New features (1.0.0 \u2192 1.1.0) - <code>patch</code>: Bug fixes (1.0.0 \u2192 1.0.1)</p> <p>Process: 1. Version Bump: Semantic versioning via <code>.github/scripts/bump-version.main.kts</code> 2. Documentation Sync: Auto-update all docs/samples with new version 3. Maven Central: Publish signed artifacts 4. GitHub Release: Auto-generated changelog with commit history 5. Next Development: Auto-bump to next SNAPSHOT (e.g., 1.1.0 \u2192 1.2.0-SNAPSHOT)</p>"},{"location":"deployment/index.html#hotfix-releases-emergency-patches","title":"Hotfix Releases (Emergency Patches)","text":"<p>Trigger: Manual workflow from hotfix branch Target: Maven Central + GitHub Releases Workflow: <code>.github/workflows/publish-hotfix.yml</code></p> <pre><code>graph LR\n    A[Hotfix Branch] \u2192 B[Patch Bump] \u2192 C[Publish] \u2192 D[Tag &amp; Release]\n</code></pre> <p>Branch Strategy: <pre><code># Create hotfix branch from release tag\ngit checkout v1.0.0\ngit checkout -b hotfix/1.0.x\n\n# Make fixes, then trigger hotfix workflow\n# Automatically bumps: 1.0.0 \u2192 1.0.1\n</code></pre></p>"},{"location":"deployment/index.html#version-management","title":"\ud83d\udd04 Version Management","text":""},{"location":"deployment/index.html#single-source-of-truth","title":"Single Source of Truth","text":"<p>All versioning flows from <code>gradle.properties</code>:</p> <pre><code># gradle.properties - The authoritative version source\nVERSION_NAME=1.0.0-SNAPSHOT\n</code></pre>"},{"location":"deployment/index.html#automatic-synchronization","title":"Automatic Synchronization","text":"<p>The <code>.github/scripts/sync-docs-version.main.kts</code> script ensures consistency across:</p> <ul> <li>Version Catalogs: <code>gradle/libs.versions.toml</code></li> <li>Documentation: All <code>.md</code> files</li> <li>Samples: Build scripts in <code>samples/</code></li> <li>README: Main project documentation</li> </ul> <p>Patterns Updated: <pre><code>// Plugin declarations\nid(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n\n// Version catalog entries\nfakt = \"1.0.0-SNAPSHOT\"\n\n// Maven coordinates\ncom.rsicarelli.fakt:runtime:1.0.0-SNAPSHOT\n\n// Documentation examples\n- **Fakt**: 1.0.0-SNAPSHOT+\n</code></pre></p>"},{"location":"deployment/index.html#release-process","title":"\ud83d\ude80 Release Process","text":""},{"location":"deployment/index.html#standard-release-minormajor","title":"Standard Release (Minor/Major)","text":"<ol> <li>Prepare Release</li> <li>Ensure <code>main</code> branch is stable</li> <li>Verify all tests pass</li> <li> <p>Review pending changes for scope (breaking vs feature vs patch)</p> </li> <li> <p>Trigger Release <pre><code># Navigate to Actions \u2192 Publish Release \u2192 Run workflow\n# Select bump type: major | minor | patch\n</code></pre></p> </li> <li> <p>Automatic Process</p> </li> <li>Version bump (e.g., <code>1.0.0-SNAPSHOT</code> \u2192 <code>1.1.0</code>)</li> <li>Documentation synchronization</li> <li>Maven Central publication</li> <li>Git tag creation (<code>v1.1.0</code>)</li> <li>GitHub Release with auto-generated changelog</li> <li> <p>Next SNAPSHOT bump (<code>1.2.0-SNAPSHOT</code>)</p> </li> <li> <p>Verification <pre><code># Check Maven Central availability\n# https://central.sonatype.com/artifact/com.rsicarelli.fakt/runtime\n\n# Verify GitHub Release\n# https://github.com/rsicarelli/fakt/releases\n</code></pre></p> </li> </ol>"},{"location":"deployment/index.html#hotfix-release","title":"Hotfix Release","text":"<ol> <li> <p>Create Hotfix Branch <pre><code>git checkout v1.0.0\ngit checkout -b hotfix/1.0.x\ngit push -u origin hotfix/1.0.x\n</code></pre></p> </li> <li> <p>Apply Fixes <pre><code># Make necessary changes\ngit commit -m \"fix: critical issue in runtime\"\ngit push origin hotfix/1.0.x\n</code></pre></p> </li> <li> <p>Trigger Hotfix Workflow <pre><code># From hotfix branch \u2192 Actions \u2192 Publish Hotfix \u2192 Run workflow\n# Automatically bumps patch version: 1.0.0 \u2192 1.0.1\n</code></pre></p> </li> <li> <p>Merge Back (Manual) <pre><code># After successful hotfix, merge back to main\ngit checkout main\ngit merge hotfix/1.0.x\n</code></pre></p> </li> </ol>"},{"location":"deployment/index.html#security-signing","title":"\ud83d\udd10 Security &amp; Signing","text":""},{"location":"deployment/index.html#maven-central-requirements","title":"Maven Central Requirements","text":"<p>All releases are automatically signed using GPG keys stored as GitHub Secrets:</p> <pre><code># Required Secrets\nMAVEN_CENTRAL_USERNAME    # Sonatype Central Portal user token\nMAVEN_CENTRAL_PASSWORD    # Sonatype Central Portal user token password\nGPG_SIGNING_KEY          # GPG private key (ASCII armor format)\nGPG_SIGNING_PASSWORD     # GPG key passphrase\n</code></pre> <p>\ud83d\udea8 Setup Required: If you\u2019re encountering GPG signing errors, follow the complete setup guide: Maven Central Setup Guide</p>"},{"location":"deployment/index.html#artifact-verification","title":"Artifact Verification","text":"<p>Published artifacts include: - JAR files: Core runtime and compiler - Sources JAR: For IDE debugging - Javadoc JAR: API documentation - POM files: Dependency metadata - GPG signatures: <code>.asc</code> files for verification</p>"},{"location":"deployment/index.html#monitoring-verification","title":"\ud83d\udcca Monitoring &amp; Verification","text":""},{"location":"deployment/index.html#release-health-checks","title":"Release Health Checks","text":"<p>After each release, verify:</p> <ol> <li> <p>Maven Central Availability <pre><code># Check new version appears\ncurl -s \"https://search.maven.org/solrsearch/select?q=g:com.rsicarelli.fakt\"\n</code></pre></p> </li> <li> <p>GitHub Release Creation</p> </li> <li>Release notes generated</li> <li>Assets attached correctly</li> <li> <p>Tag points to correct commit</p> </li> <li> <p>Documentation Sync</p> </li> <li>Version catalog updated</li> <li>Sample projects reference new version</li> <li>Documentation examples current</li> </ol>"},{"location":"deployment/index.html#snapshot-monitoring","title":"SNAPSHOT Monitoring","text":"<p>SNAPSHOT releases are published continuously: <pre><code># Latest SNAPSHOT always available\ncom.rsicarelli.fakt:runtime:1.0.0-SNAPSHOT\n</code></pre></p>"},{"location":"deployment/index.html#development-workflow","title":"\ud83d\udee0\ufe0f Development Workflow","text":""},{"location":"deployment/index.html#for-contributors","title":"For Contributors","text":"<pre><code># Normal development - SNAPSHOTs published automatically\ngit checkout -b feature/awesome-feature\n# ... make changes ...\ngit commit -m \"feat: add awesome feature\"\ngit push origin feature/awesome-feature\n# Create PR \u2192 Merge \u2192 SNAPSHOT automatically published\n</code></pre>"},{"location":"deployment/index.html#testing-publishing-setup","title":"Testing Publishing Setup","text":"<p>Before releasing, test your Maven Central configuration:</p> <pre><code># Run the validation script\n./scripts/test-maven-central.sh\n\n# Manual testing (requires environment variables)\n./gradlew publishToMavenCentral --dry-run\n</code></pre> <p>\ud83d\udccb Full Setup Guide: Maven Central Setup</p>"},{"location":"deployment/index.html#for-maintainers","title":"For Maintainers","text":"<pre><code># Release planning\n1. Review accumulated changes since last release\n2. Determine semantic version impact (major/minor/patch)\n3. Trigger appropriate release workflow\n4. Monitor release pipeline completion\n5. Verify artifacts in Maven Central\n6. Announce release in appropriate channels\n</code></pre>"},{"location":"deployment/index.html#quick-reference","title":"\u26a1 Quick Reference","text":"Task Command Result Development Merge PR to main Auto-publishes SNAPSHOT Feature Release Workflow dispatch \u2192 <code>minor</code> 1.0.0 \u2192 1.1.0 Breaking Changes Workflow dispatch \u2192 <code>major</code> 1.0.0 \u2192 2.0.0 Bug Fix Release Workflow dispatch \u2192 <code>patch</code> 1.0.0 \u2192 1.0.1 Emergency Fix Hotfix branch workflow Immediate patch release Version Check <code>gradle.properties</code> Single source of truth"},{"location":"deployment/index.html#troubleshooting","title":"\ud83c\udd98 Troubleshooting","text":""},{"location":"deployment/index.html#common-issues","title":"Common Issues","text":"<p>Release workflow fails with signing errors: <pre><code># Common error: \"secret key ring doesn't start with secret key tag\"\n# Solution: Follow the complete Maven Central setup guide\n\n# Quick check\n./scripts/test-maven-central.sh\n\n# Complete setup\ndocs/deployment/maven-central-setup.md\n</code></pre></p> <p>SNAPSHOT not appearing in Maven Central: <pre><code># SNAPSHOTs may take 5-10 minutes to propagate\n# Check workflow logs for publication errors\n# Verify VERSION_NAME contains \"-SNAPSHOT\" suffix\n</code></pre></p> <p>Documentation out of sync: <pre><code># Run manual synchronization\nkotlin .github/scripts/sync-docs-version.main.kts\ngit add . &amp;&amp; git commit -m \"docs: sync version references\"\n</code></pre></p>"},{"location":"deployment/index.html#emergency-procedures","title":"Emergency Procedures","text":"<p>Corrupt release published: 1. Do not delete from Maven Central (impossible) 2. Immediately publish hotfix with incremented version 3. Update documentation to skip problematic version</p> <p>Failed release workflow: 1. Check workflow logs for specific error 2. Fix underlying issue 3. Re-run workflow (safe to retry) 4. Manual cleanup if needed (tags, releases)</p> <p>For additional support, consult the Troubleshooting Guide or open an issue.</p>"},{"location":"guides/configuration.html","title":"Configuration Guide","text":"<p>Complete guide to configuring the Fakt Gradle plugin.</p>"},{"location":"guides/configuration.html#log-level-configuration","title":"Log Level Configuration","text":"<p>Control compilation output verbosity:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.LogLevel\n\nfakt {\n    logLevel.set(LogLevel.INFO)  // Default\n}\n</code></pre>"},{"location":"guides/configuration.html#available-levels","title":"Available Levels","text":"<p><code>LogLevel.QUIET</code> - Zero output</p> <ul> <li>Use in CI/CD pipelines</li> <li>Minimal noise in build logs</li> <li>Recommended for production builds</li> </ul> <pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)\n}\n</code></pre> <p><code>LogLevel.INFO</code> - Concise summary (default)</p> <ul> <li>Shows generated fake count</li> <li>Cache hit rates</li> <li>Compilation time</li> <li>Ideal for local development</li> </ul> <pre><code>fakt {\n    logLevel.set(LogLevel.INFO)\n}\n</code></pre> <p>Example output: <pre><code>GENERATION: 121 fakes (avg 333\u00b5s/fake, 3,867 LOC)\nCACHE: 100% hit rate (121/121 from cache)\nTOTAL: 40ms\n</code></pre></p> <p><code>LogLevel.DEBUG</code> - Detailed breakdown</p> <ul> <li>FIR phase details</li> <li>IR generation per file</li> <li>Platform detection reasoning</li> <li>Performance metrics</li> </ul> <pre><code>fakt {\n    logLevel.set(LogLevel.DEBUG)\n}\n</code></pre> <p>Use for troubleshooting or understanding plugin behavior.</p>"},{"location":"guides/configuration.html#multi-module-configuration","title":"Multi-Module Configuration","text":"<p>Enable cross-module fake collection:</p> <pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"guides/configuration.html#opt-in-requirement","title":"Opt-In Requirement","text":"<p>Multi-module support requires explicit opt-in:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Experimental API</p> <p>Multi-module support is marked <code>@ExperimentalFaktMultiModule</code>. The API is production-ready but may evolve based on feedback.</p>"},{"location":"guides/configuration.html#complete-multi-module-setup","title":"Complete Multi-Module Setup","text":"<p>Producer module (<code>core/analytics/build.gradle.kts</code>): <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n\n    sourceSets.commonMain.dependencies {\n        implementation(libs.fakt.runtime)\n    }\n}\n\n// Fakes generated automatically in commonTest/\n</code></pre></p> <p>Collector module (<code>core/analytics-fakes/build.gradle.kts</code>): <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\nkotlin {\n    // MUST have ALL producer's targets\n    jvm()\n    iosArm64()\n\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)\n    }\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre></p> <p>Consumer module (<code>app/build.gradle.kts</code>): <pre><code>kotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre></p> <p>See Multi-Module Guide for architecture details.</p>"},{"location":"guides/configuration.html#ide-integration","title":"IDE Integration","text":""},{"location":"guides/configuration.html#intellij-idea-android-studio","title":"IntelliJ IDEA / Android Studio","text":"<p>Fakt-generated code appears in <code>build/generated/fakt/</code> and is automatically indexed.</p> <p>Enable K2 Mode for Better Autocomplete:</p> <ol> <li>Settings \u2192 Languages &amp; Frameworks \u2192 Kotlin</li> <li>Enable K2 mode</li> <li>Restart IDE</li> </ol> <p>K2 mode improves factory function autocomplete and type inference.</p>"},{"location":"guides/configuration.html#generated-sources-location","title":"Generated Sources Location","text":"Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code> <code>androidUnitTest/</code> <code>build/generated/fakt/androidUnitTest/kotlin/</code>"},{"location":"guides/configuration.html#cicd-best-practices","title":"CI/CD Best Practices","text":""},{"location":"guides/configuration.html#use-quiet-mode-in-pipelines","title":"Use QUIET Mode in Pipelines","text":"<pre><code>// build.gradle.kts\nfakt {\n    logLevel.set(\n        if (System.getenv(\"CI\") == \"true\") {\n            LogLevel.QUIET\n        } else {\n            LogLevel.INFO\n        }\n    )\n}\n</code></pre>"},{"location":"guides/configuration.html#gradle-configuration-cache","title":"Gradle Configuration Cache","text":"<p>Fakt 1.0.0-SNAPSHOT+ supports Gradle configuration cache:</p> <pre><code>// gradle.properties\norg.gradle.configuration-cache=true\n</code></pre>"},{"location":"guides/configuration.html#verify-cache-hit-rates","title":"Verify Cache Hit Rates","text":"<p>Monitor cache effectiveness in CI:</p> <pre><code>fakt {\n    logLevel.set(LogLevel.INFO)\n}\n</code></pre> <p>Check logs for: <pre><code>CACHE: 100% hit rate (121/121 from cache)\n</code></pre></p> <p>Low hit rates indicate unnecessary recompilation.</p>"},{"location":"guides/configuration.html#version-catalog-integration","title":"Version Catalog Integration","text":"<p><code>gradle/libs.versions.toml</code>:</p> <pre><code>[versions]\nfakt = \"1.0.0-SNAPSHOT\"\nkotlin = \"2.2.20\"\n\n[plugins]\nkotlin-multiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nfakt = { id = \"com.rsicarelli.fakt\", version.ref = \"fakt\" }\n\n[libraries]\nfakt-runtime = { module = \"com.rsicarelli.fakt:runtime\", version.ref = \"fakt\" }\n</code></pre> <p>Root <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform) apply false\n    alias(libs.plugins.fakt) apply false\n}\n</code></pre> <p>Module <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\nkotlin {\n    sourceSets.commonMain.dependencies {\n        implementation(libs.fakt.runtime)\n    }\n}\n</code></pre>"},{"location":"guides/configuration.html#performance-tuning","title":"Performance Tuning","text":""},{"location":"guides/configuration.html#check-build-impact","title":"Check Build Impact","text":"<p>Use <code>LogLevel.INFO</code> to measure overhead:</p> <pre><code>DISCOVERY: 1ms (100 interfaces, 21 classes)\nGENERATION: 39ms (121 new fakes, avg 333\u00b5s/fake)\nTOTAL: 40ms\n</code></pre>"},{"location":"guides/configuration.html#optimize-large-projects","title":"Optimize Large Projects","text":"<p>For projects with 100+ fakes:</p> <ol> <li>Enable incremental compilation (on by default)</li> <li>Use configuration cache</li> <li>Monitor cache hit rates</li> <li>Use QUIET mode in CI</li> </ol> <p>See Performance Guide for detailed benchmarks.</p>"},{"location":"guides/configuration.html#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"guides/configuration.html#verify-plugin-applied","title":"Verify Plugin Applied","text":"<pre><code>./gradlew :module:tasks --all | grep fakt\n</code></pre> <p>Should show Fakt-related tasks.</p>"},{"location":"guides/configuration.html#check-effective-configuration","title":"Check Effective Configuration","text":"<pre><code>./gradlew :module:build --info | grep -i fakt\n</code></pre> <p>Shows actual plugin settings used during compilation.</p>"},{"location":"guides/configuration.html#common-issues","title":"Common Issues","text":"<p>\u201cCannot resolve fakt { }\u201d</p> <ul> <li>Ensure plugin is applied in module\u2019s <code>build.gradle.kts</code></li> <li>Check version catalog references are correct</li> </ul> <p>\u201cExperimentalFaktMultiModule not found\u201d</p> <ul> <li>Add import: <code>import com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule</code></li> <li>Verify Fakt version is 1.0.0-SNAPSHOT+</li> </ul>"},{"location":"guides/configuration.html#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Module Setup - Cross-module fakes</li> <li>Performance Guide - Build time optimization</li> <li>Troubleshooting - Common configuration issues</li> <li>API Reference - Generated API details</li> </ul>"},{"location":"guides/migration-from-mocks.html","title":"Migration from MockK/Mockito","text":"<p>Migrating from runtime mocking frameworks to Fakt compile-time fakes.</p>"},{"location":"guides/migration-from-mocks.html#why-migrate","title":"Why Migrate?","text":"Aspect MockK/Mockito Fakt Platform Support JVM/Android only All KMP targets Runtime Cost Reflection overhead Zero (compile-time) Type Safety Runtime errors Compile-time errors Debugging Proxy magic Generated code Refactoring Silent failures Breaks at compile-time"},{"location":"guides/migration-from-mocks.html#mockk-fakt","title":"MockK \u2192 Fakt","text":"<p>MockK:</p> <pre><code>@Test\nfun `test with MockK`() {\n    val mock = mockk&lt;UserRepository&gt;()\n    every { mock.getUser(any()) } returns User(\"123\", \"Alice\")\n\n    val service = UserService(mock)\n    service.processUser(\"123\")\n\n    verify(exactly = 1) { mock.getUser(\"123\") }\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN fake repository WHEN processing user THEN calls getUser`() {\n    val fake = fakeUserRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    val service = UserService(fake)\n    service.processUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n}\n</code></pre>"},{"location":"guides/migration-from-mocks.html#mockito-fakt","title":"Mockito \u2192 Fakt","text":"<p>Mockito:</p> <pre><code>@Test\nfun `test with Mockito`() {\n    val mock = mock(UserRepository::class.java)\n    `when`(mock.getUser(anyString())).thenReturn(User(\"123\", \"Alice\"))\n\n    val service = UserService(mock)\n    service.processUser(\"123\")\n\n    verify(mock, times(1)).getUser(\"123\")\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN fake repository WHEN processing user THEN calls getUser`() {\n    val fake = fakeUserRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    val service = UserService(fake)\n    service.processUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n}\n</code></pre>"},{"location":"guides/migration-from-mocks.html#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Add Fakt plugin to <code>build.gradle.kts</code></li> <li>[ ] Annotate interfaces with <code>@Fake</code></li> <li>[ ] Build project to generate fakes</li> <li>[ ] Replace <code>mockk&lt;T&gt;()</code> / <code>mock(T::class.java)</code> with <code>fakeT {}</code></li> <li>[ ] Replace <code>every { }</code> / <code>when()</code> with DSL configuration</li> <li>[ ] Replace <code>verify { }</code> with call counter assertions</li> <li>[ ] Remove MockK/Mockito dependencies</li> </ul>"},{"location":"guides/migration-from-mocks.html#next-steps","title":"Next Steps","text":"<ul> <li>Testing Patterns - Best practices</li> <li>Performance - Build time impact</li> </ul>"},{"location":"guides/performance.html","title":"Performance","text":"<p>Fakt\u2019s compile-time impact and telemetry system.</p>"},{"location":"guides/performance.html#build-time-impact","title":"Build Time Impact","text":"<p>Fakt uses intelligent caching across KMP targets:</p> <p>First target compilation:</p> <pre><code>DISCOVERY: 1ms (100 interfaces, 21 classes)\nGENERATION: 39ms (121 new fakes, avg 333\u00b5s/fake)\nTOTAL: 40ms\n</code></pre> <p>Subsequent targets (cached):</p> <pre><code>compileKotlinJvm:     1ms (121 from cache)\ncompileKotlinAndroid: 1ms (121 from cache)\ncompileKotlinIosX64:  1ms (121 from cache)\n</code></pre>"},{"location":"guides/performance.html#telemetry-configuration","title":"Telemetry Configuration","text":"<p>Four log levels for debugging and performance analysis:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.LogLevel\n\nfakt {\n    logLevel.set(LogLevel.INFO)   // Default: concise summary\n    // LogLevel.QUIET  - Zero output (CI/CD)\n    // LogLevel.DEBUG  - Detailed breakdown with FIR + IR details\n}\n</code></pre>"},{"location":"guides/performance.html#log-level-outputs","title":"Log Level Outputs","text":"<p>INFO (default):</p> <pre><code>\u2705 10 fakes generated in 1.2s (6 cached)\n   Discovery: 120ms | Analysis: 340ms | Generation: 580ms\n   Cache hit rate: 40% (6/15)\n</code></pre> <p>DEBUG:</p> <pre><code>[DISCOVERY] 120ms - 15 interfaces, 3 classes\n[FILTERING] 85ms - Cache hits: 6/15 (40%)\n[ANALYSIS] 340ms\n  \u251c\u2500 UserRepository (18ms)\n  \u251c\u2500 Analytics (42ms)\n  \u251c\u2500 FIR + IR node inspection, type resolution\n</code></pre> <p>Includes full FIR + IR details, type resolution, etc. (~5-10ms overhead)</p>"},{"location":"guides/performance.html#cache-strategy","title":"Cache Strategy","text":"<p>Fakt caches generated code across:</p> <ul> <li>KMP targets (jvm, ios, android, etc.)</li> <li>Incremental compilation runs</li> <li>Clean builds (invalidates cache)</li> </ul>"},{"location":"guides/performance.html#best-practices","title":"Best Practices","text":""},{"location":"guides/performance.html#use-quiet-in-cicd","title":"\u2705 Use QUIET in CI/CD","text":"<pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)  // Zero overhead\n}\n</code></pre>"},{"location":"guides/performance.html#use-debug-for-troubleshooting","title":"\u2705 Use DEBUG for Troubleshooting","text":"<pre><code>fakt {\n    logLevel.set(LogLevel.DEBUG)  // ~5-10ms overhead\n}\n</code></pre>"},{"location":"guides/performance.html#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Plugin options</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"guides/testing-patterns.html","title":"Testing Patterns","text":"<p>Best practices for using Fakt-generated fakes in your test suites.</p>"},{"location":"guides/testing-patterns.html#given-when-then-pattern","title":"GIVEN-WHEN-THEN Pattern","text":"<p>Follow BDD-style test naming with Fakt fakes:</p> <pre><code>@Test\nfun `GIVEN configured repository WHEN saving user THEN returns success`() = runTest {\n    // GIVEN\n    val fake = fakeUserRepository {\n        saveUser { user -&gt; Result.success(Unit) }\n    }\n    val service = UserService(fake)\n\n    // WHEN\n    val result = service.createUser(\"Alice\")\n\n    // THEN\n    assertTrue(result.isSuccess)\n    assertEquals(1, fake.saveUserCallCount.value)\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#isolated-fakes-per-test","title":"Isolated Fakes Per Test","text":"<p>Create fresh fakes for each test to avoid shared state:</p> <pre><code>class UserServiceTest {\n    @Test\n    fun `test case 1`() {\n        val fake = fakeRepository {  // Fresh fake\n            getUser { id -&gt; User(id, \"Alice\") }\n        }\n        // Test with Alice\n    }\n\n    @Test\n    fun `test case 2`() {\n        val fake = fakeRepository {  // Fresh fake\n            getUser { id -&gt; User(id, \"Bob\") }\n        }\n        // Test with Bob\n    }\n}\n</code></pre> <p>Why this matters: - Prevents test pollution (one test affecting another) - Makes tests order-independent - Easier to understand test setup</p>"},{"location":"guides/testing-patterns.html#configure-only-what-you-need","title":"Configure Only What You Need","text":"<p>Don\u2019t configure methods you don\u2019t use in the test:</p> <pre><code>@Test\nfun `GIVEN repository WHEN getting user THEN returns user`() {\n    val fake = fakeRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n        // Don't configure saveUser, deleteUser, etc. if not used\n    }\n\n    val user = fake.getUser(\"123\")\n    assertEquals(\"Alice\", user.name)\n}\n</code></pre> <p>Benefits: - Tests are easier to read (only relevant setup visible) - Reduces noise in test code - Smart defaults handle unconfigured methods</p>"},{"location":"guides/testing-patterns.html#verify-behavior-not-implementation","title":"Verify Behavior, Not Implementation","text":"<p>Use call counters to verify interactions:</p> <pre><code>@Test\nfun `GIVEN service WHEN processing user THEN calls repository once`() {\n    val fakeRepo = fakeRepository()\n    val service = UserService(fakeRepo)\n\n    service.processUser(\"123\")\n\n    assertEquals(1, fakeRepo.getUserCallCount.value)\n    assertEquals(1, fakeRepo.saveUserCallCount.value)\n}\n</code></pre> <p>State-based verification example:</p> <pre><code>@Test\nfun `GIVEN repository WHEN saving users THEN all users are saved`() {\n    val savedUsers = mutableListOf&lt;User&gt;()\n    val fake = fakeRepository {\n        saveUser { user -&gt;\n            savedUsers.add(user)\n            Result.success(Unit)\n        }\n    }\n\n    val service = UserService(fake)\n    service.batchSave(listOf(alice, bob))\n\n    // Verify OUTCOME (state), not method calls\n    assertEquals(2, savedUsers.size)\n    assertTrue(savedUsers.contains(alice))\n    assertTrue(savedUsers.contains(bob))\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#test-edge-cases","title":"Test Edge Cases","text":"<p>Configure fakes to test error handling:</p> <pre><code>@Test\nfun `GIVEN repository failure WHEN saving user THEN handles error`() = runTest {\n    val fake = fakeRepository {\n        saveUser { user -&gt;\n            Result.failure(NetworkException())\n        }\n    }\n    val service = UserService(fake)\n\n    val result = service.createUser(\"Alice\")\n\n    assertTrue(result.isFailure)\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#use-turbine-for-reactive-testing","title":"Use Turbine for Reactive Testing","text":"<p>Test StateFlow call counters reactively:</p> <pre><code>@Test\nfun `GIVEN fake WHEN calling repeatedly THEN emits counts`() = runTest {\n    val fake = fakeAnalytics()\n\n    fake.trackCallCount.test {\n        assertEquals(0, awaitItem())\n\n        fake.track(\"event1\")\n        assertEquals(1, awaitItem())\n\n        fake.track(\"event2\")\n        assertEquals(2, awaitItem())\n    }\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":""},{"location":"guides/testing-patterns.html#shared-fakes-across-tests","title":"\u274c Shared Fakes Across Tests","text":"<pre><code>// \u274c BAD: Shared fake\nclass UserServiceTest {\n    private val sharedFake = fakeRepository()  // State leaks between tests\n\n    @Test\n    fun test1() { /* uses sharedFake */ }\n\n    @Test\n    fun test2() { /* uses same sharedFake - FLAKY! */ }\n}\n</code></pre> <pre><code>// \u2705 GOOD: Fresh fake per test\nclass UserServiceTest {\n    @Test\n    fun test1() {\n        val fake = fakeRepository()  // Isolated\n    }\n\n    @Test\n    fun test2() {\n        val fake = fakeRepository()  // Independent\n    }\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#over-configuring-fakes","title":"\u274c Over-Configuring Fakes","text":"<pre><code>// \u274c BAD: Configuring unused methods\n@Test\nfun `test getUser only`() {\n    val fake = fakeRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n        saveUser { /* not used in this test */ }\n        deleteUser { /* not used in this test */ }\n        listUsers { /* not used in this test */ }\n    }\n\n    val user = fake.getUser(\"123\")  // Only this is tested\n}\n</code></pre> <pre><code>// \u2705 GOOD: Configure only what's needed\n@Test\nfun `test getUser only`() {\n    val fake = fakeRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n        // Smart defaults handle the rest\n    }\n\n    val user = fake.getUser(\"123\")\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#next-steps","title":"Next Steps","text":"<ul> <li>Migration Guide - From MockK/Mockito to Fakt</li> <li>Performance - Build time impact and optimization</li> <li>Basic Usage - Core patterns and examples</li> </ul>"},{"location":"introduction/features.html","title":"Features","text":"<p>Comprehensive overview of what Fakt supports and how it works.</p>"},{"location":"introduction/features.html#supported-class-types","title":"Supported Class Types","text":"<p>Fakt can generate fakes for these Kotlin types:</p>"},{"location":"introduction/features.html#interfaces","title":"\u2705 Interfaces","text":"<p>The primary use case\u2014clean contracts without implementation:</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): User\n    fun deleteUser(id: String): Boolean\n}\n</code></pre>"},{"location":"introduction/features.html#abstract-classes","title":"\u2705 Abstract Classes","text":"<p>Abstract classes with abstract members:</p> <pre><code>@Fake\nabstract class BaseService {\n    abstract fun start(): Boolean\n    abstract val isRunning: Boolean\n}\n</code></pre>"},{"location":"introduction/features.html#open-classes","title":"\u2705 Open Classes","text":"<p>Open classes with overridable members (only overridable members are faked):</p> <pre><code>@Fake\nopen class NetworkClient {\n    open suspend fun fetch(url: String): Result&lt;String&gt; =\n        Result.failure(NotImplementedError())\n}\n</code></pre>"},{"location":"introduction/features.html#data-classes","title":"\u274c Data Classes","text":"<p>Data classes have compiler-generated implementations and can\u2019t be faked. Use builders or <code>copy()</code> instead.</p> <p>Works as parameter/return types:</p> <pre><code>data class User(val id: String, val name: String)\n\n@Fake  // \u2705 This works\ninterface UserRepository {\n    fun getUser(id: String): User  // \u2705 Data class as return type\n}\n</code></pre>"},{"location":"introduction/features.html#sealed-classesinterfaces","title":"\u274c Sealed Classes/Interfaces","text":"<p>Sealed hierarchies can\u2019t be faked directly. Use exhaustive when-expressions or visitor patterns.</p> <p>Works as parameter/return types:</p> <pre><code>sealed interface Result&lt;out T&gt;\ndata class Success&lt;T&gt;(val value: T) : Result&lt;T&gt;\ndata class Failure(val error: Throwable) : Result&lt;Nothing&gt;\n\n@Fake  // \u2705 This works\ninterface Repository {\n    fun save(data: String): Result&lt;Unit&gt;  // \u2705 Sealed class as return type\n}\n</code></pre>"},{"location":"introduction/features.html#type-system-support","title":"Type System Support","text":""},{"location":"introduction/features.html#generics","title":"\u2705 Generics","text":"<p>Full generic support with smart defaults:</p> <p>Class-level generics:</p> <pre><code>@Fake\ninterface Repository&lt;T&gt; {\n    fun save(item: T): Result&lt;Unit&gt;\n    fun getAll(): List&lt;T&gt;\n}\n\nval fake = fakeRepository&lt;User&gt; {\n    save { item -&gt; Result.success(Unit) }\n    getAll { emptyList() }\n}\n</code></pre> <p>Method-level generics:</p> <pre><code>@Fake\ninterface Transformer {\n    fun &lt;T, R&gt; transform(input: T, mapper: (T) -&gt; R): R\n}\n\nval fake = fakeTransformer {\n    transform { input, mapper -&gt; mapper(input) }  // Identity function default\n}\n</code></pre> <p>Generic constraints:</p> <pre><code>@Fake\ninterface ComparableRepository&lt;T : Comparable&lt;T&gt;&gt; {\n    fun findMax(items: List&lt;T&gt;): T?\n}\n\nval fake = fakeComparableRepository&lt;Int&gt; {\n    findMax { items -&gt; items.maxOrNull() }\n}\n</code></pre> <p>Variance:</p> <pre><code>@Fake\ninterface Producer&lt;out T&gt; {\n    fun produce(): T\n}\n\n@Fake\ninterface Consumer&lt;in T&gt; {\n    fun consume(item: T)\n}\n</code></pre>"},{"location":"introduction/features.html#nullable-types","title":"\u2705 Nullable Types","text":"<p>Full support for nullable types with <code>null</code> defaults:</p> <pre><code>@Fake\ninterface UserService {\n    fun findUser(id: String): User?\n    suspend fun getCurrentUser(): User?\n}\n\nval fake = fakeUserService {\n    findUser { id -&gt; null }  // Default: null\n    getCurrentUser { User(\"123\", \"Alice\") }\n}\n</code></pre>"},{"location":"introduction/features.html#complex-standard-library-types","title":"\u2705 Complex Standard Library Types","text":"<p>Fakt handles common stdlib types (<code>Result&lt;T&gt;</code>, <code>List&lt;T&gt;</code>, <code>Map&lt;K,V&gt;</code>, <code>Set&lt;T&gt;</code>, etc.) with smart empty defaults.</p> <p>For complete default behavior reference, see Why Fakt: Smart Defaults.</p>"},{"location":"introduction/features.html#kotlin-language-features","title":"Kotlin Language Features","text":""},{"location":"introduction/features.html#suspend-functions","title":"\u2705 Suspend Functions","text":"<p>Full coroutine support\u2014no weird <code>runBlocking</code> wrappers. Suspend functions work naturally in <code>runTest</code> blocks with proper coroutine context handling.</p> <p>For detailed examples and testing patterns, see Suspend Functions Guide.</p>"},{"location":"introduction/features.html#properties","title":"\u2705 Properties","text":"<p>Both read-only (<code>val</code>) and mutable (<code>var</code>) properties:</p> <p>Read-only properties:</p> <pre><code>@Fake\ninterface Config {\n    val apiUrl: String\n    val timeout: Int\n}\n\nval fake = fakeConfig {\n    apiUrl { \"https://api.example.com\" }\n    timeout { 30 }\n}\n\nassertEquals(\"https://api.example.com\", fake.apiUrl)\nassertEquals(1, fake.apiUrlCallCount.value)  // Call tracking\n</code></pre> <p>Mutable properties:</p> <pre><code>@Fake\ninterface Settings {\n    var theme: String\n    var fontSize: Int\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n    fontSize { 14 }\n}\n\n// Getter tracking\nassertEquals(\"dark\", fake.theme)\nassertEquals(1, fake.getThemeCallCount.value)\n\n// Setter tracking\nfake.theme = \"light\"\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"introduction/features.html#default-parameters","title":"\u2705 Default Parameters","text":"<p>Methods with default parameters are supported (defaults are ignored):</p> <pre><code>@Fake\ninterface Logger {\n    fun log(message: String, level: LogLevel = LogLevel.INFO)\n}\n\nval fake = fakeLogger {\n    log { message, level -&gt;\n        println(\"[$level] $message\")\n    }\n}\n\nfake.log(\"Error occurred\", LogLevel.ERROR)\nfake.log(\"Info message\")  // Uses interface's default\n</code></pre>"},{"location":"introduction/features.html#inheritance","title":"\u2705 Inheritance","text":"<p>Fakt handles inheritance correctly:</p> <pre><code>interface BaseRepository {\n    fun getId(): String\n}\n\n@Fake\ninterface UserRepository : BaseRepository {\n    suspend fun getUser(id: String): User\n}\n\nval fake = fakeUserRepository {\n    getId { \"repo-123\" }  // Inherited method\n    getUser { id -&gt; User(id, \"Alice\") }\n}\n</code></pre>"},{"location":"introduction/features.html#call-tracking","title":"Call Tracking","text":""},{"location":"introduction/features.html#built-in-stateflow-counters","title":"Built-In StateFlow Counters","text":"<p>Every method and property gets automatic call tracking:</p> <pre><code>@Fake\ninterface Analytics {\n    fun track(event: String)\n    suspend fun identify(userId: String)\n    val sessionId: String\n}\n\nval fake = fakeAnalytics {\n    track { event -&gt; println(event) }\n    identify { userId -&gt; }\n    sessionId { \"session-123\" }\n}\n\nfake.track(\"event1\")\nfake.track(\"event2\")\n\n// Thread-safe call counting\nassertEquals(2, fake.trackCallCount.value)\nassertEquals(0, fake.identifyCallCount.value)\n\n// Property tracking\nval id = fake.sessionId\nassertEquals(1, fake.sessionIdCallCount.value)\n</code></pre>"},{"location":"introduction/features.html#reactive-testing","title":"Reactive Testing","text":"<p>StateFlow counters work seamlessly with Kotlin Flow test utilities like Turbine.</p> <p>See Call Tracking Guide for reactive testing patterns.</p>"},{"location":"introduction/features.html#code-generation-patterns","title":"Code Generation Patterns","text":"<p>Fakt generates production-quality code with smart defaults, type-safe DSLs, and factory functions. For details on default behaviors, see Why Fakt: Technical Advantages.</p>"},{"location":"introduction/features.html#type-safe-dsl","title":"Type-Safe DSL","text":"<p>Every fake includes a type-safe configuration DSL where lambdas match the original method signatures. The compiler catches type errors at build time.</p> <p>See Getting Started for examples and Basic Usage for patterns.</p>"},{"location":"introduction/features.html#factory-functions","title":"Factory Functions","text":"<p>Generated factory functions follow Kotlin naming conventions: <code>fake{InterfaceName}</code> (e.g., <code>fakeUserRepository</code>, <code>fakeApiClient</code>).</p> <p>See API Reference for complete naming rules and generated code structure.</p>"},{"location":"introduction/features.html#multi-module-support-experimental","title":"Multi-Module Support (Experimental)","text":"<p>Cross-module fake consumption via dedicated <code>-fakes</code> modules:</p> <pre><code>// Producer module: :core:analytics\n@Fake\ninterface Analytics\n\n// Collector module: :core:analytics-fakes\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\n// Consumer module: :app\ndependencies {\n    commonTest {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre> <p>For complete documentation, see Multi-Module Overview.</p>"},{"location":"introduction/features.html#performance-features","title":"Performance Features","text":""},{"location":"introduction/features.html#intelligent-caching","title":"Intelligent Caching","text":"<p>Fakt caches generated code across KMP targets:</p> <ul> <li>First target: Full generation (~40ms for 100 interfaces)</li> <li>Subsequent targets: Cache hits (~1ms each)</li> </ul>"},{"location":"introduction/features.html#telemetry-configuration","title":"Telemetry Configuration","text":"<p>Four log levels for debugging and performance analysis:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.LogLevel\n\nfakt {\n    logLevel.set(LogLevel.INFO)   // Default: concise summary\n    // LogLevel.QUIET  - Zero output (CI/CD)\n    // LogLevel.DEBUG  - Detailed breakdown with FIR + IR details\n}\n</code></pre> <p>See Performance Guide for benchmarks.</p>"},{"location":"introduction/features.html#platform-support","title":"Platform Support","text":"<p>Works on ALL Kotlin Multiplatform targets:</p> <ul> <li>\u2705 JVM, Android</li> <li>\u2705 iOS (arm64, x64, simulator)</li> <li>\u2705 macOS, Linux, Windows</li> <li>\u2705 JavaScript (IR), WebAssembly</li> <li>\u2705 watchOS, tvOS</li> </ul> <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p>"},{"location":"introduction/features.html#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Get started with fakes</li> <li>Suspend Functions - Async patterns</li> <li>Generics - Generic type handling</li> <li>Call Tracking - StateFlow counters</li> </ul>"},{"location":"introduction/getting-started.html","title":"Getting Started","text":"<p>Get Fakt up and running in your project and create your first fake in 5 minutes.</p>"},{"location":"introduction/getting-started.html#prerequisites","title":"Prerequisites","text":"Requirement Version Kotlin 2.2.20+ Gradle 8.0+ JVM 11+"},{"location":"introduction/getting-started.html#installation","title":"Installation","text":""},{"location":"introduction/getting-started.html#multiplatform-projects","title":"Multiplatform Projects","text":"<p>Version Catalog (<code>gradle/libs.versions.toml</code>):</p> <pre><code>[versions]\nfakt = \"1.0.0-SNAPSHOT\"\nkotlin = \"2.2.20\"\n\n[plugins]\nkotlin-multiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nfakt = { id = \"com.rsicarelli.fakt\", version.ref = \"fakt\" }\n\n[libraries]\nfakt-runtime = { module = \"com.rsicarelli.fakt:runtime\", version.ref = \"fakt\" }\n</code></pre> <p>Root <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform) apply false\n    alias(libs.plugins.fakt) apply false\n}\n</code></pre> <p>Module <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\nkotlin {\n    // Your KMP targets\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain.dependencies {\n            implementation(libs.fakt.runtime)\n        }\n    }\n}\n</code></pre> <p>\u2026and that\u2019s it!</p>"},{"location":"introduction/getting-started.html#single-platform-projects","title":"Single-Platform Projects","text":"<p>Fakt works with single-platform Kotlin projects too:</p> <p>JVM-Only:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\ndependencies {\n    implementation(libs.fakt.runtime)\n}\n</code></pre> <p>Android-Only:</p> <pre><code>plugins {\n    id(\"com.android.library\")\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\ndependencies {\n    implementation(libs.fakt.runtime)\n}\n</code></pre>"},{"location":"introduction/getting-started.html#your-first-fake-5-minutes","title":"Your First Fake (5 Minutes)","text":""},{"location":"introduction/getting-started.html#step-1-annotate-an-interface","title":"Step 1: Annotate an Interface","text":"<p>Create an interface and mark it with <code>@Fake</code>:</p> <pre><code>// src/commonMain/kotlin/com/example/Analytics.kt\npackage com.example\n\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n}\n</code></pre>"},{"location":"introduction/getting-started.html#step-2-build-your-project","title":"Step 2: Build Your Project","text":"<p>Run Gradle build to generate the fake:</p> <pre><code>./gradlew build\n</code></pre> <p>Fakt generates <code>FakeAnalyticsImpl</code> in <code>build/generated/fakt/commonTest/kotlin/com/example/</code>.</p>"},{"location":"introduction/getting-started.html#step-3-use-in-tests","title":"Step 3: Use in Tests","text":"<p>The generated fake includes a factory function and DSL:</p> <pre><code>// src/commonTest/kotlin/com/example/AnalyticsTest.kt\npackage com.example\n\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AnalyticsTest {\n    @Test\n    fun `GIVEN configured fake WHEN tracking event THEN captures call`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val fake = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n        }\n\n        fake.track(\"user_signup\")\n\n        assertEquals(listOf(\"user_signup\"), events)\n        assertEquals(1, fake.trackCallCount.value)\n    }\n}\n</code></pre>"},{"location":"introduction/getting-started.html#understanding-generated-code","title":"Understanding Generated Code","text":"<p>Fakt generates three components for each <code>@Fake</code> interface:</p>"},{"location":"introduction/getting-started.html#1-implementation-class","title":"1. Implementation Class","text":"<pre><code>class FakeAnalyticsImpl : Analytics {\n    private var trackBehavior: (String) -&gt; Unit = { }\n    private val _trackCallCount = MutableStateFlow(0)\n    val trackCallCount: StateFlow&lt;Int&gt; get() = _trackCallCount\n\n    override fun track(event: String) {\n        _trackCallCount.update { it + 1 }\n        trackBehavior(event)\n    }\n\n    internal fun configureTrack(behavior: (String) -&gt; Unit) {\n        trackBehavior = behavior\n    }\n}\n</code></pre>"},{"location":"introduction/getting-started.html#2-factory-function","title":"2. Factory Function","text":"<pre><code>fun fakeAnalytics(\n    configure: FakeAnalyticsConfig.() -&gt; Unit = {}\n): FakeAnalyticsImpl = FakeAnalyticsImpl().apply {\n    FakeAnalyticsConfig(this).configure()\n}\n</code></pre>"},{"location":"introduction/getting-started.html#3-configuration-dsl","title":"3. Configuration DSL","text":"<pre><code>class FakeAnalyticsConfig(private val fake: FakeAnalyticsImpl) {\n    fun track(behavior: (String) -&gt; Unit) {\n        fake.configureTrack(behavior)\n    }\n}\n</code></pre>"},{"location":"introduction/getting-started.html#generated-code-location","title":"Generated Code Location","text":"<p>Fakt generates code in test source sets only:</p> Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code> <code>androidUnitTest/</code> <code>build/generated/fakt/androidUnitTest/kotlin/</code> <p>Note</p> <p>Generated code never appears in production builds. Fakt is test-only.</p>"},{"location":"introduction/getting-started.html#more-complex-example","title":"More Complex Example","text":"<p>Here\u2019s a realistic interface with suspend functions and generics:</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n    suspend fun saveUser(user: User): Result&lt;Unit&gt;\n    val currentUser: User?\n}\n</code></pre> <p>Using it in tests:</p> <pre><code>import kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertTrue\n\nclass UserRepositoryTest {\n    @Test\n    fun `GIVEN fake repository WHEN saving user THEN returns success`() = runTest {\n        val savedUsers = mutableListOf&lt;User&gt;()\n\n        val fake = fakeUserRepository {\n            saveUser { user -&gt;\n                savedUsers.add(user)\n                Result.success(Unit)\n            }\n            getUser { id -&gt;\n                Result.success(User(id, \"Alice\"))\n            }\n            currentUser { User(\"123\", \"Bob\") }\n        }\n\n        val result = fake.saveUser(User(\"456\", \"Charlie\"))\n\n        assertTrue(result.isSuccess)\n        assertEquals(1, savedUsers.size)\n        assertEquals(\"Charlie\", savedUsers.first().name)\n        assertEquals(1, fake.saveUserCallCount.value)\n    }\n}\n</code></pre>"},{"location":"introduction/getting-started.html#ide-support","title":"IDE Support","text":"<p>Fakt-generated code appears in <code>build/generated/fakt/</code> and is automatically indexed by IntelliJ IDEA and Android Studio.</p> <p>K2 IDE Mode</p> <p>Enable K2 mode for better autocomplete of generated factories:</p> <p>Settings \u2192 Languages &amp; Frameworks \u2192 Kotlin \u2192 Enable K2 mode</p>"},{"location":"introduction/getting-started.html#kotlin-version-compatibility","title":"Kotlin Version Compatibility","text":"Fakt Version Kotlin Version Support 1.0.0-SNAPSHOT 2.2.20 - 2.2.30 <p>Fakt follows forward compatibility on a best-effort basis (usually N+.2 minor versions).</p>"},{"location":"introduction/getting-started.html#next-steps","title":"Next Steps","text":"<ul> <li>Features - Complete feature reference</li> <li>Basic Usage - Common patterns and examples</li> <li>Suspend Functions - Async/coroutine support</li> <li>Call Tracking - StateFlow-based reactive counters</li> <li>Testing Patterns - Best practices</li> <li>Configuration - Plugin options (coming soon)</li> </ul>"},{"location":"introduction/why-fakt.html","title":"Why Fakt?","text":"<p>The story behind building a compile-time fake generator for Kotlin testing.</p>"},{"location":"introduction/why-fakt.html#introduction","title":"Introduction","text":"<p>Fakt is a Kotlin compiler plugin that eliminates the boilerplate of writing test fakes by generating them at compile-time.</p> <p>Add <code>@Fake</code> annotation. Fakt generates everything automatically:</p> <pre><code>@Fake\ninterface AnalyticsService {\n    fun track(event: String)\n}\n\n// Generated factory + DSL (zero boilerplate)\nval fake = fakeAnalyticsService {\n    track { event -&gt; println(\"Tracked: $event\") }\n}\n\nfake.track(\"user_signup\")\nassertEquals(1, fake.trackCallCount.value)\n</code></pre> <p>What Fakt generates:</p> <ol> <li>Implementation class with thread-safe StateFlow call tracking</li> <li>Factory function with clean DSL (<code>fakeXxx {}</code>)</li> <li>Configuration DSL for behavior setup</li> </ol>"},{"location":"introduction/why-fakt.html#the-problem-manual-fakes-are-tedious-mocks-are-costly","title":"The Problem: Manual Fakes Are Tedious, Mocks Are Costly","text":"<p>Modern Kotlin development faces a testing dilemma. Writing test doubles (fakes, mocks, stubs) manually is time-consuming and error-prone. Runtime mocking frameworks solve the boilerplate problem but introduce severe performance penalties and architectural limitations. Fakt was created to address both challenges.</p>"},{"location":"introduction/why-fakt.html#the-manual-fake-burden","title":"The Manual Fake Burden","text":"<p>Consider a simple interface requiring a test double:</p> <pre><code>interface AnalyticsService {\n    fun track(event: String)\n    suspend fun flush(): Result&lt;Unit&gt;\n}\n</code></pre> <p>A proper, production-quality fake requires ~60-80 lines of boilerplate:</p> <pre><code>class FakeAnalyticsService : AnalyticsService {\n    // Behavior configuration\n    private var trackBehavior: ((String) -&gt; Unit)? = null\n    private var flushBehavior: (suspend () -&gt; Result&lt;Unit&gt;)? = null\n\n    // Call tracking (non-thread-safe!)\n    private var _trackCallCount = 0\n    val trackCallCount: Int get() = _trackCallCount\n\n    private var _flushCallCount = 0\n    val flushCallCount: Int get() = _flushCallCount\n\n    // Interface implementation\n    override fun track(event: String) {\n        _trackCallCount++\n        trackBehavior?.invoke(event) ?: Unit\n    }\n\n    override suspend fun flush(): Result&lt;Unit&gt; {\n        _flushCallCount++\n        return flushBehavior?.invoke() ?: Result.success(Unit)\n    }\n\n    // Configuration methods\n    fun configureTrack(behavior: (String) -&gt; Unit) {\n        trackBehavior = behavior\n    }\n\n    fun configureFlush(behavior: suspend () -&gt; Result&lt;Unit&gt;) {\n        flushBehavior = behavior\n    }\n}\n</code></pre> <p>Critical issues: - Non-thread-safe call tracking (<code>var count = 0</code>) breaks under concurrent tests - Maintenance burden scales with interface complexity (N methods = ~30N lines) - Silent refactoring failures (interface signature changes don\u2019t break unused fakes) - Copy-paste errors accumulate across dozens of fakes</p> <p>For a codebase with 50+ interfaces requiring fakes, this represents thousands of lines of brittle, repetitive boilerplate.</p>"},{"location":"introduction/why-fakt.html#the-runtime-mocking-crisis-two-independent-failures","title":"The Runtime Mocking Crisis: Two Independent Failures","text":"<p>Runtime mocking frameworks (MockK, Mockito) solve the boilerplate problem through reflection and bytecode instrumentation. However, this \u201cmagic\u201d approach faces two critical, independent failures that make it unsustainable for modern Kotlin development.</p>"},{"location":"introduction/why-fakt.html#failure-1-the-jvm-mock-tax-performance-crisis","title":"Failure 1: The JVM \u201cMock Tax\u201d (Performance Crisis)","text":"<p>Kotlin\u2019s design\u2014final classes by default\u2014creates a fundamental conflict with Java-based mocking tools. Mockito was built for a world where Java classes are <code>open</code> by default, allowing runtime subclassing. Kotlin\u2019s <code>final</code> classes block this mechanism.</p>"},{"location":"introduction/why-fakt.html#the-four-bad-workarounds","title":"The Four Bad Workarounds","text":"<p>Kotlin developers are forced to choose between four sub-optimal solutions:</p> <ol> <li>Manual <code>open</code> keyword - Pollutes production code with test-only concerns</li> <li><code>all-open</code> compiler plugin - Compromises Kotlin\u2019s safety guarantees</li> <li>Mockito\u2019s <code>mock-maker-inline</code> - Uses bytecode instrumentation (slow)</li> <li>MockK\u2019s default behavior - Bundles instrumentation by default (hidden cost)</li> </ol>"},{"location":"introduction/why-fakt.html#verified-performance-penalties","title":"Verified Performance Penalties","text":"<p>Independent benchmarks<sup>1</sup> quantify the \u201cMock Tax\u201d\u2014severe performance degradation when mocking idiomatic Kotlin patterns:</p> Mocking Pattern Framework Comparison Verified Penalty <code>mockkObject</code> (Singletons) MockK vs. Dependency Injection 1,391x slower <code>mockkStatic</code> (Top-level functions) MockK vs. Interface-based DI 146x slower <code>verify { ... }</code> (Interaction verification) MockK vs. State-based testing 47x slower <code>relaxed</code> mocks (Unstubbed calls) MockK vs. Strict mocks 3.7x slower <code>mock-maker-inline</code> Mockito vs. <code>all-open</code> plugin 2.7-3x slower<sup>26</sup><sup>2</sup> <p>Real-world impact: A production test suite with 2,668 tests experienced a 2.7x slowdown (7.3s \u2192 20.0s) when using <code>mock-maker-inline</code> instead of the <code>all-open</code> plugin<sup>2</sup>. For large projects, this \u201cMock Tax\u201d accumulates to 40% slower test suites<sup>1</sup>.</p> <p>The testing framework actively punishes developers for using Kotlin\u2019s most idiomatic features (objects, top-level functions, extension functions).</p>"},{"location":"introduction/why-fakt.html#failure-2-the-kmp-dead-end-architectural-impossibility","title":"Failure 2: The KMP Dead End (Architectural Impossibility)","text":"<p>Kotlin Multiplatform (KMP) has exploded in adoption\u2014Google, Netflix, Cash App, and JetBrains all use it in production. But runtime mocking is fundamentally incompatible with non-JVM targets.</p>"},{"location":"introduction/why-fakt.html#why-runtime-mocking-cannot-work-in-kmp","title":"Why Runtime Mocking Cannot Work in KMP","text":"<p>Runtime mocking relies on JVM-specific features:</p> <ul> <li>Reflection - Inspect and modify code at runtime</li> <li>Bytecode instrumentation - Change class definitions after loading</li> <li>Dynamic proxies - Generate \u201cmagic\u201d classes on the fly</li> </ul> <p>Kotlin/Native (iOS, Desktop) and Kotlin/Wasm compile to native machine code. They have no JVM. Reflection is severely limited<sup>3</sup><sup>4</sup>, bytecode doesn\u2019t exist, and dynamic proxies are impossible.</p> <p>Conclusion: MockK and Mockito cannot run in <code>commonTest</code> source sets targeting Native or Wasm<sup>5</sup><sup>6</sup>. Runtime mocking is a dead end for the entire KMP ecosystem.</p>"},{"location":"introduction/why-fakt.html#the-ksp-workaround-crisis","title":"The KSP \u201cWorkaround\u201d Crisis","text":"<p>The KMP community attempted compile-time code generation via KSP (Kotlin Symbol Processing), creating tools like Mockative, MocKMP, and Mokkery. This ecosystem is in crisis:</p> <p>Kotlin 2.0 Breakage (Verified): - The K2 compiler \u201cfails to handle common metadata tasks properly\u201d in <code>commonTest</code> source sets<sup>7</sup> - Real-world example: StreetComplete app (10,000+ tests) forced to migrate from Mockative to Mokkery due to K2 incompatibility<sup>7</sup> - Mockative maintainer not providing clear K2 migration path<sup>7</sup></p> <p>Feature Limitations: - Mokkery cannot mock: <code>object</code>, <code>sealed</code>, top-level functions, final classes (without <code>all-open</code>)<sup>7</sup> - MocKMP can only mock interfaces, no relaxed mocks<sup>8</sup></p> <p>Strategic failure: The KSP \u201csolutions\u201d cannot even solve the original Kotlin problems (objects, top-level functions) that create JVM performance penalties.</p>"},{"location":"introduction/why-fakt.html#the-philosophical-foundation-why-fakes-reduce-brittleness","title":"The Philosophical Foundation: Why Fakes Reduce Brittleness","text":"<p>Beyond performance, the \u201cfakes over mocks\u201d movement represents a fundamental shift in testing philosophy, rooted in decades of TDD (Test-Driven Development) debate.</p>"},{"location":"introduction/why-fakt.html#state-based-vs-interaction-based-testing","title":"State-Based vs. Interaction-Based Testing","text":"<p>Martin Fowler\u2019s seminal \u201cMocks Aren\u2019t Stubs\u201d<sup>9</sup> describes two testing schools:</p> <p>State-Based Testing (Classic/Detroit School): - Uses fakes and stubs to provide inputs - Verifies the resulting state of the system - Test assertion: \u201cAfter calling <code>saveUser</code>, is the user in the fake repository?\u201d</p> <p>Interaction-Based Testing (London School): - Uses mocks to verify method calls - Verifies how a unit communicates with collaborators - Test assertion: \u201cWas <code>repository.saveUser()</code> called exactly once with the correct user?\u201d</p>"},{"location":"introduction/why-fakt.html#the-refactoring-problem","title":"The Refactoring Problem","text":"<p>Mock-based tests couple to implementation details, not outcomes<sup>10</sup>. Consider this refactoring:</p> <p>Before: <pre><code>// SUT implementation\nfun checkout() {\n    repository.saveOrder(order)\n}\n\n// Mock-based test\nverify { repository.saveOrder(order) }\n</code></pre></p> <p>After (valid refactoring): <pre><code>// SUT implementation\nfun checkout() {\n    repository.saveOrderWithAudit(order, auditLog = true) // New overload\n}\n\n// Mock-based test BREAKS (false negative)\nverify { repository.saveOrder(order) } // \u274c Fails!\n</code></pre></p> <p>The outcome is identical (order is saved), but the process changed. The mock-based test reports a failure even though no bug was introduced. This creates a vicious cycle: brittle tests discourage refactoring, leading to code rot.</p> <p>Google\u2019s \u201cTesting on the Toilet\u201d papers define resilience as a critical test quality: \u201cA test shouldn\u2019t fail if the code under test isn\u2019t defective\u201d<sup>11</sup>. Mock-based tests violate this principle.</p>"},{"location":"introduction/why-fakt.html#the-virtuous-cycle-of-fakes","title":"The Virtuous Cycle of Fakes","text":"<p>Fake-based testing with state verification creates resilient tests:</p> <pre><code>// Fake-based test (survives refactoring)\nval fake = fakeRepository()\nviewModel.checkout()\n\n// Assert the OUTCOME, not the process\nassertEquals(1, fake.orders.size)\nassertTrue(fake.orders.contains(order))\n</code></pre> <p>This test continues passing after the refactoring because it verifies what happened (order was saved), not how it happened (which method was called). Kent Beck observed that mocks \u201cslow down refactoring\u2026 because of the higher coupling between your tests and the actual implementation\u201d<sup>12</sup>.</p>"},{"location":"introduction/why-fakt.html#industry-validation-googles-now-in-android-playbook","title":"Industry Validation: Google\u2019s \u201cNow in Android\u201d Playbook","text":"<p>The \u201cfakes over mocks\u201d philosophy isn\u2019t theoretical\u2014it\u2019s the explicit, documented strategy of Google\u2019s flagship Android reference app.</p>"},{"location":"introduction/why-fakt.html#the-official-directive","title":"The Official Directive","text":"<p>Google\u2019s \u201cNow in Android\u201d (NiA) testing strategy wiki states unambiguously:</p> <p>\u201cDon\u2019t use mocking frameworks. Instead, use fakes.\u201d<sup>14</sup></p> <p>This decision is deliberate. The documentation explains the goal is to create \u201cless brittle tests that may exercise more production code, instead of just verifying specific calls against mocks\u201c<sup>13</sup>.</p>"},{"location":"introduction/why-fakt.html#pattern-1-test-only-hooks","title":"Pattern 1: Test-Only Hooks","text":"<p>NiA uses \u201ctest-only hooks\u201d to control fake behavior<sup>14</sup>:</p> <pre><code>// Production interface\ninterface NewsRepository {\n    fun getNews(): Flow&lt;List&lt;Article&gt;&gt;\n}\n\n// Test repository with hooks\nclass TestNewsRepository : NewsRepository {\n    private val newsFlow = MutableStateFlow&lt;List&lt;Article&gt;&gt;(emptyList())\n\n    // Production method\n    override fun getNews(): Flow&lt;List&lt;Article&gt;&gt; = newsFlow\n\n    // Test-only hook (not in interface)\n    fun sendNews(articles: List&lt;Article&gt;) {\n        newsFlow.value = articles\n    }\n}\n\n// Test usage\n@Test\nfun `GIVEN breaking news WHEN loading THEN displays alert`() = runTest {\n    val fake = TestNewsRepository()\n    val viewModel = NewsViewModel(fake)\n\n    // Use test-only hook to control fake\n    fake.sendNews(listOf(Article(breaking = true)))\n\n    // Assert resulting state\n    assertTrue(viewModel.uiState.value.showAlert)\n}\n</code></pre> <p>This pattern transforms testing from passive \u201csetup-then-verify\u201d (mocks) to active \u201cact-and-assert\u201d (fakes).</p>"},{"location":"introduction/why-fakt.html#pattern-2-high-fidelity-testing","title":"Pattern 2: High-Fidelity Testing","text":"<p>NiA doesn\u2019t fake everything\u2014it uses real implementations when controllable<sup>13</sup>:</p> <ul> <li>DataStore: Uses real <code>DataStore</code> writing to temporary folders wiped after each test</li> <li>Benefit: Tests exercise serialization, error handling, and migration logic</li> </ul> <p>This reveals a mature testing hierarchy: 1. First choice: Real implementation in controlled environment 2. Second choice: Fake for uncontrollable dependencies (network) 3. Last resort (banned): Mocks from frameworks</p>"},{"location":"introduction/why-fakt.html#the-asynchronous-testing-synergy","title":"The Asynchronous Testing Synergy","text":"<p>Kotlin\u2019s modern async stack\u2014<code>runTest</code>, <code>TestDispatcher</code>, and Turbine\u2014is inherently state-based, creating natural synergy with fakes.</p>"},{"location":"introduction/why-fakt.html#official-jetbrains-tooling","title":"Official JetBrains Tooling","text":"<p><code>runTest</code> + <code>TestDispatcher</code><sup>15</sup>: - Official <code>kotlinx-coroutines-test</code> library - Provides <code>TestScope</code> with virtual time control - Best practice: Inject <code>CoroutineDispatcher</code> into ViewModels/Repositories</p> <pre><code>@Test\nfun `GIVEN delay WHEN loading THEN skips virtual time`() = runTest {\n    val fake = fakeRepository()\n    val viewModel = ViewModel(fake, testScheduler) // Inject TestDispatcher\n\n    viewModel.loadData() // Internally: delay(5000)\n\n    // Test completes instantly (virtual time)\n    assertEquals(LoadingState.Success, viewModel.state.value)\n}\n</code></pre>"},{"location":"introduction/why-fakt.html#cash-apps-turbine-de-facto-standard","title":"Cash App\u2019s Turbine (De Facto Standard)","text":"<p>Turbine<sup>16</sup> is the universally adopted library for testing <code>Flow</code>:</p> <pre><code>@Test\nfun `GIVEN repository updates WHEN observing THEN emits new state`() = runTest {\n    val fake = fakeRepository {\n        getUser { User(id = \"123\", name = \"Alice\") }\n    }\n\n    viewModel.userFlow.test {\n        fake.sendUser(User(id = \"123\", name = \"Bob\")) // Test-only hook\n        assertEquals(\"Bob\", awaitItem().name) // State-based assertion\n    }\n}\n</code></pre> <p>Key insight: Turbine\u2019s API (<code>awaitItem()</code>) is designed for state verification, not interaction verification. The most natural way to produce data for Turbine is a fake with <code>MutableStateFlow</code> backing.</p>"},{"location":"introduction/why-fakt.html#the-golden-path","title":"The Golden Path","text":"<p>The modern Kotlin testing stack is: - <code>runTest</code> (virtual time) - Turbine (Flow testing) - Fakes (state-based data sources)</p> <p>This entire ecosystem is state-based by design. Compile-time fake generation completes this stack by automating the \u201chandwritten fake\u201d pattern.</p>"},{"location":"introduction/why-fakt.html#the-solution-compile-time-fake-generation","title":"The Solution: Compile-Time Fake Generation","text":"<p>Fakt solves both the JVM performance crisis and the KMP dead end through deep compiler integration\u2014a FIR \u2192 IR two-phase architecture that succeeds where KSP-based solutions fundamentally fail.</p>"},{"location":"introduction/why-fakt.html#why-ksp-based-solutions-failed","title":"Why KSP-Based Solutions Failed","text":"<p>The KMP testing ecosystem attempted to solve the mocking crisis through KSP (Kotlin Symbol Processing)\u2014a code generation tool that operates at the symbol level. This approach has proven architecturally inadequate.</p> <p>The K2 Compiler Breakage (Verified):</p> <p>Kotlin 2.0\u2019s release broke KSP-based mocking libraries. The K2 compiler \u201cfails to handle common metadata tasks properly\u201d in <code>commonTest</code> source sets<sup>7</sup>, creating a real-world migration crisis:</p> <ul> <li>StreetComplete app (10,000+ tests) forced to migrate from Mockative to Mokkery</li> <li>Mockative maintainer provided no clear K2 migration path</li> <li>Mokkery itself was forced to abandon KSP and build a full compiler plugin just to survive<sup>7</sup></li> </ul> <p>Architectural Limitations:</p> Issue KSP (Symbol-Level) Compiler Plugin (IR-Level) Access Level After type resolution During compilation (FIR/IR) Type System Read-only symbol view Full type manipulation Generic Support Limited (no type substitution) Complete (IrTypeSubstitutor) K2 Stability BROKEN (forced migrations) Stable (official extension points) Cross-Module Fragile (metadata issues) Robust (IR graph traversal) <p>The Verdict: KSP is the wrong tool for production-quality fake generation. A compiler-level solution is the only viable path.</p>"},{"location":"introduction/why-fakt.html#the-mokkery-exception-compiler-plugins-as-the-survivor-architecture","title":"The Mokkery Exception: Compiler Plugins as the Survivor Architecture","text":"<p>While the KSP ecosystem collapsed, one library thrived: Mokkery<sup>17</sup>.</p> <p>Mokkery is a Kotlin/IR compiler plugin\u2014not a KSP processor. This architectural choice proved decisive during the K2 migration. While Mockative and MocKMP struggled with broken <code>commonTest</code> generation, Mokkery\u2019s developer was proactively testing K2 betas in February 2024 and shipped stable K2 support by May 2024<sup>18</sup>.</p> <p>The Real-World Impact:</p> <p>The K2 migration created a forced ecosystem migration. StreetComplete, a popular open-source Android app with 10,000+ tests, had to abandon Mockative for Mokkery when K2 broke their test suite<sup>19</sup>. The Mockative maintainer himself publicly suggested users investigate Mokkery as a viable alternative<sup>7</sup>.</p> <p>This ecosystem schism validated a critical insight: compiler plugins, not KSP, are the only stable architecture for KMP test tooling.</p> <p>Why Mokkery Succeeded:</p> <p>Mokkery operates inside the Kotlin compiler as an IR transformer. When you write <code>mock&lt;UserRepository&gt;()</code>, Mokkery\u2019s plugin replaces that call with a fully-generated implementation class at the IR level<sup>20</sup>. This eliminates KSP\u2019s fundamental problem: fragile source-set code generation.</p> <p>Mokkery\u2019s API is intentionally designed as a MockK analogue<sup>21</sup>, providing zero-friction migration for KMP developers:</p> <pre><code>// Mokkery: Familiar MockK-like DSL\nval repository = mock&lt;BookRepository&gt;()\nevery { repository.findAll() } returns flowOf(Book(\"...\"))\nverify(exhaustiveOrder) { repository.findById(\"1\") }\n</code></pre> <p>Mokkery is production-ready (v2.10.2), actively maintained, and the current incumbent for KMP mocking<sup>22</sup>. For teams committed to interaction-based testing, Mokkery is a credible, stable solution.</p> <p>The Compiler Plugin Validation:</p> <p>Mokkery\u2019s success proves the architectural validity of compiler plugins for KMP testing. Both Mokkery and Fakt share this fundamental design decision. This isn\u2019t coincidental\u2014it\u2019s the only path that survives K2\u2019s stricter compilation model.</p> <p>Where Mokkery and Fakt Diverge:</p> <p>The critical difference isn\u2019t architecture\u2014it\u2019s testing paradigm coverage.</p> <p>Mokkery is a mocking library designed exclusively for interaction-based testing (verifying that methods were called). Fakt is a fake generator that supports both paradigms: state-based testing (primary) with built-in interaction tracking through StateFlow call counting.</p> <p>This distinction reveals itself in Mokkery\u2019s documented limitations<sup>23</sup>. As a mocking library, Mokkery is architecturally unable to mock:</p> <ul> <li><code>object</code> singletons</li> <li><code>sealed class</code> and <code>sealed interface</code> hierarchies</li> <li>Top-level functions and extension functions</li> <li>Final classes from third-party dependencies</li> </ul> <p>These aren\u2019t bugs\u2014they\u2019re the glass ceiling of the mocking paradigm. Mocking requires \u201cfully overridable\u201d types (interfaces, abstract classes). Sealed types, objects, and final classes cannot be \u201cmocked\u201d at runtime.</p> <p>Fakt\u2019s Dual Paradigm Advantage:</p> <p>Fakt doesn\u2019t mock\u2014it generates real implementations with support for both testing approaches. Every generated fake includes:</p> <ul> <li>Behavior configuration (state-based testing)</li> <li>StateFlow call tracking (interaction-based testing)</li> <li>Thread-safety (no <code>var count = 0</code> footguns)</li> </ul> <p>As documented earlier in \u201cSupporting Both Testing Paradigms,\u201d the same Fakt fake can verify state and interactions:</p> <pre><code>val fake = fakeUserRepository {\n    save { user -&gt; user.copy(id = \"generated-id\") }\n}\n\n// State-based verification\nval result = fake.save(User(\"test\"))\nassertEquals(\"generated-id\", result.id) // What happened?\n\n// Interaction-based verification (same fake)\nassertEquals(1, fake.saveCallCount.value) // How many times?\n</code></pre> <p>This dual paradigm support means you\u2019re not forced to choose philosophies\u2014Fakt adapts to your testing needs.</p> <p>The Brittleness Trade-off:</p> <p>Consider this refactoring scenario that highlights the paradigm difference:</p> <pre><code>// Original implementation\nfun checkout() {\n    repository.saveOrder(order)\n}\n\n// Mokkery test (interaction-based ONLY)\nverify(exactly = 1) { repository.saveOrder(order) }\n\n// Refactored implementation (same outcome, different method signature)\nfun checkout() {\n    repository.saveOrderWithAudit(order, auditLog = true)\n}\n\n// Result: Mokkery test BREAKS (false negative)\n// The outcome is identical, but the process changed\n</code></pre> <p>The outcome is identical (order saved), but the process changed. The mock-based test fails even though no bug exists. This is the brittleness Martin Fowler warned about\u2014tests coupled to how code works, not what it achieves<sup>9</sup>.</p> <p>The same refactoring with Fakt:</p> <pre><code>// Fakt test (state-based verification)\nval fake = fakeRepository()\nviewModel.checkout()\nassertEquals(1, fake.orders.size) // Assert OUTCOME, not process\n// Test survives refactoring\n</code></pre> <p>This test survives because it verifies state (was the order saved?), not interactions (which method was called?). And when you do need interaction verification, Fakt provides it through StateFlow: <code>assertEquals(1, fake.saveOrderCallCount.value)</code>.</p> <p>Complementary Solutions:</p> <p>Mokkery and Fakt serve different philosophical commitments:</p> Choose Mokkery When: Choose Fakt When: Interaction-based testing is your standard State-based testing is your primary approach MockK muscle memory drives your team Need both paradigms in one tool Side-effect verification without observable state Building test fixtures with controllable behavior Committed to London School exclusively Following Google\u2019s NiA pattern (state-based) <p>For teams with MockK expertise, Mokkery is the natural KMP migration path. For teams adopting state-based testing or needing flexibility between both paradigms, Fakt completes the Kotlin async testing stack (<code>runTest</code> + Turbine + Fakes).</p> <p>The Architectural Depth Difference:</p> <p>Mokkery and Fakt differ even at the compiler level:</p> <ul> <li>Mokkery: IR-only plugin (single-phase, anonymous IR classes, invisible output)</li> <li>Fakt: FIR \u2192 IR plugin (two-phase, readable <code>.kt</code> files, full debuggability)</li> </ul> <p>Fakt\u2019s two-phase architecture provides richer semantic information (full type resolution at FIR) and debuggable output (step through generated fakes with breakpoints). Mokkery\u2019s IR-only approach is invisible (no physical files), which works well for mocking but limits debuggability.</p> <p>Conclusion:</p> <p>Mokkery validates the compiler plugin architecture as the survivor of the K2 schism. It\u2019s an excellent solution for teams committed to interaction-based testing. Fakt extends this foundation by supporting both testing paradigms\u2014state-based verification with optional interaction tracking\u2014while generating real implementations that handle sealed types, objects, and other idiomatic Kotlin patterns that mocking fundamentally cannot support.</p> <p>The choice isn\u2019t \u201cwhich is better\u201d\u2014it\u2019s about paradigm needs. Mokkery excels at interaction-based testing. Fakt provides dual paradigm support with architectural advantages for Kotlin\u2019s full type system.</p>"},{"location":"introduction/why-fakt.html#fakts-fir-ir-two-phase-architecture","title":"Fakt\u2019s FIR \u2192 IR Two-Phase Architecture","text":"<p>Fakt uses a Metro-inspired production compiler plugin architecture with deep integration into Kotlin\u2019s compilation pipeline:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1: FIR (Frontend IR)                         \u2502\n\u2502  \u2022 FaktFirExtensionRegistrar                         \u2502\n\u2502  \u2022 Detects @Fake annotations on interfaces          \u2502\n\u2502  \u2022 Validates structure, thread-safety requirements   \u2502\n\u2502  \u2022 Full access to type system during resolution      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 2: IR (Intermediate Representation)          \u2502\n\u2502  \u2022 UnifiedFaktIrGenerationExtension                  \u2502\n\u2502  \u2022 InterfaceAnalyzer: Dynamic interface discovery    \u2502\n\u2502  \u2022 IrCodeGenerator: Type-safe code generation        \u2502\n\u2502  \u2022 Generates readable .kt files (not IR nodes)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  OUTPUT: Generated Kotlin Source Code               \u2502\n\u2502  \u2022 FakeXxxImpl.kt (implementation class)             \u2502\n\u2502  \u2022 fakeXxx() factory (type-safe DSL)                 \u2502\n\u2502  \u2022 Thread-safe StateFlow call tracking               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Metro Alignment: Fakt follows the production-validated pattern from Metro, Zac Sweers\u2019 dependency injection compiler plugin used by Google, Netflix, and Cash App. Metro\u2019s two-phase FIR \u2192 IR architecture has proven stable across Kotlin 1.9, 2.0, and 2.1.</p> <p>Why Not IR-Native Generation?</p> <p>Fakt generates readable <code>.kt</code> source files, not IR nodes directly. For test fakes\u2014code developers constantly debug\u2014transparency outweighs marginal performance gains. Generated fakes are real Kotlin files you can step through with breakpoints, not decompiled bytecode.</p>"},{"location":"introduction/why-fakt.html#supporting-both-testing-paradigms","title":"Supporting Both Testing Paradigms","text":"<p>Fakt doesn\u2019t force you to choose between state-based or interaction-based testing. Every generated fake supports both philosophies simultaneously.</p> <p>State-Based Testing (Classic/Detroit School):</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun save(user: User): User\n}\n\n// Generated: Behavior configuration DSL\nval fake = fakeUserRepository {\n    save { user -&gt; user.copy(id = \"generated-id\") }\n}\n\n// Test: Verify STATE\n@Test\nfun `GIVEN user WHEN saving THEN returns persisted user`() = runTest {\n    val result = fake.save(User(\"test\"))\n    assertEquals(\"generated-id\", result.id) // State verification\n}\n</code></pre> <p>Interaction-Based Testing (London School):</p> <pre><code>// Same generated fake includes automatic call tracking\n@Test\nfun `GIVEN multiple saves WHEN called THEN tracks interaction count`() = runTest {\n    fake.save(User(\"user1\"))\n    fake.save(User(\"user2\"))\n\n    // Verify INTERACTIONS (thread-safe StateFlow)\n    assertEquals(2, fake.saveCallCount.value)\n}\n</code></pre> <p>The Technical Achievement:</p> <p>Every generated method/property includes: - Behavior configuration (state-based testing) - StateFlow call tracking (interaction-based testing) - Thread-safety (no <code>var count = 0</code> footguns) - Zero runtime overhead (compile-time generation)</p> <p>One tool. Both paradigms. Zero dogma.</p>"},{"location":"introduction/why-fakt.html#how-fakt-works","title":"How Fakt Works","text":"<pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n}\n\n// Generated at compile-time (zero runtime overhead)\nval fake = fakeUserRepository {\n    getUser { id -&gt; Result.success(User(id, \"Alice\")) }\n}\n\n// State-based: Configure behavior\nfake.getUser(\"123\") // Returns User(\"123\", \"Alice\")\n\n// Interaction-based: Verify calls\nassertEquals(1, fake.getUserCallCount.value) // Thread-safe StateFlow\n</code></pre>"},{"location":"introduction/why-fakt.html#technical-advantages","title":"Technical Advantages","text":"<p>Universal Platform Support: - JVM, Android, Native (iOS/Desktop), JavaScript, WebAssembly - No reflection required (works on Native/Wasm) - Zero runtime dependencies</p> <p>Zero Performance Overhead: - Eliminates 1,391x MockK penalty<sup>1</sup> - No bytecode instrumentation - Generated code as fast as handwritten fakes</p> <p>100% Debuggable: - Readable <code>.kt</code> files in <code>build/generated/fakt/</code> - Set breakpoints, inspect variables - Step through generated implementations line-by-line</p> <p>Compiler-Level Stability: - Uses official Kotlin compiler extension points - Survives K2 compiler updates (unlike KSP tools) - Aligned with Metro\u2019s production-tested patterns</p> <p>Built-In Thread Safety: - StateFlow call tracking (not <code>var count = 0</code>) - No concurrent test flakiness - Reactive (works with Turbine for Flow testing)</p> <p>Smart Defaults:</p> <p>Fakt generates sensible default behaviors for unconfigured methods:</p> Type Default Behavior <code>Unit</code> <code>{ }</code> <code>Boolean</code> <code>{ false }</code> <code>Int</code>, <code>Long</code>, etc. <code>{ 0 }</code> <code>String</code> <code>{ \"\" }</code> <code>List&lt;T&gt;</code> <code>{ emptyList() }</code> <code>Result&lt;T&gt;</code> <code>{ Result.failure(NotImplementedError)}</code> Generic <code>T -&gt; T</code> <code>{ it }</code> (identity function) Nullable <code>T?</code> <code>{ null }</code>"},{"location":"introduction/why-fakt.html#fakes-vs-mocks-quick-comparison","title":"Fakes vs. Mocks: Quick Comparison","text":"Feature MockK/Mockito Fakt KMP Support Limited (JVM only) Universal (all targets) Compile-time Safety \u274c \u2705 Runtime Overhead Heavy (reflection) Zero Type Safety Partial (<code>any()</code> matchers) Complete Learning Curve Steep (complex DSL) Gentle (typed functions) Call Tracking Manual (<code>verify { }</code>) Built-in (StateFlow) Thread Safety Not guaranteed StateFlow-based Debuggability Reflection (opaque) Generated <code>.kt</code> files"},{"location":"introduction/why-fakt.html#migration-example","title":"Migration Example","text":"<p>Before (MockK): <pre><code>@Test\nfun `test user service`() = runTest {\n    val mockService = mockk&lt;UserService&gt;()\n\n    every { mockService.getUser(any()) } returns User(\"123\", \"Mock User\")\n\n    val result = mockService.getUser(\"123\")\n\n    verify { mockService.getUser(\"123\") }\n    assertEquals(\"Mock User\", result.name)\n}\n</code></pre></p> <p>After (Fakt): <pre><code>@Test\nfun `GIVEN fake service WHEN getting user THEN returns configured user`() = runTest {\n    val fake = fakeUserService {\n        getUser { id -&gt; User(id, \"Test User\") }\n    }\n\n    val result = fake.getUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n    assertEquals(\"Test User\", result.name)\n}\n</code></pre></p> <p>Key improvements: 1. No magic strings - <code>any()</code> replaced with typed lambda 2. Explicit behavior - Clear what\u2019s returned for which input 3. Type-safe verification - Compiler catches <code>getUserCallCount</code> typos 4. Readable intent - GIVEN-WHEN-THEN structure</p>"},{"location":"introduction/why-fakt.html#when-not-to-use-fakes","title":"When NOT to Use Fakes","text":"<p>Fakt isn\u2019t a silver bullet. Some scenarios favor other tools:</p> <p>Third-Party APIs \u2192 Use WireMock<sup>24</sup> or Pact<sup>25</sup> - Hand-written fakes for external APIs are \u201cdangerous illusions of fidelity\u201d - WireMock tests full HTTP client stack - Pact validates contracts with provider teams</p> <p>Legacy Code Without Interfaces \u2192 Use Pragmatic Mocks - Mocking frameworks can mock concrete classes via reflection - Allows testing before major refactoring - \u201cFakes-only\u201d demands all-or-nothing interface refactoring</p> <p>Side Effects Without Observable State \u2192 Use Mocks - Fire-and-forget analytics, logging - Interaction timing/ordering matters - Fakes provide no value without state to assert</p>"},{"location":"introduction/why-fakt.html#what-fakt-supports","title":"What Fakt Supports","text":"<p>Class Types: - \u2705 Interfaces - \u2705 Abstract classes - \u2705 Open classes (overridable members only)</p> <p>Type System: - \u2705 Full generics (class-level, method-level, constraints, variance) - \u2705 Nullable types - \u2705 Complex stdlib types (<code>Result&lt;T&gt;</code>, <code>List&lt;T&gt;</code>, etc.)</p> <p>Kotlin Features: - \u2705 Suspend functions - \u2705 Properties (<code>val</code>, <code>var</code>) - \u2705 Methods with parameters - \u2705 Inheritance</p>"},{"location":"introduction/why-fakt.html#current-limitations","title":"Current Limitations","text":"<p>Fakt is honest about what it doesn\u2019t support (yet):</p> <ul> <li>\u274c Data classes as <code>@Fake</code> targets (work fine as parameter/return types)</li> <li>\u274c Sealed hierarchies as <code>@Fake</code> targets</li> <li>\u274c Default parameters in interface methods</li> </ul> <p>See Limitations for details and workarounds.</p>"},{"location":"introduction/why-fakt.html#the-path-forward","title":"The Path Forward","text":"<p>Fakt represents the convergence of: - Industry best practices (Google\u2019s NiA pattern) - Verified performance data (1,391x MockK penalty eliminated) - Architectural necessity (KMP requires compile-time solutions) - Dual paradigm support (state-based AND interaction-based testing) - Compiler-level stability (FIR \u2192 IR architecture survives K2 updates)</p> <p>For JVM-only teams, Fakt delivers 40% faster test suites<sup>1</sup> and more resilient tests. For KMP teams, Fakt is the only stable fake generator for <code>commonTest</code>, complementing Mokkery\u2019s mocking capabilities with dual paradigm support and full Kotlin type system coverage.</p>"},{"location":"introduction/why-fakt.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Install Fakt and create your first fake in 5 minutes</li> <li>Features - Complete feature reference</li> <li>Basic Usage - Common patterns and examples</li> <li>Testing Patterns - Best practices and strategies</li> <li>Migration from Mocks - Moving from MockK/Mockito to Fakt</li> </ul>"},{"location":"introduction/why-fakt.html#works-cited","title":"Works Cited","text":"<ol> <li> <p>Benchmarking Mockk \u2014 Avoid these patterns for fast unit tests. Kevin Block. https://medium.com/@_kevinb/benchmarking-mockk-avoid-these-patterns-for-fast-unit-tests-220fc225da55 \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Mocking Kotlin classes with Mockito \u2014 the fast way. Brais Gab\u00edn Moreira. https://medium.com/21buttons-tech/mocking-kotlin-classes-with-mockito-the-fast-way-631824edd5ba \u21a9\u21a9</p> </li> <li> <p>Reflection | Kotlin Documentation. https://kotlinlang.org/docs/reflection.html \u21a9</p> </li> <li> <p>Reflection? - Native - Kotlin Discussions. https://discuss.kotlinlang.org/t/reflection/4054 \u21a9</p> </li> <li> <p>Did someone try to use Mockk on KMM project. Kotlin Slack. https://slack-chats.kotlinlang.org/t/10131532/did-someone-try-to-use-mockk-on-kmm-project \u21a9</p> </li> <li> <p>Mock common tests in kotlin using multiplatform. Stack Overflow. https://stackoverflow.com/questions/65491916/mock-common-tests-in-kotlin-using-multiplatform \u21a9</p> </li> <li> <p>Mocking in Kotlin Multiplatform: KSP vs Compiler Plugins. Martin Hristev. https://medium.com/@mhristev/mocking-in-kotlin-multiplatform-ksp-vs-compiler-plugins-4424751b83d7 \u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>MocKMP: a Mocking processor for Kotlin/Multiplatform. Salomon BRYS. https://medium.com/kodein-koders/mockmp-a-mocking-processor-for-kotlin-multiplatform-51957c484fe5 \u21a9</p> </li> <li> <p>Mocks Aren\u2019t Stubs. Martin Fowler. https://martinfowler.com/articles/mocksArentStubs.html \u21a9\u21a9</p> </li> <li> <p>Unit Testing \u2014 Why must you mock me? Craig Walker. https://medium.com/@walkercp/unit-testing-why-must-you-mock-me-69293508dd13 \u21a9</p> </li> <li> <p>Testing on the Toilet: Effective Testing. Google Testing Blog. https://testing.googleblog.com/2014/05/testing-on-toilet-effective-testing.html \u21a9</p> </li> <li> <p>Trade-offs to consider when choosing to use Mocks vs Fakes. HackMD. https://hackmd.io/@pierodibello/Trade-offs-to-consider-when-choosing-to-use-Mocks-vs-Fakes \u21a9</p> </li> <li> <p>android/nowinandroid: A fully functional Android app built entirely with Kotlin and Jetpack Compose. GitHub. https://github.com/android/nowinandroid \u21a9\u21a9</p> </li> <li> <p>Testing strategy and how to test. Now in Android Wiki. https://github.com/android/nowinandroid/wiki/Testing-strategy-and-how-to-test \u21a9\u21a9</p> </li> <li> <p>Testing Kotlin coroutines on Android. Android Developers. https://developer.android.com/kotlin/coroutines/test \u21a9</p> </li> <li> <p>Flow testing with Turbine. Cash App Code Blog. https://code.cash.app/flow-testing-with-turbine \u21a9</p> </li> <li> <p>lupuuss/Mokkery: The mocking library for Kotlin Multiplatform. GitHub. https://github.com/lupuuss/Mokkery \u21a9</p> </li> <li> <p>Kotlin 2.0.0 support \u00b7 Issue #1 \u00b7 lupuuss/Mokkery. GitHub. https://github.com/lupuuss/Mokkery/issues/1 \u21a9</p> </li> <li> <p>Use multiplatform mocking library for tests \u00b7 Issue #5420 \u00b7 streetcomplete/StreetComplete. GitHub. https://github.com/streetcomplete/StreetComplete/issues/5420 \u21a9</p> </li> <li> <p>Kotlin 2.2.0 support \u00b7 Issue #83 \u00b7 lupuuss/Mokkery. GitHub. https://github.com/lupuuss/Mokkery/issues/83 \u21a9</p> </li> <li> <p>Mocking | Mokkery. https://mokkery.dev/docs/Guides/Mocking/ \u21a9</p> </li> <li> <p>A to Z of Testing in Kotlin Multiplatform. Kinto Technologies. https://blog.kinto-technologies.com/posts/2024-12-24-tests-in-kmp/ \u21a9</p> </li> <li> <p>Limitations | Mokkery. https://mokkery.dev/docs/Limitations/ \u21a9</p> </li> <li> <p>Why we should use wiremock instead of Mockito. Stack Overflow. https://stackoverflow.com/questions/50726017/why-we-should-use-wiremock-instead-of-mockito \u21a9</p> </li> <li> <p>Stop Breaking My API: A Practical Guide to Contract Testing with Pact. Medium. https://medium.com/@mohsenny/stop-breaking-my-api-a-practical-guide-to-contract-testing-with-pact-33858d113386 \u21a9</p> </li> <li> <p>Effective migration to Kotlin on Android. Aris Papadopoulos. https://medium.com/android-news/effective-migration-to-kotlin-on-android-cfb92bfaa49b \u21a9</p> </li> </ol>"},{"location":"multi-module/index.html","title":"Multi-Module Support","text":"<p>Fakt\u2019s multi-module support enables fake reuse across multiple Gradle modules through dedicated collector modules.</p> <p>Experimental API</p> <p>Multi-module support is marked <code>@ExperimentalFaktMultiModule</code>. The API is production-ready but may evolve based on real-world feedback. Explicit opt-in is required.</p>"},{"location":"multi-module/index.html#what-is-multi-module-support","title":"What is Multi-Module Support?","text":"<p>Multi-module support allows you to:</p> <ul> <li>Generate fakes once in a producer module with <code>@Fake</code> interfaces</li> <li>Collect fakes in a dedicated collector module</li> <li>Use fakes across multiple consumer modules in tests</li> </ul> <p>This eliminates fake duplication and enables clean dependency management in large projects.</p>"},{"location":"multi-module/index.html#architecture-producer-collector-consumer","title":"Architecture: Producer \u2192 Collector \u2192 Consumer","text":"<p>Fakt\u2019s multi-module pattern uses three distinct roles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PRODUCER MODULE (:core:analytics)                              \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Contains @Fake annotated interfaces                          \u2502\n\u2502  \u2022 Fakt generates fakes at compile-time                         \u2502\n\u2502  \u2022 Output: build/generated/fakt/commonTest/kotlin/              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  COLLECTOR MODULE (:core:analytics-fakes) \u2020                     \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Collects generated fakes from producer                       \u2502\n\u2502  \u2022 FakeCollectorTask copies fakes with platform detection       \u2502\n\u2502  \u2022 Output: build/generated/collected-fakes/{platform}/kotlin/   \u2502\n\u2502  \u2022 Published as standard Gradle dependency                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  CONSUMER MODULES (:app, :features:login, etc.)                 \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Depend on collector module in tests                          \u2502\n\u2502  \u2022 Use fakes via generated factory functions                    \u2502\n\u2502  \u2022 No direct dependency on producer's test code                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u2020 Naming is flexible - can be :analytics-fakes, :analytics-test,\n  :analytics-test-fixtures, or any name you choose\n</code></pre>"},{"location":"multi-module/index.html#when-to-use-multi-module","title":"When to Use Multi-Module?","text":""},{"location":"multi-module/index.html#use-multi-module-when","title":"\u2705 Use Multi-Module When","text":"<ul> <li>Multiple modules need the same fakes (e.g., <code>core/logger</code> used by 10+ feature modules)</li> <li>Publishing fakes as artifacts (Maven Central, internal repository)</li> <li>Strict module boundaries (DDD, Clean Architecture, modular monoliths)</li> <li>Large teams with module ownership (dedicated teams per module)</li> <li>Shared test infrastructure (common fakes for integration tests)</li> </ul>"},{"location":"multi-module/index.html#use-single-module-when","title":"\u274c Use Single-Module When","text":"<ul> <li>Single module or 2-3 closely related modules</li> <li>Fakes only used locally (not shared across modules)</li> <li>Small team or early prototyping (prefer simplicity)</li> <li>Rapid iteration (multi-module adds slight build overhead)</li> </ul>"},{"location":"multi-module/index.html#quick-example","title":"Quick Example","text":""},{"location":"multi-module/index.html#producer-module","title":"Producer Module","text":"<p>Define <code>@Fake</code> interfaces in your core module:</p> <pre><code>// :core:analytics/src/commonMain/kotlin/Analytics.kt\npackage com.example.core.analytics\n\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    suspend fun identify(userId: String)\n}\n</code></pre> <p>Build the module\u2014Fakt generates fakes in <code>build/generated/fakt/commonTest/kotlin/</code>.</p>"},{"location":"multi-module/index.html#collector-module","title":"Collector Module","text":"<p>Create a dedicated module to collect the generated fakes:</p> <pre><code>// :core:analytics-fakes/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.rsicarelli.fakt\")\n}\n\nkotlin {\n    // Configure your KMP targets (jvm, ios, etc.)\n\n    sourceSets.commonMain.dependencies {\n        // CRITICAL: api() exposes original types to consumers\n        api(projects.core.analytics)\n\n        // Add dependencies needed by generated fakes\n        implementation(libs.coroutines)\n    }\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Naming Flexibility</p> <p>The collector module can be named anything you prefer:</p> <ul> <li><code>:core:analytics-fakes</code> \u2705 (recommended convention)</li> <li><code>:core:analytics-test</code> \u2705</li> <li><code>:core:analytics-test-fixtures</code> \u2705</li> <li><code>:test:analytics</code> \u2705</li> <li><code>:testFixtures:analytics</code> \u2705</li> </ul> <p>Fakt doesn\u2019t impose any naming convention. Choose what fits your project best.</p>"},{"location":"multi-module/index.html#consumer-module","title":"Consumer Module","text":"<p>Use the collected fakes in your tests:</p> <pre><code>// :app/build.gradle.kts\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre> <pre><code>// :app/src/commonTest/kotlin/AppTest.kt\n@Test\nfun `GIVEN app WHEN tracking event THEN should log event`() {\n    val events = mutableListOf&lt;String&gt;()\n    val analytics = fakeAnalytics { track { event -&gt; events.add(event) } }\n\n    analytics.track(\"user_login\")\n\n    assertEquals(listOf(\"user_login\"), events)\n    assertEquals(1, analytics.trackCallCount.value)\n}\n</code></pre>"},{"location":"multi-module/index.html#how-it-works","title":"How It Works","text":"<p>Fakt\u2019s multi-module flow follows three phases:</p> <p>1. Producer generates fakes at compile-time in test source sets (<code>build/generated/fakt/commonTest/</code>)</p> <p>2. Collector copies fakes using <code>FakeCollectorTask</code>: - Discovers generated fakes from producer - Analyzes package structure to detect target platform (e.g., <code>com.example.jvm.*</code> \u2192 <code>jvmMain/</code>) - Copies fakes to collector\u2019s source sets (<code>build/generated/collected-fakes/commonMain/</code>) - Registers as source roots for compilation</p> <p>3. Consumer uses fakes as standard dependencies: <pre><code>dependencies {\n    commonTestImplementation(projects.core.analyticsFakes)\n}\n</code></pre></p> <p>The collector exposes both original interfaces (via <code>api()</code>) and compiled fakes.</p> <p>See Advanced Topics for platform detection algorithm and Advanced Topics for task details.</p>"},{"location":"multi-module/index.html#key-benefits","title":"Key Benefits","text":"<ul> <li>Fake Reuse: Generate fakes once in producer, use across multiple consumer modules</li> <li>Clean Dependencies: Standard Gradle dependencies (<code>implementation(projects.core.analyticsFakes)</code>)</li> <li>Publishable Artifacts: Collectors are normal modules that can be published to Maven Central or internal repos</li> <li>Platform Awareness: Automatic platform detection places fakes in correct KMP source sets (jvmMain, iosMain, commonMain)</li> <li>Type Safety: Compile-time errors if interfaces change, preventing broken tests</li> </ul>"},{"location":"multi-module/index.html#getting-started","title":"Getting Started","text":"<p>Ready to set up multi-module support? Follow the Getting Started Guide for a step-by-step tutorial.</p> <p>Learn More:</p> <ul> <li>Getting Started - 15-minute step-by-step tutorial</li> <li>Advanced Topics - Platform detection, performance, publishing, and API reference</li> <li>Samples - Production-quality kmp-multi-module example (11 modules)</li> <li>Troubleshooting - Common issues &amp; solutions</li> <li>Migration Guide - Single-module \u2192 Multi-module migration</li> </ul>"},{"location":"multi-module/advanced.html","title":"Advanced Topics","text":"<p>Deep technical details for power users and complex multi-module setups.</p>"},{"location":"multi-module/advanced.html#platform-detection","title":"Platform Detection","text":"<p>Fakt\u2019s <code>FakeCollectorTask</code> automatically detects target platforms by analyzing package structures.</p>"},{"location":"multi-module/advanced.html#algorithm","title":"Algorithm","text":"<pre><code>fun determinePlatformSourceSet(\n    fileContent: String,\n    availableSourceSets: Set&lt;String&gt;\n): String {\n    // 1. Extract package declaration (first 10 lines)\n    val packageDeclaration = fileContent\n        .lines()\n        .take(10)\n        .firstOrNull { it.trim().startsWith(\"package \") }\n        ?.removePrefix(\"package \")\n        ?.trim()\n        ?: return \"commonMain\"\n\n    // 2. Split into segments\n    val segments = packageDeclaration.split(\".\")\n\n    // 3. Find matching source sets\n    val matches = segments.flatMap { segment -&gt;\n        availableSourceSets\n            .filter { sourceSet -&gt;\n                sourceSet.startsWith(segment, ignoreCase = true) &amp;&amp;\n                sourceSet.endsWith(\"Main\")\n            }\n            .map { it to segment }\n    }.distinct()\n\n    // 4. Return shortest match (most general)\n    return matches.minByOrNull { (sourceSet, _) -&gt; sourceSet.length }?.first\n        ?: \"commonMain\"\n}\n</code></pre>"},{"location":"multi-module/advanced.html#examples","title":"Examples","text":"<pre><code>// JVM-Specific Package\npackage com.example.jvm.database\n\u2192 segments = [\"com\", \"example\", \"jvm\", \"database\"]\n\u2192 \"jvm\" matches \"jvmMain\"\n\u2192 Output: jvmMain/kotlin/\n\n// iOS with Multiple Variants\npackage com.example.ios.camera\n\u2192 \"ios\" matches: iosMain (7), iosArm64Main (13), iosX64Main (10)\n\u2192 Shortest: iosMain\n\u2192 Output: iosMain/kotlin/\n\n// No Match (Fallback)\npackage com.example.business.logic\n\u2192 No segment matches\n\u2192 Output: commonMain/kotlin/ (fallback)\n</code></pre>"},{"location":"multi-module/advanced.html#package-naming-conventions","title":"Package Naming Conventions","text":"Platform Package Segment Example JVM <code>jvm.*</code> <code>com.example.jvm.database</code> Android <code>android.*</code> <code>com.example.android.storage</code> iOS <code>ios.*</code> <code>com.example.ios.camera</code> JS <code>js.*</code> <code>com.example.js.browser</code> Native <code>native.*</code> <code>com.example.native.file</code> WASM <code>wasm.*</code> <code>com.example.wasm.api</code> Common <code>shared.*</code>, <code>common.*</code> <code>com.example.shared.logger</code>"},{"location":"multi-module/advanced.html#fakecollectortask-api","title":"FakeCollectorTask API","text":"<p>The core component responsible for collecting generated fakes from producer modules.</p>"},{"location":"multi-module/advanced.html#task-properties","title":"Task Properties","text":"<pre><code>abstract class FakeCollectorTask : DefaultTask() {\n    @Input abstract val sourceProjectPath: Property&lt;String&gt;\n    @Internal abstract val sourceGeneratedDir: DirectoryProperty\n    @OutputDirectory abstract val destinationDir: DirectoryProperty\n    @Input abstract val availableSourceSets: SetProperty&lt;String&gt;\n    @Input abstract val logLevel: Property&lt;LogLevel&gt;\n}\n</code></pre> <p>sourceProjectPath: Gradle path to producer module (e.g., <code>\":core:analytics\"</code>)</p> <p>sourceGeneratedDir: Root directory of generated fakes in producer (<code>core/analytics/build/generated/fakt/</code>)</p> <p>destinationDir: Root directory for collected fakes in collector (<code>core/analytics-fakes/build/generated/collected-fakes/</code>)</p> <p>availableSourceSets: All KMP source sets available in collector module (e.g., <code>[\"commonMain\", \"jvmMain\", \"iosMain\"]</code>)</p> <p>logLevel: Logging verbosity (<code>QUIET</code>, <code>INFO</code>, <code>DEBUG</code>, <code>TRACE</code>)</p>"},{"location":"multi-module/advanced.html#build-system-integration","title":"Build System Integration","text":""},{"location":"multi-module/advanced.html#task-dependencies","title":"Task Dependencies","text":"<p>FakeCollectorTask automatically wires dependencies:</p> <pre><code>Producer Compilation\n:core:analytics:compileKotlinMetadata\n:core:analytics:compileKotlinJvm\n:core:analytics:compileKotlinIos\n    \u2193 dependsOn\nCollector Collection\n:core:analytics-fakes:collectFakes\n    \u2193 dependsOn\nCollector Compilation\n:core:analytics-fakes:compileKotlinJvm\n:core:analytics-fakes:compileKotlinIos\n    \u2193 testImplementation dependency\nConsumer Compilation\n:app:compileTestKotlinJvm\n:app:compileTestKotlinIos\n</code></pre>"},{"location":"multi-module/advanced.html#incremental-compilation","title":"Incremental Compilation","text":"<p>Fakt supports Gradle incremental compilation:</p> <ul> <li>First build: Full fake generation + collection (~40ms for 100 interfaces)</li> <li>No changes: Skip generation and collection (cached)</li> <li>Producer changed: Regenerate fakes + recollect (~40ms)</li> <li>Collector config changed: Recollect only (~10ms)</li> <li>Consumer changed: No regeneration/recollection (uses compiled artifacts)</li> </ul>"},{"location":"multi-module/advanced.html#configuration-cache-compatibility","title":"Configuration Cache Compatibility","text":"<p>Fakt is fully compatible with Gradle configuration cache:</p> <pre><code>./gradlew build --configuration-cache\n</code></pre> <p>FakeCollectorTask uses: - <code>Property&lt;T&gt;</code> for all configuration - File collections instead of file paths - No direct <code>Project</code> references at execution time</p>"},{"location":"multi-module/advanced.html#performance-optimization","title":"Performance Optimization","text":""},{"location":"multi-module/advanced.html#build-time-impact","title":"Build Time Impact","text":"<p>Typical overhead per fake module:</p> Scenario Time per Module Total (10 modules) Clean build (first) ~40-50ms ~400-500ms Incremental (changed) ~10-15ms ~100-150ms Incremental (cached) ~1-2ms ~10-20ms"},{"location":"multi-module/advanced.html#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"multi-module/advanced.html#1-enable-build-cache","title":"1. Enable Build Cache","text":"<pre><code>// gradle.properties\norg.gradle.caching=true\norg.gradle.configuration-cache=true\n</code></pre> <pre><code>./gradlew build --build-cache\n</code></pre>"},{"location":"multi-module/advanced.html#2-parallel-compilation","title":"2. Parallel Compilation","text":"<pre><code>// gradle.properties\norg.gradle.parallel=true\norg.gradle.workers.max=8\n</code></pre>"},{"location":"multi-module/advanced.html#3-increase-heap-size","title":"3. Increase Heap Size","text":"<pre><code>// gradle.properties\norg.gradle.jvmargs=-Xmx4g -XX:MaxMetaspaceSize=1g\n</code></pre>"},{"location":"multi-module/advanced.html#4-use-loglevelquiet-in-ci","title":"4. Use LogLevel.QUIET in CI","text":"<pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.QUIET)\n}\n</code></pre>"},{"location":"multi-module/advanced.html#analyzing-build-performance","title":"Analyzing Build Performance","text":"<pre><code># Generate build scan\n./gradlew build --scan\n\n# Profile build\n./gradlew build --profile\n\n# Check task times\n./gradlew build --info | grep \"Execution time\"\n</code></pre>"},{"location":"multi-module/advanced.html#publishing-fake-modules","title":"Publishing Fake Modules","text":"<p>Collector modules are standard Gradle modules and can be published to repositories.</p>"},{"location":"multi-module/advanced.html#publishing-to-maven-local","title":"Publishing to Maven Local","text":"<pre><code>./gradlew :core:analytics-fakes:publishToMavenLocal\n</code></pre>"},{"location":"multi-module/advanced.html#publishing-to-maven-central","title":"Publishing to Maven Central","text":"<p>Add to collector\u2019s <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    `maven-publish`\n    signing\n}\n\npublishing {\n    publications {\n        create&lt;MavenPublication&gt;(\"maven\") {\n            from(components[\"kotlin\"])\n\n            groupId = \"com.example\"\n            artifactId = \"analytics-fakes\"\n            version = \"1.0.0\"\n\n            pom {\n                name.set(\"Analytics Fakes\")\n                description.set(\"Test fakes for Analytics interface\")\n                url.set(\"https://github.com/example/project\")\n\n                licenses {\n                    license {\n                        name.set(\"Apache License 2.0\")\n                        url.set(\"https://www.apache.org/licenses/LICENSE-2.0\")\n                    }\n                }\n\n                developers {\n                    developer {\n                        id.set(\"example\")\n                        name.set(\"Example Developer\")\n                    }\n                }\n\n                scm {\n                    connection.set(\"scm:git:git://github.com/example/project.git\")\n                    url.set(\"https://github.com/example/project\")\n                }\n            }\n        }\n    }\n\n    repositories {\n        maven {\n            name = \"sonatype\"\n            url = uri(\"https://oss.sonatype.org/service/local/staging/deploy/maven2/\")\n            credentials {\n                username = project.findProperty(\"ossrhUsername\") as String?\n                password = project.findProperty(\"ossrhPassword\") as String?\n            }\n        }\n    }\n}\n\nsigning {\n    sign(publishing.publications[\"maven\"])\n}\n</code></pre>"},{"location":"multi-module/advanced.html#using-published-fakes","title":"Using Published Fakes","text":"<pre><code>// Consumer module\ndependencies {\n    commonTestImplementation(\"com.example:analytics-fakes:1.0.0\")\n}\n</code></pre>"},{"location":"multi-module/advanced.html#ide-integration","title":"IDE Integration","text":""},{"location":"multi-module/advanced.html#intellij-idea-android-studio","title":"IntelliJ IDEA / Android Studio","text":"<p>Fakt-generated fakes are automatically indexed by IDEs.</p> <p>Setup: 1. Build project: <code>./gradlew build</code> 2. Sync Gradle: File \u2192 Reload All Gradle Projects 3. Verify: Type <code>fake</code> and check autocomplete suggestions</p> <p>Troubleshooting: - Fakes not appearing: File \u2192 Invalidate Caches \u2192 Invalidate and Restart - Wrong platform fakes: Check package naming conventions - Compilation errors: Verify collector targets match producer</p>"},{"location":"multi-module/advanced.html#debugging-generated-code","title":"Debugging Generated Code","text":"<p>Navigate to generated fakes:</p> <pre><code>core/analytics-fakes/build/generated/collected-fakes/\n\u251c\u2500\u2500 commonMain/kotlin/  # IDE can navigate here\n\u251c\u2500\u2500 jvmMain/kotlin/\n\u2514\u2500\u2500 iosMain/kotlin/\n</code></pre> <p>Add breakpoints in generated code for debugging.</p>"},{"location":"multi-module/advanced.html#multi-repository-setups","title":"Multi-Repository Setups","text":"<p>For projects spanning multiple Git repositories:</p>"},{"location":"multi-module/advanced.html#repository-a-shared-infrastructure","title":"Repository A (Shared Infrastructure)","text":"<pre><code>// repo-a/core/analytics/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.rsicarelli.fakt\")\n    `maven-publish`\n}\n\npublishing {\n    publications {\n        create&lt;MavenPublication&gt;(\"maven\") {\n            from(components[\"kotlin\"])\n            groupId = \"com.company.shared\"\n            artifactId = \"analytics\"\n            version = \"2.0.0\"\n        }\n    }\n}\n\n// repo-a/core/analytics-fakes/build.gradle.kts\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\npublishing {\n    publications {\n        create&lt;MavenPublication&gt;(\"maven\") {\n            from(components[\"kotlin\"])\n            groupId = \"com.company.shared\"\n            artifactId = \"analytics-fakes\"\n            version = \"2.0.0\"\n        }\n    }\n}\n</code></pre>"},{"location":"multi-module/advanced.html#repository-b-consumer","title":"Repository B (Consumer)","text":"<pre><code>// repo-b/app/build.gradle.kts\ndependencies {\n    implementation(\"com.company.shared:analytics:2.0.0\")\n    commonTestImplementation(\"com.company.shared:analytics-fakes:2.0.0\")\n}\n</code></pre>"},{"location":"multi-module/advanced.html#custom-collector-configurations","title":"Custom Collector Configurations","text":""},{"location":"multi-module/advanced.html#collecting-multiple-producers","title":"Collecting Multiple Producers","text":"<p>One collector can aggregate multiple producers:</p> <pre><code>// Not currently supported - create separate collectors instead\n// Future enhancement: fakt.collectFakesFrom(projects.core.analytics, projects.core.logger)\n\n// Current pattern: One collector per producer\n// :core:analytics-fakes \u2192 collects :core:analytics\n// :core:logger-fakes \u2192 collects :core:logger\n</code></pre>"},{"location":"multi-module/advanced.html#excluding-specific-fakes","title":"Excluding Specific Fakes","text":"<p>Generated fakes are all-or-nothing from a producer. To exclude specific fakes:</p> <p>Option 1: Don\u2019t add <code>@Fake</code> annotation Option 2: Create separate producer modules for different fake groups</p>"},{"location":"multi-module/advanced.html#advanced-dependency-management","title":"Advanced Dependency Management","text":""},{"location":"multi-module/advanced.html#transitive-dependencies","title":"Transitive Dependencies","text":"<p>Collector modules must declare ALL dependencies used by generated fakes:</p> <pre><code>// If generated fakes use:\n// - suspend functions \u2192 kotlinx-coroutines\n// - Flow \u2192 kotlinx-coroutines\n// - Result&lt;T&gt; \u2192 kotlin-stdlib (already included)\n// - Custom types from other modules \u2192 add those modules\n\nkotlin {\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)  // Original interfaces\n        implementation(libs.coroutines)  // Used by suspend fakes\n        implementation(projects.core.logger)  // Used by fakes\n    }\n}\n</code></pre>"},{"location":"multi-module/advanced.html#avoiding-circular-dependencies","title":"Avoiding Circular Dependencies","text":"<p>Problem: Feature A fakes need Feature B, Feature B fakes need Feature A</p> <p>Solution: Extract shared interfaces to core module</p> <pre><code>Before (circular):\nfeatures/payment \u2192 depends on features/user\nfeatures/user \u2192 depends on features/payment\n\nAfter (hierarchical):\ncore/payment-api @Fake interface PaymentProvider\ncore/user-api @Fake interface UserProvider\nfeatures/payment \u2192 depends on core/payment-api, core/user-api\nfeatures/user \u2192 depends on core/user-api, core/payment-api\n</code></pre>"},{"location":"multi-module/advanced.html#experimental-features","title":"Experimental Features","text":""},{"location":"multi-module/advanced.html#platform-specific-collector-targets","title":"Platform-Specific Collector Targets","text":"<p>Limit collector to specific platforms:</p> <pre><code>kotlin {\n    // Only JVM and iOS (skip JS, Native, etc.)\n    jvm()\n    iosArm64()\n\n    // Collector will only generate for these targets\n}\n</code></pre> <p>Use when producer supports many platforms but you only test on a subset.</p>"},{"location":"multi-module/advanced.html#api-reference","title":"API Reference","text":""},{"location":"multi-module/advanced.html#collectfakesfrom","title":"collectFakesFrom()","text":"<p>Extension method on <code>FaktPluginExtension</code> for configuring multi-module collection.</p> <p>Type-safe project accessor (recommended): <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre></p> <p>Traditional project reference: <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(project(\":core:analytics\"))\n}\n</code></pre></p> <p>Both approaches are equally valid. Type-safe accessors provide better IDE support but require <code>enableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")</code> in <code>settings.gradle.kts</code>.</p>"},{"location":"multi-module/advanced.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Step-by-step tutorial</li> <li>Troubleshooting - Debug common issues</li> <li>Migration Guide - Single-module \u2192 Multi-module</li> </ul>"},{"location":"multi-module/getting-started.html","title":"Getting Started with Multi-Module","text":"<p>Set up Fakt multi-module support in 15 minutes with this step-by-step tutorial.</p>"},{"location":"multi-module/getting-started.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>\u2705 Kotlin Multiplatform or JVM project with multiple Gradle modules</li> <li>\u2705 Fakt plugin installed (see Installation)</li> <li>\u2705 Basic understanding of Gradle module structure</li> <li>\u2705 Type-safe project accessors enabled in <code>settings.gradle.kts</code></li> </ul> <p>Type-Safe Project Accessors</p> <p>If you don\u2019t have type-safe accessors enabled, add to <code>settings.gradle.kts</code>: <pre><code>enableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n</code></pre> Then sync Gradle to generate <code>projects.*</code> accessors.</p>"},{"location":"multi-module/getting-started.html#tutorial-overview","title":"Tutorial Overview","text":"<p>We\u2019ll create a simple multi-module setup:</p> <pre><code>my-project/\n\u251c\u2500\u2500 core/analytics/           # Producer (defines @Fake interfaces)\n\u251c\u2500\u2500 core/analytics-fakes/     # Collector (collects generated fakes)\n\u2514\u2500\u2500 app/                      # Consumer (uses fakes in tests)\n</code></pre> <p>Time: ~15 minutes</p>"},{"location":"multi-module/getting-started.html#step-1-create-producer-module","title":"Step 1: Create Producer Module","text":"<p>The producer module contains <code>@Fake</code> annotated interfaces.</p> <pre><code>// core/analytics/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n\n    sourceSets.commonMain.dependencies {\n        implementation(\"com.rsicarelli.fakt:runtime:1.0.0-SNAPSHOT\")\n    }\n}\n</code></pre> <p>Define <code>@Fake</code> interface:</p> <pre><code>// core/analytics/src/commonMain/kotlin/Analytics.kt\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    suspend fun identify(userId: String)\n}\n</code></pre> <p>Build the module: <code>./gradlew :core:analytics:build</code></p> <p>Verify fakes generated in <code>build/generated/fakt/commonTest/kotlin/</code></p>"},{"location":"multi-module/getting-started.html#step-2-create-collector-module","title":"Step 2: Create Collector Module","text":"<p>The collector module collects generated fakes and makes them available to other modules. Name it anything (<code>:core:analytics-fakes</code>, <code>:analytics-test</code>, etc.).</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    jvm()  // MUST match producer's targets\n    iosArm64()\n\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)  // CRITICAL: Use api() to expose types\n        implementation(libs.coroutines)  // Add dependencies used by fakes\n    }\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Key points: Use <code>api()</code> for producer dependency, match all producer targets, declare transitive dependencies.</p> <p>Build and verify: <code>./gradlew :core:analytics-fakes:build</code></p> <p>Verify fakes collected in <code>build/generated/collected-fakes/commonMain/kotlin/</code></p>"},{"location":"multi-module/getting-started.html#step-3-register-modules-in-settingsgradlekts","title":"Step 3: Register Modules in settings.gradle.kts","text":"<p>Add both modules to your project:</p> <pre><code>// settings.gradle.kts\nenableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n\nrootProject.name = \"my-project\"\n\ninclude(\":core:analytics\")\ninclude(\":core:analytics-fakes\")\ninclude(\":app\")\n</code></pre> <p>Sync Gradle to generate type-safe accessors (<code>projects.core.analytics</code>, etc.).</p>"},{"location":"multi-module/getting-started.html#step-4-use-fakes-in-consumer-module","title":"Step 4: Use Fakes in Consumer Module","text":"<p>Now use the collected fakes in your app or feature modules.</p>"},{"location":"multi-module/getting-started.html#configure-appbuildgradlekts","title":"Configure app/build.gradle.kts","text":"<pre><code>// app/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                // Main code depends on original interfaces\n                implementation(projects.core.analytics)\n            }\n        }\n\n        commonTest {\n            dependencies {\n                implementation(kotlin(\"test\"))\n\n                // Tests depend on collector module\n                implementation(projects.core.analyticsFakes)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#write-a-test","title":"Write a Test","text":"<pre><code>// app/src/commonTest/kotlin/com/example/app/AppTest.kt\npackage com.example.app\n\nimport com.example.core.analytics.Analytics\nimport kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AppTest {\n    @Test\n    fun `GIVEN analytics fake WHEN tracking event THEN should capture call`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val analytics: Analytics = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n            identify { userId -&gt; println(\"User: $userId\") }\n            sessionId { \"session-123\" }\n        }\n\n        analytics.track(\"user_login\")\n        analytics.track(\"user_signup\")\n\n        assertEquals(listOf(\"user_login\", \"user_signup\"), events)\n        assertEquals(2, analytics.trackCallCount.value)\n    }\n\n    @Test\n    fun `GIVEN analytics fake WHEN getting session THEN returns configured value`() {\n        val analytics = fakeAnalytics {\n            sessionId { \"my-session-id\" }\n        }\n\n        val sessionId = analytics.sessionId\n\n        assertEquals(\"my-session-id\", sessionId)\n        assertEquals(1, analytics.sessionIdCallCount.value)\n    }\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#run-tests","title":"Run Tests","text":"<pre><code>./gradlew :app:test\n</code></pre> <p>Expected: All tests pass \u2705</p>"},{"location":"multi-module/getting-started.html#step-5-verify-the-setup","title":"Step 5: Verify the Setup","text":""},{"location":"multi-module/getting-started.html#build-entire-project","title":"Build Entire Project","text":"<pre><code>./gradlew build\n</code></pre>"},{"location":"multi-module/getting-started.html#check-generated-code-locations","title":"Check Generated Code Locations","text":"<p>Producer (<code>:core:analytics</code>): <pre><code>core/analytics/build/generated/fakt/\n\u251c\u2500\u2500 commonTest/kotlin/com/example/core/analytics/\n\u2502   \u251c\u2500\u2500 FakeAnalyticsImpl.kt\n\u2502   \u251c\u2500\u2500 fakeAnalytics.kt\n\u2502   \u2514\u2500\u2500 FakeAnalyticsConfig.kt\n</code></pre></p> <p>Collector (<code>:core:analytics-fakes</code>): <pre><code>core/analytics-fakes/build/generated/collected-fakes/\n\u251c\u2500\u2500 commonMain/kotlin/com/example/core/analytics/\n\u2502   \u251c\u2500\u2500 FakeAnalyticsImpl.kt\n\u2502   \u251c\u2500\u2500 fakeAnalytics.kt\n\u2502   \u2514\u2500\u2500 FakeAnalyticsConfig.kt\n\u251c\u2500\u2500 jvmMain/kotlin/  (if JVM-specific fakes exist)\n\u2514\u2500\u2500 iosMain/kotlin/  (if iOS-specific fakes exist)\n</code></pre></p> <p>Consumer (<code>:app</code>): - No generated code (uses compiled fakes from collector dependency)</p>"},{"location":"multi-module/getting-started.html#verify-ide-autocomplete","title":"Verify IDE Autocomplete","text":"<p>In your test file, type <code>fake</code> and verify IDE suggests: - <code>fakeAnalytics()</code></p> <p>If not appearing, try: 1. File \u2192 Reload All Gradle Projects 2. File \u2192 Invalidate Caches \u2192 Invalidate and Restart</p>"},{"location":"multi-module/getting-started.html#multi-producer-example","title":"Multi-Producer Example","text":"<p>For projects with multiple core modules:</p> <p>1. Create additional producers (logger, auth, etc.) with <code>@Fake</code> interfaces</p> <p>2. Create corresponding collectors: <pre><code>// core/logger-fakes/build.gradle.kts\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.logger)\n}\n</code></pre></p> <p>3. Add all collectors as test dependencies: <pre><code>// app/build.gradle.kts\ncommonTest.dependencies {\n    implementation(projects.core.analyticsFakes)\n    implementation(projects.core.loggerFakes)\n    implementation(projects.core.authFakes)\n}\n</code></pre></p> <p>4. Compose multiple fakes in tests: <pre><code>@Test\nfun `test using multiple fakes`() = runTest {\n    val analytics = fakeAnalytics { track { event -&gt; /* ... */ } }\n    val logger = fakeLogger { info { msg -&gt; /* ... */ } }\n    val auth = fakeAuthProvider { login { Result.success(User(\"123\")) } }\n\n    // Test your use case with composed fakes\n}\n</code></pre></p>"},{"location":"multi-module/getting-started.html#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"multi-module/getting-started.html#pattern-1-type-safe-project-accessors-recommended","title":"Pattern 1: Type-Safe Project Accessors (Recommended)","text":"<pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Benefits: - IDE autocomplete - Compile-time safety - Refactoring support</p>"},{"location":"multi-module/getting-started.html#pattern-2-string-based-paths","title":"Pattern 2: String-Based Paths","text":"<pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(project(\":core:analytics\"))\n}\n</code></pre> <p>Use When: - Type-safe accessors not available - Dynamic module names - Cross-project references</p>"},{"location":"multi-module/getting-started.html#next-steps","title":"Next Steps","text":"<p>You\u2019ve successfully set up multi-module support! \ud83c\udf89</p> <p>For troubleshooting, see Troubleshooting Guide. Explore advanced topics:</p> <ul> <li>Advanced Topics - Platform detection, performance tuning, publishing, and API reference</li> <li>Migration Guide - Migrate existing single-module projects</li> </ul>"},{"location":"multi-module/migration.html","title":"Migration Guide","text":"<p>Migrate from single-module to multi-module fake consumption.</p>"},{"location":"multi-module/migration.html#when-to-migrate","title":"When to Migrate","text":""},{"location":"multi-module/migration.html#decision-criteria","title":"Decision Criteria","text":"<p>\u2705 Migrate to Multi-Module When: - 3+ modules need the same fakes - Publishing fake artifacts - Strict module boundaries (DDD, Clean Architecture) - Large teams (dedicated module ownership)</p> <p>\u274c Stay Single-Module When: - 1-2 modules total - Fakes only used locally - Small team or prototype - Prefer simplicity over reuse</p>"},{"location":"multi-module/migration.html#costbenefit-analysis","title":"Cost/Benefit Analysis","text":"Aspect Single-Module Multi-Module Setup Time 0 minutes ~30-60 minutes Build Modules N modules N + N collector modules Build Time Baseline +5-10ms per collector Fake Reuse None Full cross-module reuse Publishability No Yes (Maven, etc.)"},{"location":"multi-module/migration.html#migration-strategies","title":"Migration Strategies","text":""},{"location":"multi-module/migration.html#strategy-1-big-bang-all-at-once","title":"Strategy 1: Big Bang (All at Once)","text":"<p>Timeline: 1-2 days</p> <p>Process: 1. Create all collector modules 2. Update all consumer dependencies 3. Test entire project 4. Deploy together</p> <p>Best for: Small projects (&lt; 10 modules), dedicated migration time</p>"},{"location":"multi-module/migration.html#strategy-2-gradual-module-by-module","title":"Strategy 2: Gradual (Module by Module)","text":"<p>Timeline: 1-4 weeks</p> <p>Process: 1. Week 1: Core infrastructure (logger, analytics, etc.) 2. Week 2: Foundation features (auth, storage) 3. Week 3: Business features 4. Week 4: Polish, optimize, document</p> <p>Best for: Large projects, continuous delivery, risk aversion</p>"},{"location":"multi-module/migration.html#strategy-3-hybrid-mixed","title":"Strategy 3: Hybrid (Mixed)","text":"<p>Keep some single-module, migrate others</p> <p>Process: - Migrate frequently-shared fakes (core/logger, core/analytics) - Keep feature-specific fakes single-module</p> <p>Best for: Mixed module ownership, gradual rollout</p>"},{"location":"multi-module/migration.html#step-by-step-migration","title":"Step-by-Step Migration","text":""},{"location":"multi-module/migration.html#phase-1-preparation-30-minutes","title":"Phase 1: Preparation (30 minutes)","text":""},{"location":"multi-module/migration.html#1-enable-type-safe-project-accessors-optional","title":"1. Enable Type-Safe Project Accessors (Optional)","text":"<pre><code>// settings.gradle.kts\nenableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n</code></pre> <p>Sync Gradle to generate <code>projects.*</code> accessors.</p>"},{"location":"multi-module/migration.html#2-identify-fake-candidates","title":"2. Identify Fake Candidates","text":"<pre><code># Find all @Fake interfaces\nfind . -name \"*.kt\" -exec grep -l \"@Fake\" {} \\;\n\n# Group by module\n# - High reuse: core/logger (10+ consumers)\n# - Medium reuse: core/auth (5+ consumers)\n# - Low reuse: features/profile (1-2 consumers)\n</code></pre> <p>Prioritize: High reuse modules first</p>"},{"location":"multi-module/migration.html#phase-2-create-collectors-15-minutes-per-module","title":"Phase 2: Create Collectors (15 minutes per module)","text":""},{"location":"multi-module/migration.html#1-create-collector-module-directory","title":"1. Create Collector Module Directory","text":"<pre><code># Example: core/analytics \u2192 core/analytics-fakes\nmkdir -p core/analytics-fakes/src\n</code></pre>"},{"location":"multi-module/migration.html#2-create-buildgradlekts","title":"2. Create build.gradle.kts","text":"<pre><code>// core/analytics-fakes/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    // MUST match producer's targets\n    jvm()\n    iosArm64()\n    // ... all other targets from producer\n\n    sourceSets.commonMain.dependencies {\n        // Use api() to expose types\n        api(projects.core.analytics)\n\n        // Add transitive dependencies\n        implementation(libs.coroutines)\n    }\n}\n\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"multi-module/migration.html#3-register-in-settingsgradlekts","title":"3. Register in settings.gradle.kts","text":"<pre><code>include(\":core:analytics-fakes\")\n</code></pre>"},{"location":"multi-module/migration.html#4-build-and-verify","title":"4. Build and Verify","text":"<pre><code>./gradlew :core:analytics-fakes:build\n\n# Verify fakes collected\nls core/analytics-fakes/build/generated/collected-fakes/\n</code></pre>"},{"location":"multi-module/migration.html#phase-3-update-consumers-5-minutes-per-module","title":"Phase 3: Update Consumers (5 minutes per module)","text":""},{"location":"multi-module/migration.html#1-update-dependencies","title":"1. Update Dependencies","text":"<pre><code>// Before (single-module)\nkotlin {\n    sourceSets.commonTest.dependencies {\n        // No dependency - fakes generated locally\n    }\n}\n\n// After (multi-module)\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre>"},{"location":"multi-module/migration.html#2-test-imports","title":"2. Test Imports","text":"<pre><code>// Before (single-module)\nimport com.example.core.analytics.fakeAnalytics  // Local generated\n\n// After (multi-module)\nimport com.example.core.analytics.fakeAnalytics  // From collector dependency\n// \u2191 Import path unchanged! Fakes use same package as original interface\n</code></pre>"},{"location":"multi-module/migration.html#3-verify-tests-pass","title":"3. Verify Tests Pass","text":"<pre><code>./gradlew :app:test\n</code></pre>"},{"location":"multi-module/migration.html#phase-4-cleanup-optional","title":"Phase 4: Cleanup (Optional)","text":""},{"location":"multi-module/migration.html#1-remove-unused-test-code","title":"1. Remove Unused Test Code","text":"<p>If producer module no longer needs its own fakes:</p> <pre><code>// core/analytics/build.gradle.kts\n// Can remove Fakt plugin if only used for generation\n// Keep if producer's own tests use fakes\n</code></pre>"},{"location":"multi-module/migration.html#2-update-documentation","title":"2. Update Documentation","text":"<p>Update README, wiki, or docs to reflect multi-module setup.</p>"},{"location":"multi-module/migration.html#migration-examples","title":"Migration Examples","text":""},{"location":"multi-module/migration.html#example-1-core-logger-high-reuse","title":"Example 1: Core Logger (High Reuse)","text":"<p>Before: <pre><code>core/logger/\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 commonMain/kotlin/Logger.kt (@Fake)\n    \u2514\u2500\u2500 commonTest/kotlin/  (fakes generated here, not shared)\n\nfeatures/login/\n\u2514\u2500\u2500 src/commonTest/kotlin/  (no access to logger fakes)\n\nfeatures/checkout/\n\u2514\u2500\u2500 src/commonTest/kotlin/  (no access to logger fakes)\n</code></pre></p> <p>After: <pre><code>core/logger/\n\u2514\u2500\u2500 src/commonMain/kotlin/Logger.kt (@Fake)\n\ncore/logger-fakes/\n\u2514\u2500\u2500 build/generated/collected-fakes/  (fakes collected here)\n\nfeatures/login/\n\u2514\u2500\u2500 build.gradle.kts: implementation(projects.core.loggerFakes)\n\nfeatures/checkout/\n\u2514\u2500\u2500 build.gradle.kts: implementation(projects.core.loggerFakes)\n</code></pre></p> <p>Benefits: 2+ feature modules now share logger fakes</p>"},{"location":"multi-module/migration.html#example-2-feature-module-low-reuse","title":"Example 2: Feature Module (Low Reuse)","text":"<p>Decision: Keep single-module (not worth migration overhead)</p> <pre><code>features/profile/\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 commonMain/kotlin/ProfileService.kt (@Fake)\n    \u2514\u2500\u2500 commonTest/kotlin/  (fakes used only here)\n\n# No collector module created\n# Fakes stay local\n</code></pre>"},{"location":"multi-module/migration.html#rollback-procedure","title":"Rollback Procedure","text":"<p>If migration causes issues:</p>"},{"location":"multi-module/migration.html#1-revert-consumer-dependencies","title":"1. Revert Consumer Dependencies","text":"<pre><code>// Remove collector dependency\nkotlin {\n    sourceSets.commonTest.dependencies {\n        // implementation(projects.core.analyticsFakes)  // \u2190 Comment out\n    }\n}\n</code></pre>"},{"location":"multi-module/migration.html#2-re-enable-local-fake-generation","title":"2. Re-enable Local Fake Generation","text":"<p>Producer module already generates fakes locally. Just use them:</p> <pre><code>// core/analytics/build.gradle.kts\n// Plugin already present - fakes still generated locally\n</code></pre>"},{"location":"multi-module/migration.html#3-rebuild","title":"3. Rebuild","text":"<pre><code>./gradlew clean build\n</code></pre>"},{"location":"multi-module/migration.html#4-remove-collector-modules-optional","title":"4. Remove Collector Modules (Optional)","text":"<pre><code>rm -rf core/analytics-fakes/\n</code></pre> <pre><code>// settings.gradle.kts\n// include(\":core:analytics-fakes\")  // \u2190 Comment out\n</code></pre>"},{"location":"multi-module/migration.html#gradual-migration-timeline","title":"Gradual Migration Timeline","text":""},{"location":"multi-module/migration.html#4-week-plan-large-project","title":"4-Week Plan (Large Project)","text":"<p>Week 1: Core Infrastructure - [ ] Create collectors for: logger, analytics, network, storage - [ ] Update 3-5 high-priority consumers - [ ] Test integration - [ ] Document patterns</p> <p>Week 2: Foundation Features - [ ] Create collectors for: auth, config, database - [ ] Update remaining core consumers - [ ] Test cross-module dependencies</p> <p>Week 3: Business Features - [ ] Create collectors for: login, checkout, profile - [ ] Update all feature module tests - [ ] Remove local fake duplicates</p> <p>Week 4: Polish &amp; Optimize - [ ] Tune build cache - [ ] Optimize task dependencies - [ ] Update CI/CD pipelines - [ ] Team training &amp; documentation</p>"},{"location":"multi-module/migration.html#common-migration-patterns","title":"Common Migration Patterns","text":""},{"location":"multi-module/migration.html#pattern-1-version-catalog-updates","title":"Pattern 1: Version Catalog Updates","text":"<pre><code># gradle/libs.versions.toml\n\n# Before\n[libraries]\ncore-analytics = { module = \"com.example:core-analytics\", version = \"1.0.0\" }\n\n# After (add fake modules)\n[libraries]\ncore-analytics = { module = \"com.example:core-analytics\", version = \"1.0.0\" }\ncore-analytics-fakes = { module = \"com.example:core-analytics-fakes\", version = \"1.0.0\" }\n</code></pre>"},{"location":"multi-module/migration.html#pattern-2-convention-plugin","title":"Pattern 2: Convention Plugin","text":"<p>Create plugin for collector boilerplate:</p> <pre><code>// buildSrc/src/main/kotlin/fakt-collector.gradle.kts\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.rsicarelli.fakt\")\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n}\n\n// Apply to collectors\n// core/analytics-fakes/build.gradle.kts\nplugins {\n    id(\"fakt-collector\")\n}\n\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"multi-module/migration.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Multi-module setup guide</li> <li>Troubleshooting - Common migration issues</li> <li>Advanced Topics - Performance optimization</li> </ul>"},{"location":"reference/api.html","title":"API Reference","text":"<p>Generated code API and patterns.</p>"},{"location":"reference/api.html#generated-classes","title":"Generated Classes","text":"<p>For each <code>@Fake</code> annotated interface, Fakt generates three components:</p>"},{"location":"reference/api.html#implementation-class","title":"Implementation Class","text":"<pre><code>class Fake{Interface}Impl : {Interface} {\n    // StateFlow call counters\n    val {method}CallCount: StateFlow&lt;Int&gt;\n\n    // Override interface members\n    override fun {method}({params}): {return} = {method}Behavior({params})\n\n    // Internal configuration methods\n    internal fun configure{Method}(behavior: ({params}) -&gt; {return})\n}\n</code></pre>"},{"location":"reference/api.html#factory-function","title":"Factory Function","text":"<pre><code>fun fake{Interface}(\n    configure: Fake{Interface}Config.() -&gt; Unit = {}\n): Fake{Interface}Impl\n</code></pre>"},{"location":"reference/api.html#configuration-dsl","title":"Configuration DSL","text":"<pre><code>class Fake{Interface}Config(private val fake: Fake{Interface}Impl) {\n    fun {method}(behavior: ({params}) -&gt; {return})\n}\n</code></pre>"},{"location":"reference/api.html#naming-conventions","title":"Naming Conventions","text":"Element Pattern Example Implementation class <code>Fake{Interface}Impl</code> <code>FakeAnalyticsImpl</code> Factory function <code>fake{Interface}</code> <code>fakeAnalytics</code> Configuration DSL <code>Fake{Interface}Config</code> <code>FakeAnalyticsConfig</code> Call counter <code>{method}CallCount</code> <code>trackCallCount</code> Configuration method <code>{method}</code> <code>track { }</code>"},{"location":"reference/api.html#package-structure","title":"Package Structure","text":"<p>Generated fakes are in the same package as the annotated interface:</p> <pre><code>com.example.services.Analytics (@Fake)\n\u2192 com.example.services.FakeAnalyticsImpl\n\u2192 com.example.services.fakeAnalytics()\n\u2192 com.example.services.FakeAnalyticsConfig\n</code></pre>"},{"location":"reference/api.html#generated-code-location","title":"Generated Code Location","text":"Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code>"},{"location":"reference/api.html#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Plugin options</li> <li>Compatibility - Kotlin versions</li> <li>Limitations - Known issues</li> </ul>"},{"location":"reference/compatibility.html","title":"Compatibility","text":"<p>Platform and version requirements.</p>"},{"location":"reference/compatibility.html#kotlin-version-support","title":"Kotlin Version Support","text":"Fakt Version Kotlin Version Support 1.0.0-SNAPSHOT 2.2.20 - 2.2.30 <p>Fakt follows forward compatibility on a best-effort basis (usually N+.2 minor versions).</p>"},{"location":"reference/compatibility.html#gradle-version","title":"Gradle Version","text":"<ul> <li>Minimum: Gradle 8.0</li> <li>Recommended: Gradle 8.10+</li> </ul>"},{"location":"reference/compatibility.html#jvm-version","title":"JVM Version","text":"<ul> <li>Minimum: JVM 11</li> <li>Recommended: JVM 21+</li> </ul>"},{"location":"reference/compatibility.html#platform-support","title":"Platform Support","text":"<p>Works on all Kotlin Multiplatform targets:</p> <ul> <li>\u2705 JVM, Android</li> <li>\u2705 iOS (arm64, x64, simulator)</li> <li>\u2705 macOS, Linux, Windows</li> <li>\u2705 JavaScript (IR), WebAssembly</li> <li>\u2705 watchOS, tvOS</li> </ul> <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p>"},{"location":"reference/compatibility.html#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Setup guide</li> <li>Limitations - Known issues</li> </ul>"},{"location":"reference/limitations.html","title":"Limitations","text":"<p>Known limitations and workarounds.</p>"},{"location":"reference/limitations.html#current-limitations","title":"Current Limitations","text":""},{"location":"reference/limitations.html#data-classes-as-fake-targets","title":"\u274c Data Classes as @Fake Targets","text":"<p>Data classes have compiler-generated implementations and can\u2019t be faked.</p> <p>Workaround: Use builders or <code>copy()</code> for test data.</p> <p>Works as parameter/return types:</p> <pre><code>data class User(val id: String, val name: String)\n\n@Fake  // \u2705 This works\ninterface UserRepository {\n    fun getUser(id: String): User  // \u2705 Data class as return type\n}\n</code></pre>"},{"location":"reference/limitations.html#sealed-classes-as-fake-targets","title":"\u274c Sealed Classes as @Fake Targets","text":"<p>Sealed hierarchies can\u2019t be faked directly.</p> <p>Workaround: Use exhaustive when-expressions or visitor patterns.</p>"},{"location":"reference/limitations.html#default-parameters-in-interface-methods","title":"\u274c Default Parameters in Interface Methods","text":"<p>Interfaces with default parameters are not yet supported.</p> <p>Workaround: Use overloaded methods or remove defaults.</p>"},{"location":"reference/limitations.html#reporting-issues","title":"Reporting Issues","text":"<p>Found a limitation not listed here? Report it on GitHub.</p>"},{"location":"reference/limitations.html#next-steps","title":"Next Steps","text":"<ul> <li>FAQ - Common questions</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"samples/index.html","title":"Sample Projects","text":"<p>Fakt includes working sample projects demonstrating different use cases.</p>"},{"location":"samples/index.html#kmp-single-module","title":"kmp-single-module","text":"<p>Location: <code>samples/kmp-single-module/</code></p> <p>Demonstrates: Basic KMP usage with single module</p> <p>Targets: JVM, iOS, Android, JS, Native</p> <p>Key Examples:</p> <ul> <li>Simple interfaces with suspend functions</li> <li>Property fakes (val/var)</li> <li>Generic interfaces</li> <li>Call tracking with StateFlow</li> </ul> <p>Best for: Learning Fakt basics and KMP setup</p>"},{"location":"samples/index.html#kmp-multi-module","title":"kmp-multi-module","text":"<p>Location: <code>samples/kmp-multi-module/</code></p> <p>Demonstrates: Advanced multi-module architecture with dedicated fake modules</p> <p>Structure:</p> <ul> <li>11 producer modules with <code>@Fake</code> interfaces</li> <li>11 dedicated <code>-fakes</code> collector modules</li> <li>1 consumer app module using all fakes</li> </ul> <p>Key Examples:</p> <ul> <li>Cross-module fake consumption (experimental)</li> <li>Gradle project references with version catalogs</li> <li>Large-scale KMP project patterns</li> <li>Fake module organization</li> </ul> <p>Best for: Understanding multi-module setups and scaling Fakt</p>"},{"location":"samples/index.html#running-samples","title":"Running Samples","text":"<p>Clone the repository and build:</p> <pre><code>git clone https://github.com/rsicarelli/fakt.git\ncd fakt/samples/kmp-single-module\n./gradlew build\n</code></pre>"},{"location":"samples/index.html#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Module Usage - Cross-module fakes</li> <li>Contributing - Add your own samples</li> </ul>"},{"location":"usage/basic-usage.html","title":"Basic Usage","text":"<p>Learn the fundamentals of using Fakt-generated fakes in your tests.</p>"},{"location":"usage/basic-usage.html#simple-interface","title":"Simple Interface","text":"<p>The most common use case\u2014a simple interface with methods:</p> <pre><code>// src/commonMain/kotlin/com/example/Analytics.kt\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    fun identify(userId: String)\n}\n</code></pre> <p>Using in tests:</p> <pre><code>// src/commonTest/kotlin/com/example/AnalyticsTest.kt\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AnalyticsTest {\n    @Test\n    fun `GIVEN fake analytics WHEN tracking events THEN captures calls`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val fake = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n            identify { userId -&gt; println(\"User: $userId\") }\n        }\n\n        fake.track(\"user_signup\")\n        fake.track(\"user_login\")\n        fake.identify(\"user-123\")\n\n        assertEquals(listOf(\"user_signup\", \"user_login\"), events)\n        assertEquals(2, fake.trackCallCount.value)\n        assertEquals(1, fake.identifyCallCount.value)\n    }\n}\n</code></pre>"},{"location":"usage/basic-usage.html#return-values","title":"Return Values","text":"<p>Configure return values for methods:</p> <pre><code>@Fake\ninterface UserRepository {\n    fun getUser(id: String): User?\n    fun getAllUsers(): List&lt;User&gt;\n    fun count(): Int\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN configured repository WHEN fetching users THEN returns configured values`() {\n    val testUser = User(\"123\", \"Alice\")\n\n    val fake = fakeUserRepository {\n        getUser { id -&gt;\n            if (id == \"123\") testUser else null\n        }\n        getAllUsers { listOf(testUser) }\n        count { 1 }\n    }\n\n    assertEquals(testUser, fake.getUser(\"123\"))\n    assertNull(fake.getUser(\"456\"))\n    assertEquals(1, fake.getAllUsers().size)\n    assertEquals(1, fake.count())\n}\n</code></pre>"},{"location":"usage/basic-usage.html#default-behaviors","title":"Default Behaviors","text":"<p>Fakt generates smart defaults. You only configure what you need:</p> <pre><code>@Fake\ninterface Settings {\n    fun getTheme(): String\n    fun getFontSize(): Int\n    fun isEnabled(): Boolean\n}\n</code></pre> <p>Using defaults:</p> <pre><code>@Test\nfun `GIVEN unconfigured fake WHEN calling methods THEN uses defaults`() {\n    val fake = fakeSettings()  // No configuration\n\n    assertEquals(\"\", fake.getTheme())      // String default: \"\"\n    assertEquals(0, fake.getFontSize())    // Int default: 0\n    assertEquals(false, fake.isEnabled())  // Boolean default: false\n}\n</code></pre> <p>Override defaults:</p> <pre><code>@Test\nfun `GIVEN configured fake WHEN calling methods THEN uses custom behavior`() {\n    val fake = fakeSettings {\n        getTheme { \"dark\" }\n        isEnabled { true }\n        // getFontSize not configured, uses default: 0\n    }\n\n    assertEquals(\"dark\", fake.getTheme())\n    assertEquals(true, fake.isEnabled())\n    assertEquals(0, fake.getFontSize())  // Default\n}\n</code></pre>"},{"location":"usage/basic-usage.html#call-tracking","title":"Call Tracking","text":"<p>Every method automatically tracks calls via StateFlow:</p> <pre><code>@Fake\ninterface Logger {\n    fun log(message: String)\n    fun error(message: String)\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN fake logger WHEN logging messages THEN tracks call counts`() {\n    val fake = fakeLogger {\n        log { message -&gt; println(message) }\n        error { message -&gt; System.err.println(message) }\n    }\n\n    fake.log(\"Info message\")\n    fake.log(\"Another info\")\n    fake.error(\"Error occurred\")\n\n    assertEquals(2, fake.logCallCount.value)\n    assertEquals(1, fake.errorCallCount.value)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#multiple-parameters","title":"Multiple Parameters","text":"<p>Methods with multiple parameters work as expected:</p> <pre><code>@Fake\ninterface Calculator {\n    fun add(a: Int, b: Int): Int\n    fun divide(numerator: Double, denominator: Double): Double\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN calculator fake WHEN calling methods THEN uses provided parameters`() {\n    val fake = fakeCalculator {\n        add { a, b -&gt; a + b }\n        divide { numerator, denominator -&gt;\n            if (denominator == 0.0) Double.NaN\n            else numerator / denominator\n        }\n    }\n\n    assertEquals(5, fake.add(2, 3))\n    assertEquals(2.5, fake.divide(5.0, 2.0))\n    assertTrue(fake.divide(10.0, 0.0).isNaN())\n}\n</code></pre>"},{"location":"usage/basic-usage.html#nullable-return-types","title":"Nullable Return Types","text":"<p>Handle nullable types naturally:</p> <pre><code>@Fake\ninterface UserService {\n    fun findUser(id: String): User?\n    fun findByEmail(email: String): User?\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN user service fake WHEN finding users THEN handles nulls correctly`() {\n    val testUser = User(\"123\", \"Alice\")\n\n    val fake = fakeUserService {\n        findUser { id -&gt;\n            if (id == \"123\") testUser else null\n        }\n        // findByEmail not configured, default: null\n    }\n\n    assertNotNull(fake.findUser(\"123\"))\n    assertNull(fake.findUser(\"456\"))\n    assertNull(fake.findByEmail(\"alice@example.com\"))  // Default: null\n}\n</code></pre>"},{"location":"usage/basic-usage.html#result-types","title":"Result Types","text":"<p>Fakt handles <code>Result&lt;T&gt;</code> with sensible defaults:</p> <pre><code>@Fake\ninterface ApiClient {\n    fun fetchData(id: String): Result&lt;Data&gt;\n    fun upload(data: Data): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN API client fake WHEN fetching data THEN returns configured Result`() {\n    val testData = Data(\"123\", \"content\")\n\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            if (id == \"123\") Result.success(testData)\n            else Result.failure(NotFoundException())\n        }\n        upload { data -&gt;\n            Result.success(Unit)\n        }\n    }\n\n    val result1 = fake.fetchData(\"123\")\n    assertTrue(result1.isSuccess)\n    assertEquals(testData, result1.getOrNull())\n\n    val result2 = fake.fetchData(\"456\")\n    assertTrue(result2.isFailure)\n\n    val result3 = fake.upload(testData)\n    assertTrue(result3.isSuccess)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#collection-return-types","title":"Collection Return Types","text":"<p>Smart defaults for collections:</p> <pre><code>@Fake\ninterface Repository {\n    fun getAll(): List&lt;Item&gt;\n    fun getTags(): Set&lt;String&gt;\n    fun getMetadata(): Map&lt;String, String&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN repository fake WHEN fetching collections THEN uses defaults or configured values`() {\n    val fake = fakeRepository {\n        getAll { listOf(Item(\"1\"), Item(\"2\")) }\n        // getTags not configured, default: emptySet()\n        // getMetadata not configured, default: emptyMap()\n    }\n\n    assertEquals(2, fake.getAll().size)\n    assertTrue(fake.getTags().isEmpty())      // Default\n    assertTrue(fake.getMetadata().isEmpty())  // Default\n}\n</code></pre>"},{"location":"usage/basic-usage.html#unit-return-type","title":"Unit Return Type","text":"<p>Methods returning <code>Unit</code> get no-op defaults:</p> <pre><code>@Fake\ninterface EventBus {\n    fun publish(event: Event)\n    fun subscribe(handler: EventHandler)\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN event bus fake WHEN publishing events THEN executes configured behavior`() {\n    val receivedEvents = mutableListOf&lt;Event&gt;()\n\n    val fake = fakeEventBus {\n        publish { event -&gt; receivedEvents.add(event) }\n        // subscribe not configured, default: { } (no-op)\n    }\n\n    fake.publish(Event(\"test-event\"))\n    fake.subscribe(mockHandler)  // No-op default\n\n    assertEquals(1, receivedEvents.size)\n    assertEquals(1, fake.publishCallCount.value)\n    assertEquals(1, fake.subscribeCallCount.value)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#inheritance","title":"Inheritance","text":"<p>Fakt handles inherited methods correctly:</p> <pre><code>interface BaseService {\n    fun start(): Boolean\n    fun stop(): Boolean\n}\n\n@Fake\ninterface UserService : BaseService {\n    fun getUser(id: String): User\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN service fake WHEN calling inherited methods THEN works correctly`() {\n    val fake = fakeUserService {\n        start { true }\n        stop { true }\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    assertTrue(fake.start())\n    assertEquals(\"Alice\", fake.getUser(\"123\").name)\n    assertTrue(fake.stop())\n\n    assertEquals(1, fake.startCallCount.value)\n    assertEquals(1, fake.getUserCallCount.value)\n    assertEquals(1, fake.stopCallCount.value)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#reconfiguring-fakes","title":"Reconfiguring Fakes","text":"<p>You can reconfigure behavior mid-test if needed:</p> <pre><code>@Test\nfun `GIVEN fake WHEN reconfiguring behavior THEN uses new behavior`() {\n    val fake = fakeUserRepository()\n\n    // Initial configuration\n    fake.configureGetUser { id -&gt; User(id, \"Alice\") }\n    assertEquals(\"Alice\", fake.getUser(\"123\").name)\n\n    // Reconfigure\n    fake.configureGetUser { id -&gt; User(id, \"Bob\") }\n    assertEquals(\"Bob\", fake.getUser(\"123\").name)\n}\n</code></pre> <p>Advanced Usage</p> <p>Reconfiguring via <code>configureXxx()</code> methods is an advanced pattern. Prefer creating new fakes for different test scenarios.</p>"},{"location":"usage/basic-usage.html#next-steps","title":"Next Steps","text":"<p>Learn More: - Suspend Functions - Async/coroutine support - Generics - Generic type handling - Properties - val/var faking - Call Tracking - Advanced StateFlow patterns</p> <p>Best Practices: - Testing Patterns - GIVEN-WHEN-THEN, isolated fakes, verification strategies</p>"},{"location":"usage/call-tracking.html","title":"Call Tracking","text":"<p>Every Fakt-generated fake includes automatic, thread-safe call tracking via Kotlin StateFlow.</p>"},{"location":"usage/call-tracking.html#basic-call-tracking","title":"Basic Call Tracking","text":"<pre><code>@Fake\ninterface Analytics {\n    fun track(event: String)\n}\n\nval fake = fakeAnalytics {\n    track { event -&gt; println(event) }\n}\n\nfake.track(\"event1\")\nfake.track(\"event2\")\n\nassertEquals(2, fake.trackCallCount.value)\n</code></pre>"},{"location":"usage/call-tracking.html#stateflow-integration","title":"StateFlow Integration","text":"<p>Call counters are <code>StateFlow&lt;Int&gt;</code>, enabling reactive testing:</p> <pre><code>import app.cash.turbine.test\n\n@Test\nfun `GIVEN fake WHEN calling methods THEN counter updates reactively`() = runTest {\n    val fake = fakeRepository()\n\n    fake.getUserCallCount.test {\n        assertEquals(0, awaitItem())\n\n        fake.getUser(\"123\")\n        assertEquals(1, awaitItem())\n\n        fake.getUser(\"456\")\n        assertEquals(2, awaitItem())\n    }\n}\n</code></pre>"},{"location":"usage/call-tracking.html#property-call-tracking","title":"Property Call Tracking","text":"<p>Properties track both getter and setter calls:</p> <pre><code>@Fake\ninterface Settings {\n    var theme: String\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n}\n\nval _ = fake.theme  // Getter\nassertEquals(1, fake.getThemeCallCount.value)\n\nfake.theme = \"light\"  // Setter\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"usage/call-tracking.html#thread-safety","title":"Thread Safety","text":"<p>All call counters are thread-safe via <code>MutableStateFlow.update</code>:</p> <pre><code>@Test\nfun `GIVEN fake WHEN calling from multiple threads THEN counts correctly`() = runTest {\n    val fake = fakeAnalytics()\n\n    withContext(Dispatchers.Default) {\n        repeat(1000) {\n            launch {\n                fake.track(\"event\")\n            }\n        }\n    }\n\n    assertEquals(1000, fake.trackCallCount.value)\n}\n</code></pre>"},{"location":"usage/call-tracking.html#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Module - Cross-module fakes</li> <li>Testing Patterns - Best practices</li> </ul>"},{"location":"usage/generics.html","title":"Generics","text":"<p>Fakt fully supports generic type parameters at both class and method levels.</p>"},{"location":"usage/generics.html#class-level-generics","title":"Class-Level Generics","text":"<pre><code>@Fake\ninterface Repository&lt;T&gt; {\n    fun save(item: T): Result&lt;Unit&gt;\n    fun getAll(): List&lt;T&gt;\n}\n\nval fake = fakeRepository&lt;User&gt; {\n    save { item -&gt; Result.success(Unit) }\n    getAll { emptyList() }\n}\n</code></pre>"},{"location":"usage/generics.html#method-level-generics","title":"Method-Level Generics","text":"<pre><code>@Fake\ninterface Transformer {\n    fun &lt;T, R&gt; transform(input: T, mapper: (T) -&gt; R): R\n}\n\nval fake = fakeTransformer {\n    transform { input, mapper -&gt; mapper(input) }\n}\n</code></pre>"},{"location":"usage/generics.html#generic-constraints","title":"Generic Constraints","text":"<pre><code>@Fake\ninterface ComparableRepository&lt;T : Comparable&lt;T&gt;&gt; {\n    fun findMax(items: List&lt;T&gt;): T?\n}\n\nval fake = fakeComparableRepository&lt;Int&gt; {\n    findMax { items -&gt; items.maxOrNull() }\n}\n</code></pre>"},{"location":"usage/generics.html#variance","title":"Variance","text":"<p>Fakt supports variance modifiers (<code>out</code>, <code>in</code>):</p> <pre><code>@Fake\ninterface Producer&lt;out T&gt; {\n    fun produce(): T\n}\n\n@Fake\ninterface Consumer&lt;in T&gt; {\n    fun consume(item: T)\n}\n</code></pre>"},{"location":"usage/generics.html#next-steps","title":"Next Steps","text":"<ul> <li>Properties - val/var faking</li> <li>Call Tracking - StateFlow patterns</li> </ul>"},{"location":"usage/properties.html","title":"Properties","text":"<p>Fakt generates fakes for both read-only (<code>val</code>) and mutable (<code>var</code>) properties with automatic call tracking.</p>"},{"location":"usage/properties.html#read-only-properties-val","title":"Read-Only Properties (val)","text":"<pre><code>@Fake\ninterface Config {\n    val apiUrl: String\n    val timeout: Int\n}\n\nval fake = fakeConfig {\n    apiUrl { \"https://api.example.com\" }\n    timeout { 30 }\n}\n\nassertEquals(\"https://api.example.com\", fake.apiUrl)\nassertEquals(1, fake.apiUrlCallCount.value)\n</code></pre>"},{"location":"usage/properties.html#mutable-properties-var","title":"Mutable Properties (var)","text":"<pre><code>@Fake\ninterface Settings {\n    var theme: String\n    var fontSize: Int\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n    fontSize { 14 }\n}\n\n// Getter tracking\nassertEquals(\"dark\", fake.theme)\nassertEquals(1, fake.getThemeCallCount.value)\n\n// Setter tracking\nfake.theme = \"light\"\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"usage/properties.html#next-steps","title":"Next Steps","text":"<ul> <li>Call Tracking - Advanced StateFlow patterns</li> <li>Multi-Module - Cross-module fakes</li> </ul>"},{"location":"usage/suspend-functions.html","title":"Suspend Functions","text":"<p>Fakt fully supports Kotlin coroutines and suspend functions without any special configuration.</p>"},{"location":"usage/suspend-functions.html#basic-suspend-functions","title":"Basic Suspend Functions","text":"<p>Suspend functions work naturally in generated fakes:</p> <pre><code>@Fake\ninterface ApiClient {\n    suspend fun fetchData(id: String): Result&lt;Data&gt;\n    suspend fun upload(data: Data): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage in tests:</p> <pre><code>import kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertTrue\n\nclass ApiClientTest {\n    @Test\n    fun `GIVEN API client fake WHEN fetching data THEN suspends correctly`() = runTest {\n        val testData = Data(\"123\", \"content\")\n\n        val fake = fakeApiClient {\n            fetchData { id -&gt;\n                delay(100)  // Suspends correctly\n                Result.success(testData)\n            }\n            upload { data -&gt;\n                delay(50)\n                Result.success(Unit)\n            }\n        }\n\n        val result = fake.fetchData(\"123\")\n\n        assertTrue(result.isSuccess)\n        assertEquals(testData, result.getOrNull())\n        assertEquals(1, fake.fetchDataCallCount.value)\n    }\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#suspend-non-suspend-mix","title":"Suspend + Non-Suspend Mix","text":"<p>Interfaces can mix suspend and regular functions:</p> <pre><code>@Fake\ninterface UserRepository {\n    fun getLocalUser(id: String): User?\n    suspend fun fetchRemoteUser(id: String): Result&lt;User&gt;\n    suspend fun syncUsers(): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN repository WHEN calling mixed functions THEN works correctly`() = runTest {\n    val fake = fakeUserRepository {\n        getLocalUser { id -&gt; User(id, \"Local\") }\n        fetchRemoteUser { id -&gt;\n            delay(100)\n            Result.success(User(id, \"Remote\"))\n        }\n        syncUsers {\n            delay(200)\n            Result.success(Unit)\n        }\n    }\n\n    // Regular function (no suspend)\n    val local = fake.getLocalUser(\"123\")\n    assertEquals(\"Local\", local?.name)\n\n    // Suspend functions\n    val remote = fake.fetchRemoteUser(\"456\")\n    val syncResult = fake.syncUsers()\n\n    assertTrue(remote.isSuccess)\n    assertTrue(syncResult.isSuccess)\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#suspend-properties","title":"Suspend Properties","text":"<p>Properties with suspend getters are supported:</p> <pre><code>@Fake\ninterface AsyncConfig {\n    suspend fun loadConfig(): Map&lt;String, String&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN async config WHEN loading THEN suspends correctly`() = runTest {\n    val fake = fakeAsyncConfig {\n        loadConfig {\n            delay(50)\n            mapOf(\"key\" to \"value\")\n        }\n    }\n\n    val config = fake.loadConfig()\n\n    assertEquals(\"value\", config[\"key\"])\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#exception-handling","title":"Exception Handling","text":"<p>Suspend functions can throw exceptions naturally:</p> <pre><code>@Test\nfun `GIVEN API client WHEN fetch fails THEN throws exception`() = runTest {\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            delay(100)\n            throw NetworkException(\"Connection failed\")\n        }\n    }\n\n    assertFailsWith&lt;NetworkException&gt; {\n        fake.fetchData(\"123\")\n    }\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#coroutine-context","title":"Coroutine Context","text":"<p>Fakt-generated fakes work with all coroutine contexts:</p> <pre><code>@Test\nfun `GIVEN repository WHEN using different dispatchers THEN works correctly`() = runTest {\n    val fake = fakeRepository {\n        fetchData { id -&gt;\n            withContext(Dispatchers.Default) {\n                // Computation\n                Data(id)\n            }\n        }\n    }\n\n    val data = fake.fetchData(\"123\")\n    assertEquals(\"123\", data.id)\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#best-practices","title":"Best Practices","text":""},{"location":"usage/suspend-functions.html#use-runtest-for-suspend-tests","title":"\u2705 Use runTest for Suspend Tests","text":"<p>Always wrap suspend function tests in <code>runTest</code>:</p> <pre><code>@Test\nfun `test suspend function`() = runTest {  // \u2705 Required\n    val fake = fakeApiClient()\n    fake.fetchData(\"123\")\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#use-delay-for-testing-timing","title":"\u2705 Use delay() for Testing Timing","text":"<p>Test timing-sensitive code with <code>delay()</code>:</p> <pre><code>@Test\nfun `GIVEN slow API WHEN fetching THEN handles timeout`() = runTest {\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            delay(5000)  // Simulate slow response\n            Result.success(Data(id))\n        }\n    }\n\n    withTimeout(1000) {\n        assertFailsWith&lt;TimeoutCancellationException&gt; {\n            fake.fetchData(\"123\")\n        }\n    }\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#next-steps","title":"Next Steps","text":"<ul> <li>Generics - Generic type handling</li> <li>Properties - val/var faking</li> <li>Call Tracking - StateFlow patterns</li> </ul>"}]}