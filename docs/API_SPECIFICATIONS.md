# KtFakes API Specifications

> **Implementation Status**: String-based MVP Complete âœ… | IR-Native Architecture 90% Complete ðŸš€  
> **Last Updated**: September 2025  
> **Current Capabilities**: Full type mapping system, dynamic interface analysis, end-to-end pipeline validation, type-safe behavior configuration

## ðŸŽ‰ **WORKING EXAMPLES (Sept 2025)**

### âœ… **Real Generated Code Examples**

**Input Interface:**
```kotlin
@Fake
interface TestService {
    val memes: String
    fun getValue(): String
    fun setValue(value: String)
}

@Fake(trackCalls = true)
interface AnalyticsService {
    fun track(event: String)
}
```

**Generated Output (Fully Functional):**
```kotlin
// TestServiceFakes.kt - Generated by KtFakes compiler plugin
class FakeTestServiceImpl : TestService {
    private var getValueBehavior: () -> String = { "" }
    private var setValueBehavior: () -> Unit = {  }
    private var memesBehavior: () -> String = { "" }

    override fun getValue(): String = getValueBehavior()
    override fun setValue(value: String): Unit { setValueBehavior() }
    override val memes: String get() = memesBehavior()

    // Configuration methods for behavior setup
    internal fun configureGetValue(behavior: () -> String) { getValueBehavior = behavior }
    internal fun configureSetValue(behavior: () -> Unit) { setValueBehavior = behavior }
    internal fun configureMemes(behavior: () -> String) { memesBehavior = behavior }
}

fun fakeTestService(configure: FakeTestServiceConfig.() -> Unit = {}): TestService {
    return FakeTestServiceImpl().apply {
        FakeTestServiceConfig(this).configure()
    }
}

class FakeTestServiceConfig(private val fake: FakeTestServiceImpl) {
    fun getValue(behavior: () -> String) { fake.configureGetValue(behavior) }
    fun setValue(behavior: () -> Unit) { fake.configureSetValue(behavior) }
    fun memes(behavior: () -> String) { fake.configureMemes(behavior) }
}
```

**Usage Examples:**
```kotlin
// Basic fake creation
val service = fakeTestService()

// Configured fake with custom behavior
val customService = fakeTestService {
    getValue { "Custom Value" }
    memes { "Doge" }
    setValue { /* custom unit behavior */ }
}

// Using in tests
@Test
fun testServiceBehavior() {
    val fake = fakeTestService {
        getValue { "test-value" }
    }
    
    assertEquals("test-value", fake.getValue())
    assertEquals("Doge", fake.memes)
}
```

## ðŸŽ¯ **IR-Native Architecture Status**

### âœ… **Implemented Components**
- **Interface Analysis**: Dynamic interface discovery and validation
- **Type System**: 38+ tested type mappings with custom type support  
- **Code Generation Core**: Abstract generation engine with extensible architecture
- **Integration Pipeline**: End-to-end fake generation demonstration
- **Testing Framework**: Comprehensive TDD approach with BDD naming

### ðŸ“Š **Demonstrated Capabilities**
```yaml
Type Mapping Coverage:
  - Builtin Types: kotlin.String, Int, Boolean, Unit âœ…
  - Collections: List, Set, Map with generic support âœ…  
  - Coroutines: Flow, Job, Deferred âœ…
  - Result Types: kotlin.Result with success/failure âœ…
  - Custom Types: User-defined mappings with constructor generation âœ…
  
Interface Analysis:
  - Method Analysis: Parameters, return types, suspend detection âœ…
  - Property Analysis: Getter/setter detection, type mapping âœ…
  - Generic Analysis: Type parameters, bounds, variance âœ…
  - Validation: Thread-safety checks, content validation âœ…
  
Generated Code Quality:
  - Factory Functions: Thread-safe fake creation âœ…
  - Configuration DSL: Type-safe behavior configuration âœ…
  - Implementation Classes: Complete interface implementations âœ…
  - Method Signatures: Accurate parameter and return type handling âœ…
```

### ðŸ”„ **Migration Strategy**
- **Current State**: String-based system remains functional for existing users
- **New Architecture**: IR-Native modules run in parallel with comprehensive testing
- **Next Phase**: IR API integration for final two modules (ktfake-analysis, ktfake-codegen-ir)

---

## Runtime Annotations

### @Fake Annotation

**Primary annotation for marking interfaces/classes for fake generation.**

```kotlin
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.BINARY)  
annotation class Fake(
    /**
     * Enables call tracking and verification methods.
     * When true, generates data classes for capturing method calls
     * and verification methods like `verifyTracked()`, `verifyTrackedWith()`.
     * 
     * Performance impact: ~5-10% overhead for call storage
     * Memory impact: Stores all method calls until cleared
     * 
     * @default false
     */
    val trackCalls: Boolean = false,
    
    /**
     * Generates builder pattern for data classes.
     * When true, creates a builder class with fluent configuration methods
     * and supports nested fake generation for complex properties.
     * 
     * Only applicable to data classes, ignored for interfaces.
     * 
     * @default false
     */
    val builder: Boolean = false,
    
    /**
     * Auto-inject fake implementations for specified dependencies.
     * Creates instances of specified fakes and provides configuration access.
     * Dependencies must also have @Fake annotations.
     * 
     * Cross-module dependencies require proper test dependencies in build.gradle.
     * 
     * @default [] (empty array)
     */
    val dependencies: Array<KClass<*>> = [],
    
    /**
     * Ensures thread-safe implementation (enabled by default).
     * When true, generates instance-based fakes instead of singleton objects.
     * When false, allows shared state (NOT RECOMMENDED - race conditions possible).
     * 
     * @default true (strongly recommended to keep enabled)
     */
    val concurrent: Boolean = true,
    
    /**
     * Scope configuration for fake lifetime management.
     * Controls how long fake instances remain valid.
     * 
     * Supported values:
     * - "test" - Instance per test method (default)
     * - "class" - Instance per test class
     * - "global" - Shared instance (use with caution)
     * 
     * @default "test"
     */
    val scope: String = "test"
)
```

### @FakeConfig Annotation

**Additional configuration for advanced fake behavior.**

```kotlin
@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)
@Retention(AnnotationRetention.BINARY)
annotation class FakeConfig(
    /**
     * Custom fake factory name instead of generated default.
     * By default, generates `fakeServiceName()` for interface `ServiceName`.
     * 
     * @default "" (use generated name)
     */
    val factoryName: String = "",
    
    /**
     * Custom default values for method parameters.
     * Provides default return values when no configuration is specified.
     * 
     * Format: ["methodName=defaultValue", "otherMethod=otherDefault"]
     * 
     * @default [] (use generated defaults)
     */  
    val defaults: Array<String> = [],
    
    /**
     * Exclude specific methods from fake generation.
     * Useful for excluding methods with complex signatures or behaviors.
     * 
     * @default [] (include all methods)
     */
    val exclude: Array<String> = [],
    
    /**
     * Generate additional utility methods for common test scenarios.
     * Includes methods like `reset()`, `clearState()`, `getCallCount()`.
     * 
     * @default true
     */
    val generateUtilities: Boolean = true
)
```

### @CallTracking Annotation

**Fine-grained call tracking configuration.**

```kotlin
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.BINARY)
annotation class CallTracking(
    /**
     * Enable call tracking for this specific method.
     * Overrides class-level trackCalls setting.
     * 
     * @default true when annotation is present
     */
    val enabled: Boolean = true,
    
    /**
     * Maximum number of calls to store before rolling over.
     * Prevents memory issues with high-frequency methods.
     * 
     * @default 1000
     */
    val maxCalls: Int = 1000,
    
    /**
     * Store call arguments for verification.
     * When false, only tracks call count and timing.
     * 
     * @default true  
     */
    val storeArguments: Boolean = true,
    
    /**
     * Include call timing information.
     * Stores timestamp and execution duration for each call.
     * 
     * @default false
     */
    val timing: Boolean = false
)
```

## Generated Factory Functions

### Basic Factory Pattern

For interface `UserService` with `@Fake`:

```kotlin
/**
 * Creates a new fake instance of UserService with thread-safe behavior configuration.
 * 
 * @param configure Lambda for configuring fake behavior using DSL
 * @return New UserService fake instance with configured behavior
 * 
 * Example:
 * ```kotlin
 * val userService = fakeUserService {
 *     getUser { id -> User(id, "Test User") }
 *     updateUser(throws = RuntimeException("Update failed"))
 * }
 * ```
 */
@Generated("ktfake")
fun fakeUserService(
    configure: FakeUserServiceConfig.() -> Unit = {}
): UserService
```

### Builder Factory Pattern

For data class `User` with `@Fake(builder = true)`:

```kotlin
/**
 * Creates a new User instance using builder pattern with configurable properties.
 * 
 * @param configure Lambda for configuring User properties using builder DSL
 * @return New User instance with configured properties
 * 
 * Example:
 * ```kotlin
 * val user = fakeUser {
 *     name("John Doe")
 *     email("john@example.com") 
 *     preferences {
 *         theme("dark")
 *         notifications(true)
 *     }
 * }
 * ```
 */
@Generated("ktfake")  
fun fakeUser(
    configure: FakeUserConfig.() -> Unit = {}
): User
```

### Cross-Module Factory Pattern

For interface `OrderService` with dependencies:

```kotlin
/**
 * Creates a new OrderService fake with automatically injected dependency fakes.
 * 
 * @param configure Lambda for configuring both OrderService and its dependencies
 * @return New OrderService fake with configured dependencies
 * 
 * Example:
 * ```kotlin
 * val orderService = fakeOrderService {
 *     createOrder { userId, items -> Order(userId, items) }
 *     
 *     userService {
 *         getUser { User(it, "Test User") }
 *     }
 *     
 *     analytics {
 *         track { event, props -> println("Tracked: $event") }
 *     }
 * }
 * ```
 */
@Generated("ktfake")
fun fakeOrderService(
    configure: FakeOrderServiceConfig.() -> Unit = {}  
): OrderService
```

## Configuration DSL Specifications

### Basic Configuration DSL

For each method in faked interface, generates three configuration overloads:

```kotlin
@Generated("ktfake")
class FakeUserServiceConfig internal constructor(
    private val impl: FakeUserServiceImpl
) {
    /**
     * Configure method behavior with lambda function.
     * Provides full control over method logic including parameters.
     * 
     * @param behavior Lambda function matching method signature
     */
    fun getUser(behavior: (String) -> User): Unit
    
    /**
     * Configure method to return fixed value.
     * Ignores method parameters and always returns the same value.
     * 
     * @param value Fixed return value
     */
    fun getUser(value: User): Unit
    
    /**
     * Configure method to throw exception.
     * Always throws specified exception when called.
     * 
     * @param throws Exception to throw
     */
    fun getUser(throws: Throwable): Unit
    
    // Suspend methods maintain suspend modifier
    /**
     * Configure suspend method behavior.
     * 
     * @param behavior Suspend lambda function
     */
    suspend fun updateUser(behavior: suspend (User) -> Result<Unit>): Unit
    
    /**
     * Configure suspend method to return value.
     * 
     * @param value Fixed return value  
     */
    suspend fun updateUser(value: Result<Unit>): Unit
    
    /**
     * Configure suspend method to throw exception.
     * 
     * @param throws Exception to throw
     */
    suspend fun updateUser(throws: Throwable): Unit
}
```

### Call Tracking DSL Extensions

When `@Fake(trackCalls = true)`:

```kotlin  
@Generated("ktfake")
class FakeAnalyticsServiceConfig internal constructor(
    private val impl: FakeAnalyticsServiceImpl
) : BaseFakeConfig {
    
    // Standard configuration methods
    fun track(behavior: (String, Map<String, Any>) -> Unit): Unit
    fun track(throws: Throwable): Unit
    
    // Call tracking verification methods
    /**
     * Verify method was called exact number of times.
     * 
     * @param event Event name to verify
     * @param times Expected number of calls (default: 1)
     * @return true if call count matches, false otherwise
     */
    fun verifyTracked(event: String, times: Int = 1): Boolean
    
    /**
     * Verify method was called with specific arguments.
     * 
     * @param event Expected event name
     * @param properties Expected properties map
     * @return true if matching call found, false otherwise
     */
    fun verifyTrackedWith(event: String, properties: Map<String, Any>): Boolean
    
    /**
     * Verify method was never called.
     * 
     * @param event Event name to check  
     * @return true if never called, false otherwise
     */
    fun verifyNeverTracked(event: String): Boolean
    
    /**
     * Get all recorded calls for inspection.
     * 
     * @return List of all TrackCall instances
     */
    fun getTrackCalls(): List<TrackCall>
    
    /**
     * Clear all recorded call history.
     * Useful for test isolation within same fake instance.
     */
    fun clearCalls(): Unit
    
    /**
     * Get total number of calls made.
     * 
     * @return Total call count across all methods
     */
    fun getCallCount(): Int
}
```

### Builder Pattern DSL

When `@Fake(builder = true)` on data class:

```kotlin
@Generated("ktfake")
class FakeUserConfig internal constructor(
    private val builder: FakeUserBuilder
) {
    /**
     * Configure user ID.
     * 
     * @param value User ID string
     */
    fun id(value: String): FakeUserConfig
    
    /**
     * Configure user name.
     * 
     * @param value User name string  
     */
    fun name(value: String): FakeUserConfig
    
    /**
     * Configure user email.
     * 
     * @param value Email address string
     */
    fun email(value: String): FakeUserConfig
    
    /**
     * Configure user preferences with existing instance.
     * 
     * @param value UserPreferences instance
     */
    fun preferences(value: UserPreferences): FakeUserConfig
    
    /**
     * Configure user preferences with nested builder.
     * Automatically creates fake UserPreferences using its own builder.
     * 
     * @param configure Configuration lambda for UserPreferences
     */
    fun preferences(configure: FakeUserPreferencesConfig.() -> Unit): FakeUserConfig
    
    // Chaining support - all methods return FakeUserConfig for fluent usage
    /**
     * Example of method chaining:
     * ```kotlin
     * fakeUser {
     *     name("John").email("john@example.com").id("123")
     * }
     * ```
     */
}
```

### Cross-Module Dependencies DSL

When `@Fake(dependencies = [...])`:

```kotlin
@Generated("ktfake")
class FakeOrderServiceConfig internal constructor(
    private val impl: FakeOrderServiceImpl  
) {
    // Main service configuration
    fun createOrder(behavior: (String, List<Item>) -> Order): Unit
    fun createOrder(value: Order): Unit
    fun createOrder(throws: Throwable): Unit
    
    // Dependency configuration access
    /**
     * Configure injected UserService dependency.
     * 
     * @param configure Configuration lambda for UserService fake
     */
    fun userService(configure: FakeUserServiceConfig.() -> Unit): Unit
    
    /**
     * Configure injected AnalyticsService dependency.
     * 
     * @param configure Configuration lambda for AnalyticsService fake  
     */
    fun analytics(configure: FakeAnalyticsServiceConfig.() -> Unit): Unit
    
    // Direct access to dependency instances (advanced usage)
    /**
     * Get direct access to UserService fake implementation.
     * Useful for advanced configuration or verification.
     * 
     * @return FakeUserServiceImpl instance
     */
    fun getUserService(): FakeUserServiceImpl
    
    /**
     * Get direct access to AnalyticsService fake implementation.
     * 
     * @return FakeAnalyticsServiceImpl instance
     */  
    fun getAnalyticsService(): FakeAnalyticsServiceImpl
}
```

## Call Tracking Data Structures

### Generated Call Data Classes

For each tracked method, generates corresponding data class:

```kotlin
@Generated("ktfake")
data class TrackCall(
    val event: String,
    val properties: Map<String, Any>,
    val timestamp: Long = System.currentTimeMillis()
)

@Generated("ktfake")  
data class SetUserIdCall(
    val userId: String,
    val timestamp: Long = System.currentTimeMillis()
)

@Generated("ktfake")
data class UpdateUserCall(
    val user: User,
    val timestamp: Long = System.currentTimeMillis()
)
```

### Call Storage and Retrieval

```kotlin
@Generated("ktfake")
internal class FakeAnalyticsServiceImpl : AnalyticsService {
    // Type-safe call storage
    internal val trackCalls = mutableListOf<TrackCall>()
    internal val setUserIdCalls = mutableListOf<SetUserIdCall>()
    
    // Call count tracking
    internal var totalCallCount: Int = 0
        private set
    
    // Call timing (when enabled)
    internal val callTimings = mutableMapOf<String, MutableList<Long>>()
    
    // Method implementation with call tracking
    override fun track(event: String, properties: Map<String, Any>) {
        val call = TrackCall(event, properties)
        trackCalls.add(call)
        totalCallCount++
        
        // Execute configured behavior
        trackBehavior(event, properties)
    }
}
```

## Advanced API Features

### Scope Management

```kotlin
/**
 * Scope management for fake instances.
 * Controls lifetime and sharing of fake instances.
 */
object FakeScope {
    /**
     * Create test-scoped fake (default behavior).
     * New instance for each test method.
     */
    fun <T> testScoped(factory: () -> T): T
    
    /**
     * Create class-scoped fake.
     * Shared instance across all test methods in same test class.
     */
    fun <T> classScoped(factory: () -> T): T
    
    /**
     * Create global fake.
     * Single shared instance across entire test suite.
     * WARNING: Can cause test interdependencies.
     */
    fun <T> globalScoped(factory: () -> T): T
}
```

### Reset and State Management

```kotlin
/**
 * State management utilities for fake instances.
 */
interface FakeStateManager {
    /**
     * Reset fake to initial state.
     * Clears all configured behaviors and returns to defaults.
     */
    fun reset(): Unit
    
    /**
     * Reset only call tracking data.
     * Preserves configured behaviors but clears call history.
     */
    fun resetCalls(): Unit
    
    /**
     * Reset only configured behaviors.  
     * Preserves call history but returns behaviors to defaults.
     */
    fun resetBehaviors(): Unit
    
    /**
     * Check if fake has been configured.
     * 
     * @return true if any behaviors configured, false if using defaults
     */
    fun isConfigured(): Boolean
}
```

### Testing Framework Integration

```kotlin
/**
 * JUnit integration utilities.
 */
object KtFakesJUnit {
    /**
     * JUnit 5 extension for automatic fake reset.
     * Add to test class to automatically reset fakes between tests.
     */
    class FakeResetExtension : BeforeEachCallback {
        override fun beforeEach(context: ExtensionContext) {
            FakeRegistry.resetAll()
        }
    }
}

/**
 * Kotest integration utilities.
 */
object KtFakesKotest {
    /**
     * Kotest listener for fake management.
     */
    object FakeResetListener : TestListener {
        override suspend fun beforeEach(testCase: TestCase) {
            FakeRegistry.resetAll()
        }
    }
}
```

## Error Handling and Diagnostics

### Configuration Validation

```kotlin
/**
 * Runtime validation for fake configurations.
 */
class FakeConfigurationException(
    message: String,
    val fakeType: KClass<*>,
    val methodName: String?,
    cause: Throwable? = null
) : RuntimeException(message, cause)

/**
 * Examples of validation errors:
 */
// Circular dependency detection
throw FakeConfigurationException(
    "Circular dependency detected: UserService -> OrderService -> UserService",
    OrderService::class,
    null
)

// Invalid method configuration
throw FakeConfigurationException(
    "Cannot configure method 'getUser' - method does not exist on UserService",
    UserService::class, 
    "getUser"
)
```

### Debug and Inspection APIs

```kotlin
/**
 * Debug utilities for fake inspection.
 */
object FakeDebugger {
    /**
     * Get configuration summary for fake instance.
     * 
     * @param fake Fake instance to inspect
     * @return Configuration details as string
     */
    fun getConfigurationSummary(fake: Any): String
    
    /**
     * Get call history summary for tracked fake.
     * 
     * @param fake Tracked fake instance
     * @return Call history as formatted string
     */
    fun getCallHistorySummary(fake: Any): String
    
    /**
     * Validate fake configuration at runtime.
     * Useful for debugging configuration issues.
     * 
     * @param fake Fake instance to validate
     * @throws FakeConfigurationException if configuration invalid
     */
    fun validateConfiguration(fake: Any): Unit
}
```

This API specification provides comprehensive documentation for all generated APIs, configuration options, and utility functions. The design emphasizes type safety, thread safety, and ease of use while providing powerful configuration capabilities for complex testing scenarios.