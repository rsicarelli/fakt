// Copyright (C) 2025 Rodrigo Sicarelli
// SPDX-License-Identifier: Apache-2.0
@file:OptIn(ExperimentalFaktMultiModule::class)

package com.rsicarelli.fakt.gradle

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.io.TempDir
import java.io.File
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * TDD tests for FakeCollectorTask platform-specific fake placement.
 *
 * Tests the collector's ability to detect platform-specific fakes and place them
 * in the correct source sets (jvmMain, commonMain, iosMain, etc.) instead of
 * blindly copying everything to commonMain.
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class FakeCollectorTaskTest {
    @Test
    fun `GIVEN JVM-specific fake WHEN detecting platform THEN should return jvmMain`() {
        // GIVEN a fake file with JVM-specific package
        val fakeContent =
            """
            // Generated by Fakt
            package api.jvm

            class FakeDatabaseServiceImpl : DatabaseService {
                override suspend fun connect(url: String): Boolean = false
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should return jvmMain
        assertEquals("jvmMain", sourceSet)
    }

    @Test
    fun `GIVEN common fake WHEN detecting platform THEN should return commonMain`() {
        // GIVEN a fake file with shared/common package
        val fakeContent =
            """
            // Generated by Fakt
            package api.shared

            class FakeNetworkServiceImpl : NetworkService {
                override fun fetch(url: String): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should return commonMain
        assertEquals("commonMain", sourceSet)
    }

    @Test
    fun `GIVEN iOS-specific fake WHEN detecting platform THEN should return iosMain`() {
        // GIVEN a fake file with iOS-specific package
        val fakeContent =
            """
            // Generated by Fakt
            package api.ios

            class FakeIOSServiceImpl : IOSService {
                override fun nativeCall(): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should return iosMain
        assertEquals("iosMain", sourceSet)
    }

    @Test
    fun `GIVEN JS-specific fake WHEN detecting platform THEN should return jsMain`() {
        // GIVEN a fake file with JS-specific package
        val fakeContent =
            """
            package api.js

            class FakeJSServiceImpl : JSService {
                override fun browserApi(): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should return jsMain
        assertEquals("jsMain", sourceSet)
    }

    @Test
    fun `GIVEN native-specific fake WHEN detecting platform THEN should return nativeMain`() {
        // GIVEN a fake file with native-specific package
        val fakeContent =
            """
            package api.native

            class FakeNativeServiceImpl : NativeService {
                override fun platformCall(): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should return nativeMain
        assertEquals("nativeMain", sourceSet)
    }

    @Test
    fun `GIVEN ambiguous package WHEN detecting platform THEN should default to commonMain`() {
        // GIVEN a fake file with no platform markers
        val fakeContent =
            """
            package api.services

            class FakeGenericServiceImpl : GenericService {
                override fun doSomething(): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should default to commonMain
        assertEquals("commonMain", sourceSet)
    }

    @Test
    fun `GIVEN file with common keyword in package WHEN detecting platform THEN should return commonMain`() {
        // GIVEN a fake file with explicit "common" in package
        val fakeContent =
            """
            package api.common

            class FakeCommonServiceImpl : CommonService {
                override fun shared(): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should return commonMain
        assertEquals("commonMain", sourceSet)
    }

    @Test
    fun `GIVEN multi-platform project WHEN collecting fakes THEN should separate by platform`(
        @TempDir tempDir: File,
    ) {
        // GIVEN a source directory with mixed platform fakes
        val sourceDir = tempDir.resolve("source/build/generated/fakt/commonTest/kotlin")
        sourceDir.mkdirs()

        // Create JVM fake
        val jvmFake = sourceDir.resolve("api/jvm/FakeDatabaseServiceImpl.kt")
        jvmFake.parentFile.mkdirs()
        jvmFake.writeText(
            """
            package api.jvm
            class FakeDatabaseServiceImpl : DatabaseService {}
            """.trimIndent(),
        )

        // Create common fake
        val commonFake = sourceDir.resolve("api/shared/FakeNetworkServiceImpl.kt")
        commonFake.parentFile.mkdirs()
        commonFake.writeText(
            """
            package api.shared
            class FakeNetworkServiceImpl : NetworkService {}
            """.trimIndent(),
        )

        // Create iOS fake
        val iosFake = sourceDir.resolve("api/ios/FakeIOSServiceImpl.kt")
        iosFake.parentFile.mkdirs()
        iosFake.writeText(
            """
            package api.ios
            class FakeIOSServiceImpl : IOSService {}
            """.trimIndent(),
        )

        // WHEN collecting fakes with platform detection
        val destDir = tempDir.resolve("dest/build/generated/collected-fakes")
        val result =
            FakeCollectorTask.collectWithPlatformDetection(
                sourceDir = sourceDir,
                destinationBaseDir = destDir,
            )

        // THEN should separate fakes by platform
        assertEquals(3, result.collectedCount)
        assertEquals(3, result.platformDistribution.size)

        // Verify JVM fake placement
        assertTrue(
            destDir.resolve("jvmMain/kotlin/api/jvm/FakeDatabaseServiceImpl.kt").exists(),
            "JVM fake should be in jvmMain",
        )

        // Verify common fake placement
        assertTrue(
            destDir.resolve("commonMain/kotlin/api/shared/FakeNetworkServiceImpl.kt").exists(),
            "Common fake should be in commonMain",
        )

        // Verify iOS fake placement
        assertTrue(
            destDir.resolve("iosMain/kotlin/api/ios/FakeIOSServiceImpl.kt").exists(),
            "iOS fake should be in iosMain",
        )
    }

    @Test
    fun `GIVEN package with multiple segments WHEN detecting platform THEN should detect platform marker`() {
        // GIVEN a fake with deep package hierarchy containing platform marker
        val fakeContent =
            """
            package com.example.api.jvm.services.database

            class FakeDatabaseServiceImpl : DatabaseService {}
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should detect jvmMain from package hierarchy
        assertEquals("jvmMain", sourceSet)
    }

    @Test
    fun `GIVEN nested JVM package WHEN detecting platform THEN should return jvmMain`() {
        // GIVEN deeply nested JVM package
        val fakeContent =
            """
            package api.internal.jvm.util

            class FakeJvmUtilImpl {}
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should detect jvmMain
        assertEquals("jvmMain", sourceSet)
    }

    @Test
    fun `GIVEN file without package declaration WHEN detecting platform THEN should default to commonMain`() {
        // GIVEN a fake file with no package declaration
        val fakeContent =
            """
            class FakeServiceImpl : Service {
                override fun doWork(): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should default to commonMain
        assertEquals("commonMain", sourceSet)
    }
}
