// Copyright (C) 2025 Rodrigo Sicarelli
// SPDX-License-Identifier: Apache-2.0
@file:OptIn(ExperimentalFaktMultiModule::class)

package com.rsicarelli.fakt.gradle

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.io.TempDir
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import java.io.File
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * TDD tests for FakeCollectorTask platform-specific fake placement.
 *
 * Tests the collector's ability to detect platform-specific fakes and place them
 * in the correct source sets (jvmMain, commonMain, iosMain, etc.) instead of
 * blindly copying everything to commonMain.
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class FakeCollectorTaskTest {
    @Test
    fun `GIVEN JVM-specific fake WHEN detecting platform THEN should return jvmMain`() {
        // GIVEN a fake file with JVM-specific package
        val fakeContent =
            """
            // Generated by Fakt
            package api.jvm

            class FakeDatabaseServiceImpl : DatabaseService {
                override suspend fun connect(url: String): Boolean = false
            }
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jvmMain", "jvmTest")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should return jvmMain
        assertEquals("jvmMain", sourceSet)
    }

    @Test
    fun `GIVEN common fake WHEN detecting platform THEN should return commonMain`() {
        // GIVEN a fake file with shared/common package
        val fakeContent =
            """
            // Generated by Fakt
            package api.shared

            class FakeNetworkServiceImpl : NetworkService {
                override fun fetch(url: String): String = ""
            }
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jvmMain")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should return commonMain
        assertEquals("commonMain", sourceSet)
    }

    @Test
    fun `GIVEN iOS-specific fake WHEN detecting platform THEN should return iosMain`() {
        // GIVEN a fake file with iOS-specific package
        val fakeContent =
            """
            // Generated by Fakt
            package api.ios

            class FakeIOSServiceImpl : IOSService {
                override fun nativeCall(): String = ""
            }
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "iosMain", "iosArm64Main")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should return iosMain
        assertEquals("iosMain", sourceSet)
    }

    @Test
    fun `GIVEN JS-specific fake WHEN detecting platform THEN should return jsMain`() {
        // GIVEN a fake file with JS-specific package
        val fakeContent =
            """
            package api.js

            class FakeJSServiceImpl : JSService {
                override fun browserApi(): String = ""
            }
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jsMain", "jvmMain")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should return jsMain
        assertEquals("jsMain", sourceSet)
    }

    @Test
    fun `GIVEN native-specific fake WHEN detecting platform THEN should return nativeMain`() {
        // GIVEN a fake file with native-specific package
        val fakeContent =
            """
            package api.native

            class FakeNativeServiceImpl : NativeService {
                override fun platformCall(): String = ""
            }
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "nativeMain", "iosMain")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should return nativeMain
        assertEquals("nativeMain", sourceSet)
    }

    @Test
    fun `GIVEN ambiguous package WHEN detecting platform THEN should default to commonMain`() {
        // GIVEN a fake file with no platform markers
        val fakeContent =
            """
            package api.services

            class FakeGenericServiceImpl : GenericService {
                override fun doSomething(): String = ""
            }
            """.trimIndent()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent)

        // THEN should default to commonMain
        assertEquals("commonMain", sourceSet)
    }

    @Test
    fun `GIVEN file with common keyword in package WHEN detecting platform THEN should return commonMain`() {
        // GIVEN a fake file with explicit "common" in package
        val fakeContent =
            """
            package api.common

            class FakeCommonServiceImpl : CommonService {
                override fun shared(): String = ""
            }
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jvmMain")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should return commonMain
        assertEquals("commonMain", sourceSet)
    }

    @Test
    fun `GIVEN multi-platform project WHEN collecting fakes THEN should separate by platform`(
        @TempDir tempDir: File,
    ) {
        // GIVEN a source directory with mixed platform fakes
        val sourceDir = tempDir.resolve("source/build/generated/fakt/commonTest/kotlin")
        sourceDir.mkdirs()

        // Create JVM fake
        val jvmFake = sourceDir.resolve("api/jvm/FakeDatabaseServiceImpl.kt")
        jvmFake.parentFile.mkdirs()
        jvmFake.writeText(
            """
            package api.jvm
            class FakeDatabaseServiceImpl : DatabaseService {}
            """.trimIndent(),
        )

        // Create common fake
        val commonFake = sourceDir.resolve("api/shared/FakeNetworkServiceImpl.kt")
        commonFake.parentFile.mkdirs()
        commonFake.writeText(
            """
            package api.shared
            class FakeNetworkServiceImpl : NetworkService {}
            """.trimIndent(),
        )

        // Create iOS fake
        val iosFake = sourceDir.resolve("api/ios/FakeIOSServiceImpl.kt")
        iosFake.parentFile.mkdirs()
        iosFake.writeText(
            """
            package api.ios
            class FakeIOSServiceImpl : IOSService {}
            """.trimIndent(),
        )

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jvmMain", "iosMain", "iosArm64Main")

        // WHEN collecting fakes with platform detection
        val destDir = tempDir.resolve("dest/build/generated/collected-fakes")
        val result =
            FakeCollectorTask.collectWithPlatformDetection(
                sourceDir = sourceDir,
                destinationBaseDir = destDir,
                availableSourceSets = availableSourceSets,
            )

        // THEN should separate fakes by platform
        assertEquals(3, result.collectedCount)
        assertEquals(3, result.platformDistribution.size)

        // Verify JVM fake placement
        assertTrue(
            destDir.resolve("jvmMain/kotlin/api/jvm/FakeDatabaseServiceImpl.kt").exists(),
            "JVM fake should be in jvmMain",
        )

        // Verify common fake placement
        assertTrue(
            destDir.resolve("commonMain/kotlin/api/shared/FakeNetworkServiceImpl.kt").exists(),
            "Common fake should be in commonMain",
        )

        // Verify iOS fake placement
        assertTrue(
            destDir.resolve("iosMain/kotlin/api/ios/FakeIOSServiceImpl.kt").exists(),
            "iOS fake should be in iosMain",
        )
    }

    @Test
    fun `GIVEN package with multiple segments WHEN detecting platform THEN should detect platform marker`() {
        // GIVEN a fake with deep package hierarchy containing platform marker
        val fakeContent =
            """
            package com.example.api.jvm.services.database

            class FakeDatabaseServiceImpl : DatabaseService {}
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jvmMain", "jvmTest")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should detect jvmMain from package hierarchy
        assertEquals("jvmMain", sourceSet)
    }

    @Test
    fun `GIVEN nested JVM package WHEN detecting platform THEN should return jvmMain`() {
        // GIVEN deeply nested JVM package
        val fakeContent =
            """
            package api.internal.jvm.util

            class FakeJvmUtilImpl {}
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jvmMain", "jvmTest")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should detect jvmMain
        assertEquals("jvmMain", sourceSet)
    }

    @Test
    fun `GIVEN file without package declaration WHEN detecting platform THEN should default to commonMain`() {
        // GIVEN a fake file with no package declaration
        val fakeContent =
            """
            class FakeServiceImpl : Service {
                override fun doWork(): String = ""
            }
            """.trimIndent()

        // GIVEN available source sets
        val availableSourceSets = setOf("commonMain", "jvmMain")

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should default to commonMain
        assertEquals("commonMain", sourceSet)
    }

    /**
     * Parametrized tests for ALL KMP targets supported by runtime.
     * This ensures determinePlatformSourceSet() works for ALL platforms, not just hardcoded ones.
     *
     * Test format: "packageSegment, expectedSourceSet"
     * - packageSegment: The platform marker in package (e.g., "tvos", "macos")
     * - expectedSourceSet: The expected source set name (e.g., "tvosMain", "macosMain")
     */
    @ParameterizedTest
    @CsvSource(
        // Tier 1 - Already working
        "jvm, jvmMain",
        "ios, iosMain",
        "js, jsMain",
        // Tier 2 - Currently FAILING (missing from hardcoded list)
        "macos, macosMain",
        "linux, linuxMain",
        // Tier 3 - Currently FAILING
        "tvos, tvosMain",
        "watchos, watchosMain",
        "mingw, mingwMain",
        // Web - wasmJs currently FAILING
        "wasmJs, wasmJsMain",
        // Hierarchical source sets
        "native, nativeMain",
        "apple, appleMain",
        "androidNative, androidNativeMain",
        "web, webMain",
        // Common patterns
        "common, commonMain",
        "shared, commonMain",
    )
    fun `GIVEN platform-specific package WHEN detecting with available source sets THEN returns correct source set`(
        packageSegment: String,
        expectedSourceSet: String,
    ) {
        // GIVEN a fake file with platform-specific package
        val fakeContent =
            """
            package api.$packageSegment.services

            class FakeServiceImpl : Service {
                override fun doWork(): String = ""
            }
            """.trimIndent()

        // GIVEN available source sets (simulating KMP project with all targets)
        val availableSourceSets =
            setOf(
                "commonMain",
                "commonTest",
                // Tier 1
                "jvmMain",
                "jvmTest",
                "iosMain",
                "iosTest",
                "iosArm64Main",
                "iosX64Main",
                "iosSimulatorArm64Main",
                "jsMain",
                "jsTest",
                // Tier 2
                "macosMain",
                "macosTest",
                "macosArm64Main",
                "macosX64Main",
                "linuxMain",
                "linuxTest",
                "linuxX64Main",
                "linuxArm64Main",
                // Tier 3
                "tvosMain",
                "tvosTest",
                "tvosArm64Main",
                "tvosX64Main",
                "tvosSimulatorArm64Main",
                "watchosMain",
                "watchosTest",
                "watchosArm64Main",
                "watchosArm32Main",
                "watchosX64Main",
                "watchosSimulatorArm64Main",
                "mingwMain",
                "mingwTest",
                "mingwX64Main",
                // Web
                "wasmJsMain",
                "wasmJsTest",
                "webMain",
                "webTest",
                // Hierarchical
                "nativeMain",
                "nativeTest",
                "appleMain",
                "appleTest",
                "androidNativeMain",
                "androidNativeTest",
            )

        // WHEN detecting the platform source set with available source sets
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should return the correct source set
        assertEquals(expectedSourceSet, sourceSet, "Package segment '$packageSegment' should map to '$expectedSourceSet'")
    }

    @Test
    fun `GIVEN multiple matching source sets WHEN detecting THEN should prioritize most specific`() {
        // GIVEN a package that could match multiple source sets
        val fakeContent =
            """
            package api.ios.services

            class FakeIOSServiceImpl : IOSService {}
            """.trimIndent()

        // GIVEN hierarchical source sets where "ios" could match iosMain, appleMain, nativeMain
        val availableSourceSets =
            setOf(
                "commonMain",
                "nativeMain",
                "appleMain",
                "iosMain",
                "iosArm64Main", // Even more specific
            )

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should prioritize most specific (iosMain over appleMain over nativeMain)
        assertEquals("iosMain", sourceSet, "Should prioritize 'iosMain' over parent source sets")
    }

    @Test
    fun `GIVEN architecture-specific package WHEN detecting THEN should match architecture-specific source set`() {
        // GIVEN a package with architecture-specific marker
        val fakeContent =
            """
            package api.iosArm64.services

            class FakeIOSArm64ServiceImpl : IOSArm64Service {}
            """.trimIndent()

        // GIVEN available source sets including architecture-specific
        val availableSourceSets =
            setOf(
                "commonMain",
                "iosMain",
                "iosArm64Main",
                "iosX64Main",
            )

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should match the architecture-specific source set
        assertEquals("iosArm64Main", sourceSet, "Should match architecture-specific 'iosArm64Main'")
    }

    @Test
    fun `GIVEN package with no match WHEN detecting with available source sets THEN should fallback to commonMain`() {
        // GIVEN a package with no platform marker
        val fakeContent =
            """
            package api.services.database

            class FakeServiceImpl : Service {}
            """.trimIndent()

        // GIVEN available source sets (no match for "api", "services", or "database")
        val availableSourceSets =
            setOf(
                "commonMain",
                "jvmMain",
                "iosMain",
            )

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should fallback to commonMain
        assertEquals("commonMain", sourceSet, "Should fallback to 'commonMain' when no match found")
    }

    @Test
    fun `GIVEN empty available source sets WHEN detecting THEN should fallback to commonMain`() {
        // GIVEN a JVM-specific package
        val fakeContent =
            """
            package api.jvm.services

            class FakeJVMServiceImpl : JVMService {}
            """.trimIndent()

        // GIVEN empty available source sets
        val availableSourceSets = emptySet<String>()

        // WHEN detecting the platform source set
        val sourceSet = FakeCollectorTask.determinePlatformSourceSet(fakeContent, availableSourceSets)

        // THEN should fallback to commonMain (no matching source sets available)
        assertEquals("commonMain", sourceSet, "Should fallback to commonMain when no available source sets provided")
    }
}
