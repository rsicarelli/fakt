# Code Generation Architecture: String-Based File Generation

**Status**: Active
**Decision Date**: January 2025
**Context**: Compiler plugin code generation strategy

## Executive Summary

Fakt uses **string-based file generation** to create test fakes, writing `.kt` source files using raw `buildString {}` APIs. This approach prioritizes developer transparency, debuggability, and stability over the performance gains of IR-native code generation or the convenience of code generation libraries like KotlinPoet.

---

## Context & Motivation

Fakt is a Kotlin compiler plugin that generates type-safe test fakes from `@Fake`-annotated interfaces. During development, we evaluated three approaches for code generation:

1. **IR-Native Generation** - Generate IR nodes directly (FIR declarations + IR transformations)
2. **KotlinPoet** - Use Square's KotlinPoet library for type-safe code building
3. **Raw String Building** - Generate Kotlin source using `buildString {}`

The choice impacts:
- **Developer Experience**: How developers debug and understand generated fakes
- **Build Performance**: Compilation overhead and incremental compilation
- **Maintenance Burden**: API stability, dependency management, complexity
- **IDE Integration**: Visibility and navigation of generated code

---

## Decision: String-Based File Generation with Raw `buildString`

### What We Do

Fakt generates complete Kotlin source files as strings and writes them to `build/generated/fakt/{sourceSet}/kotlin/`:

```kotlin
// ImplementationGenerator.kt:97-155
fun generateImplementation(analysis: InterfaceAnalysis, fakeClassName: String): String =
    buildString {
        // Generate class header with type parameters
        appendLine("class $fakeClassName$typeParameters : $interfaceWithGenerics {")

        // Generate behavior fields for methods
        append(generateBehaviorProperties(analysis))

        // Generate method overrides
        append(generateMethodOverrides(analysis))

        // Generate configuration DSL methods
        append(generateConfigMethods(analysis))

        append("}")
    }
```

Generated files are written to disk:

```kotlin
// CodeGenerator.kt:205-263
private fun writeGeneratedCode(...) {
    val outputFile = packageDir.resolve("$fakeClassName.kt")

    val fullCode = buildString {
        appendLine("// Generated by Fakt")
        appendLine("package ${escapePackageName(packageName)}")

        // Add required imports
        requiredImports.sorted().forEach { import ->
            appendLine("import $import")
        }

        // Add implementation, factory, and DSL
        append(code.implementation)
        append(code.factory)
        append(code.configDsl)
    }

    outputFile.writeText(fullCode)
}
```

### Why This Approach

**1. Developer Transparency**
- Generated `.kt` files are **visible in the IDE**
- Developers can read, browse, and understand fake implementations
- "Go to Declaration" (Cmd+Click) opens readable source code
- No "black box" magic - everything is verifiable

**2. Debuggability**
- Set breakpoints in generated code
- Step through fake method implementations
- Inspect generated behavior fields and configuration methods
- Understand test failures by reading the fake's source

**3. Stability**
- Kotlin syntax is stable across compiler versions
- No dependency on unstable compiler APIs (e.g., `@UnsafeApi` markers)
- Generated code survives Kotlin version upgrades
- Minimal risk of breaking changes

**4. Simplicity**
- Straightforward string building - easy to understand
- No complex IR node construction
- Lower cognitive overhead for contributors
- Easier to review and verify correctness

**5. IDE Integration**
- Generated files appear in project file tree
- Syntax highlighting and autocomplete work immediately
- Code navigation (find usages, refactoring) works seamlessly
- IntelliJ recognizes generated code as first-class sources

### Trade-offs Accepted

**Two-Pass Compilation**: Generated `.kt` files are parsed again by the Kotlin compiler (source â†’ IR â†’ bytecode), whereas IR-native generation goes directly to bytecode. For Fakt's use case (test fake generation), this overhead is **negligible** (~10-50ms per fake).

---

## Approach Comparison

| Criterion | IR-Native (Metro) | KotlinPoet | Raw Strings (Fakt) |
|-----------|-------------------|------------|---------------------|
| **Complexity** | ğŸ”´ High (FIR + IR APIs) | ğŸŸ¡ Medium (API learning curve) | ğŸŸ¢ Low (string building) |
| **Dependencies** | âœ… None | âŒ Extra dependency (~500KB) | âœ… None |
| **IDE Visibility** | âŒ No .kt files | âœ… Generates .kt files | âœ… Generates .kt files |
| **Debugging** | ğŸ”´ Complex (IR dumps) | ğŸŸ¢ Readable source | ğŸŸ¢ Readable source |
| **Performance** | ğŸŸ¢ Direct to bytecode | ğŸŸ¡ Two-pass compilation | ğŸŸ¡ Two-pass compilation |
| **API Stability** | ğŸ”´ @UnsafeApi markers | âœ… Stable library | âœ… Kotlin syntax stable |
| **Type Safety** | ğŸŸ¢ Full IR validation | ğŸŸ¢ API-level validation | ğŸŸ¡ String validation |
| **Use Case Fit** | DI frameworks | Complex codegen | Test fakes |

### Legend
- ğŸŸ¢ Advantage / Low risk
- ğŸŸ¡ Neutral / Acceptable trade-off
- ğŸ”´ Disadvantage / High risk

---

## Why NOT IR-Native Generation?

**Metro (our architectural inspiration) uses IR-native generation**, but Metro's requirements differ fundamentally from Fakt's:

| Aspect | Metro (DI Framework) | Fakt (Test Fakes) |
|--------|----------------------|-------------------|
| **Generated Code Visibility** | Internal infrastructure (developers don't need to read it) | Test implementations (developers frequently read/debug) |
| **Performance Priority** | High (DI resolution at runtime) | Low (test code generation at compile time) |
| **Complexity Justification** | Necessary for advanced DI features | Not needed for test fakes |

**Why IR-Native Doesn't Fit Fakt:**

1. **No .kt files** â†’ Developers see decompiled bytecode or "Cannot find declaration"
2. **Complex debugging** â†’ IR dumps are difficult to interpret
3. **API instability** â†’ Kotlin IR APIs marked `@UnsafeApi` can change between versions
4. **High complexity** â†’ Requires FIR + IR expertise, ~2-3x codebase size
5. **Marginal benefit** â†’ Performance gain (~10-50ms per fake) doesn't justify complexity

**When we'd reconsider IR-native:**
- Generating 1000+ fakes per build (performance becomes critical)
- Runtime code generation requirements
- Advanced type transformations beyond current capabilities

---

## Why NOT KotlinPoet?

KotlinPoet provides type-safe code generation APIs, but introduces trade-offs:

**Drawbacks:**
1. **Extra dependency** - Adds ~500KB to compiler plugin distribution (size matters for plugins)
2. **Reflection-based** - Runtime overhead for code building
3. **API learning curve** - Team must learn KotlinPoet's API
4. **Indirection** - KotlinPoet generates strings internally anyway

**Benefits don't justify costs:**
- Raw `buildString` is **simple enough** for Fakt's generated code structure
- Type resolution handled by our `TypeResolver` + `ImportResolver`
- Direct control over formatting and output
- Performance: KotlinPoet builds strings via reflection; we build directly

**When we'd reconsider KotlinPoet:**
- Generated code complexity increases significantly (e.g., complex DSL builders)
- Type-safe API becomes critical for correctness
- Team prefers declarative API over imperative strings

---

## Implementation Details

### Type Resolution

```kotlin
// TypeResolver converts IrType to Kotlin source strings
val returnTypeString = typeResolver.irTypeToKotlinString(function.returnType)
```

### Import Management

```kotlin
// ImportResolver collects cross-module imports
val requiredImports = importResolver.collectRequiredImports(analysis, packageName)
```

### Code Structure

Generated fakes consist of three components:

1. **Implementation Class** (`ImplementationGenerator.kt`)
   - Behavior fields for each method/property
   - Call tracking with `MutableStateFlow`
   - Method/property overrides

2. **Factory Function** (`FactoryGenerator.kt`)
   - Type-safe `fakeXxx {}` factory
   - DSL configuration support

3. **Configuration DSL** (`ConfigurationDslGenerator.kt`)
   - Builder-style configuration API
   - Method behavior customization

**Code References:**
- `compiler/src/main/kotlin/com/rsicarelli/fakt/compiler/ir/generation/ImplementationGenerator.kt`
- `compiler/src/main/kotlin/com/rsicarelli/fakt/compiler/ir/generation/FactoryGenerator.kt`
- `compiler/src/main/kotlin/com/rsicarelli/fakt/compiler/ir/generation/ConfigurationDslGenerator.kt`
- `compiler/src/main/kotlin/com/rsicarelli/fakt/compiler/ir/generation/CodeGenerator.kt`

---

## Future Considerations

### Performance Monitoring

Track compilation performance metrics to detect if string-based generation becomes a bottleneck:
- Time per fake generation
- Total compilation overhead for large projects
- Incremental compilation efficiency

### Reevaluation Triggers

Reconsider this decision if:
1. **Scale increases** - Projects generate 1000+ fakes (performance critical)
2. **Complexity grows** - Generated code patterns become difficult to maintain with strings
3. **Runtime generation** - Need to generate fakes dynamically (not compile-time)
4. **Advanced transformations** - Generic type manipulation beyond current capabilities

### Migration Path

If switching to IR-native becomes necessary:
1. Implement in parallel (new `ir/codegen` module)
2. Validate output parity with current generators
3. Performance benchmark comparison
4. Gradual migration with feature flags

---

## Related Documentation

- **Metro Alignment**: `.claude/docs/development/metro-alignment.md` - How we follow Metro's patterns
- **Testing Guidelines**: `.claude/docs/validation/testing-guidelines.md` - Validating generated code
- **Code Generation Strategies**: `.claude/docs/architecture/code-generation-strategies.md` - Overall strategy
- **FIR/IR Separation**: `.claude/docs/architecture/fir-ir-separation-decision.md` - Two-phase compilation

---

## Summary

**String-based file generation with raw `buildString` is the right choice for Fakt** because:

âœ… **Transparency** - Developers can read and understand generated fakes
âœ… **Debuggability** - Set breakpoints, inspect code, verify correctness
âœ… **Stability** - Kotlin syntax is stable across versions
âœ… **Simplicity** - Low complexity, easy to maintain
âœ… **Performance** - Negligible overhead for test code generation

This decision prioritizes developer experience and long-term maintainability over marginal performance gains, aligning with Fakt's mission to provide a **MAP (Minimum Awesome Product)** for test fake generation.
