# Codegen V2 - Type-Safe Code Generation DSL

**Production-ready code generation library for Fakt compiler plugin**

Codegen V2 is a type-safe DSL for generating Kotlin code. It replaces 1366+ lines of manual string-based code generation with a clean, composable, and testable API.

## Features

- ✅ **Type-safe DSL** - No string concatenation, compile-time safety
- ✅ **Composable builders** - Build complex code structures incrementally
- ✅ **Smart default values** - Automatic default value resolution for all Kotlin types
- ✅ **Extension functions** - High-level patterns for common fake generation
- ✅ **Comprehensive testing** - 149+ tests with GIVEN-WHEN-THEN pattern
- ✅ **Production ready** - Used by Fakt compiler plugin for fake generation

## Quick Start

### Basic Class Generation

```kotlin
val file = codeFile("com.example") {
    klass("UserService") {
        function("getUser") {
            parameter("id", "String")
            returns("User?")
            body = "return repository.findById(id)"
        }
    }
}

val code = file.renderToString()
```

**Output:**
```kotlin
package com.example

class UserService {
    fun getUser(id: String): User? {
        return repository.findById(id)
    }
}
```

### Complete Fake Generation

```kotlin
val fake = generateCompleteFake(
    packageName = "com.example",
    interfaceName = "UserService",
    methods = listOf(
        MethodSpec("getUser", listOf("id" to "String"), "User?"),
        MethodSpec("saveUser", listOf("user" to "User"), "Result<Unit>", isSuspend = true)
    ),
    properties = listOf(
        PropertySpec("users", "StateFlow<List<User>>", isStateFlow = true)
    )
)
```

**Output:**
```kotlin
package com.example

import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.MutableStateFlow

class FakeUserServiceImpl : UserService {
    private var getUserBehavior: (String) -> User? = { null }

    override fun getUser(id: String): User? {
        return getUserBehavior(id)
    }

    internal fun configureGetUser(behavior: (String) -> User?): Unit {
        getUserBehavior = behavior
    }

    private var saveUserBehavior: suspend (User) -> Result<Unit> = { Result.success(Unit) }

    override suspend fun saveUser(user: User): Result<Unit> {
        return saveUserBehavior(user)
    }

    internal fun configureSaveUser(behavior: suspend (User) -> Result<Unit>): Unit {
        saveUserBehavior = behavior
    }

    private val usersValue: StateFlow<List<User>> = MutableStateFlow(emptyList())

    override val users: StateFlow<List<User>>
        get() = usersValue
}
```

## Core Components

### 1. Builders

**File Builder** - Top-level structure
```kotlin
codeFile("com.example") {
    header = "Generated by Fakt"
    import("kotlinx.coroutines.flow.StateFlow")
    klass("MyClass") { /* ... */ }
}
```

**Class Builder** - Class structure
```kotlin
klass("FakeService") {
    implements("Service")
    property("count", "Int") { /* ... */ }
    function("process") { /* ... */ }
}
```

**Function Builder** - Method structure
```kotlin
function("getUser") {
    override()
    suspend()
    parameter("id", "String")
    returns("User?")
    body = "return getUserBehavior(id)"
}
```

**Property Builder** - Property structure
```kotlin
property("users", "StateFlow<List<User>>") {
    override()
    getter = "usersValue"
}
```

### 2. Extension Functions

**Property Extensions** - Common property patterns
```kotlin
// StateFlow with backing MutableStateFlow
stateFlowProperty("users", "List<User>", "emptyList()")

// Behavior property for functions
behaviorProperty("getUser", listOf("String"), "User?", "{ null }")

// Suspend behavior property
suspendBehaviorProperty("saveUser", listOf("User"), "Result<Unit>", "{ Result.success(Unit) }")

// Simple mutable property
mutableProperty("count", "Int", "0")
```

**Method Extensions** - Common method patterns
```kotlin
// Override method delegating to behavior
overrideMethod("getUser", listOf("id" to "String"), "User?")

// Vararg method
overrideVarargMethod("process", "items", "String", "Int")

// Configuration method
configureMethod("getUser", listOf("String"), "User?")
```

**Fake Generator** - Complete fake generation
```kotlin
generateCompleteFake(
    packageName = "com.example",
    interfaceName = "UserService",
    methods = listOf(/* MethodSpec */),
    properties = listOf(/* PropertySpec */),
    imports = listOf("com.example.domain.User"),
    header = "Generated by Fakt"
)
```

### 3. Default Value Resolution

Automatic default values for all Kotlin types:

```kotlin
val resolver = DefaultValueResolver()

// Primitives
resolver.resolve(parseType("Int"))      // 0
resolver.resolve(parseType("Boolean"))  // false
resolver.resolve(parseType("String"))   // ""

// Nullable types
resolver.resolve(parseType("User?"))    // null

// Collections
resolver.resolve(parseType("List<User>"))        // emptyList()
resolver.resolve(parseType("Map<String, Int>"))  // emptyMap()
resolver.resolve(parseType("Set<String>"))       // emptySet()

// Stdlib types
resolver.resolve(parseType("Result<Unit>"))      // Result.success(Unit)
resolver.resolve(parseType("StateFlow<User>"))   // MutableStateFlow(defaultValue)
resolver.resolve(parseType("Flow<User>"))        // emptyFlow()
```

### 4. Type Parsing

Parse Kotlin type strings into structured types:

```kotlin
// Simple types
parseType("String")                    // SimpleType("String")
parseType("User?")                     // NullableType(SimpleType("User"))

// Generic types
parseType("List<User>")                // GenericType("List", [SimpleType("User")])
parseType("Map<String, List<User>>")   // GenericType("Map", [SimpleType("String"), GenericType(...)])

// Function types
parseType("(String) -> User?")         // FunctionType([SimpleType("String")], NullableType(...))
parseType("suspend () -> Unit")        // SuspendFunctionType([], SimpleType("Unit"))
```

## Architecture

### Layered Design

```
┌─────────────────────────────────────────┐
│  Extension Functions                    │  ← High-level patterns
│  (PropertyExtensions, MethodExtensions, │
│   FakeGenerator)                        │
├─────────────────────────────────────────┤
│  Builders                               │  ← DSL API
│  (CodeFileBuilder, ClassBuilder,        │
│   FunctionBuilder, PropertyBuilder)     │
├─────────────────────────────────────────┤
│  Strategy Layer                         │  ← Default value resolution
│  (DefaultValueResolver, Strategies)     │
├─────────────────────────────────────────┤
│  Model Layer                            │  ← Immutable data structures
│  (CodeFile, Class, Function, Property,  │
│   TypeModel, CodeExpression)            │
├─────────────────────────────────────────┤
│  Renderer                               │  ← Code generation
│  (Rendering.kt, CodeBuilder)            │
└─────────────────────────────────────────┘
```

### Key Principles

1. **Immutability** - All models are immutable data classes
2. **Builder Pattern** - Mutable builders create immutable models
3. **Strategy Pattern** - Pluggable default value resolution
4. **Separation of Concerns** - Build → Render → Output
5. **Type Safety** - Compile-time guarantees, no stringly-typed code

## Usage Patterns

### Pattern 1: Simple Override Method

```kotlin
klass("FakeUserService") {
    // Behavior property
    behaviorProperty("getUser", listOf("String"), "User?", "{ null }")

    // Override method
    overrideMethod("getUser", listOf("id" to "String"), "User?")

    // Configuration method
    configureMethod("getUser", listOf("String"), "User?")
}
```

### Pattern 2: Suspend Function

```kotlin
klass("FakeAsyncService") {
    // Suspend behavior
    suspendBehaviorProperty("fetchData", emptyList(), "Data?", "{ null }")

    // Suspend override
    overrideMethod("fetchData", emptyList(), "Data?", isSuspend = true)

    // Configuration
    configureMethod("fetchData", emptyList(), "Data?", isSuspend = true)
}
```

### Pattern 3: StateFlow Property

```kotlin
klass("FakeUserStore") {
    // StateFlow with backing MutableStateFlow
    stateFlowProperty("users", "List<User>", "emptyList()")
}
```

### Pattern 4: Vararg Function

```kotlin
klass("FakeLogger") {
    property("logBehavior", "(Array<out String>) -> Unit") {
        private()
        mutable()
        initializer = "{ _ -> Unit }"
    }

    overrideVarargMethod("log", "messages", "String", "Unit")
}
```

## Testing

All components are thoroughly tested with GIVEN-WHEN-THEN pattern:

```kotlin
@Test
fun `GIVEN stateFlowProperty WHEN generating THEN creates backing MutableStateFlow`() {
    // GIVEN
    val file = codeFile("com.example") {
        klass("FakeStore") {
            stateFlowProperty("users", "List<User>", "emptyList()")
        }
    }

    // WHEN
    val code = file.renderToString()

    // THEN
    assertContains(code, "private val usersValue: StateFlow<List<User>> = MutableStateFlow(emptyList())")
    assertContains(code, "override val users: StateFlow<List<User>>")
    assertContains(code, "get() = usersValue")
}
```

**Test Coverage:**
- Builder Tests: 30+ tests
- Strategy Tests: 40+ tests
- Integration Tests: 38+ tests
- Compilation Tests: 8 tests
- Extension Tests: 33 tests
- **Total: 149+ tests**

## Performance

- **Build time**: Minimal overhead (~50-100ms for typical fake generation)
- **Memory**: Efficient immutable data structures
- **Output size**: Generates clean, minimal code

## Migration from Old Generator

**Old (String-based):**
```kotlin
// 1366 lines of manual string concatenation
buildString {
    append("package $packageName\n\n")
    append("class Fake${interfaceName}Impl : $interfaceName {\n")
    // ... hundreds of lines of string manipulation
}
```

**New (DSL-based):**
```kotlin
// ~50 lines with type safety
generateCompleteFake(
    packageName = packageName,
    interfaceName = interfaceName,
    methods = methods,
    properties = properties
)
```

## Future Enhancements

- [ ] Support for nested classes
- [ ] Support for companion objects
- [ ] Support for annotations
- [ ] Support for type aliases
- [ ] Custom rendering strategies
- [ ] Code formatting options (indent size, line width)

## Contributing

All code must follow:
- ✅ **TDD approach** - Write tests first (RED → GREEN → REFACTOR)
- ✅ **GIVEN-WHEN-THEN** naming pattern
- ✅ **Vanilla JUnit5** + kotlin-test (no custom matchers)
- ✅ **Isolated test instances** (no shared state)
- ✅ **Professional KDoc** for all public APIs

See `.claude/docs/validation/testing-guidelines.md` for full guidelines.

## License

Apache 2.0 - See LICENSE file for details.
