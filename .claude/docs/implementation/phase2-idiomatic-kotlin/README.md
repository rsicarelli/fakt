# Phase 2: Idiomatic Kotlin & Developer Experience (Q2 2025)

> **Strategic Goal**: Automate boilerplate for common Kotlin patterns
> **Target**: Reduce test setup effort by **50%+**
> **Timeline**: 8-10 weeks
> **Status**: Planning

## Executive Summary

Phase 2 shifts focus from performance optimization to **developer productivity**. While Phase 1 solves critical speed bottlenecks, Phase 2 addresses the tedious, error-prone manual work that developers face when writing tests for idiomatic Kotlin code.

Modern Kotlin applications use specific patterns extensively:
- **Data classes** for DTOs, domain models, API responses
- **Sealed hierarchies** for state machines, result types
- **Flows** for asynchronous data streams
- **Abstract classes** for framework integration

Testing these patterns currently requires significant manual boilerplate: building test data, instantiating every sealed state, creating fake Flow producers, and implementing abstract members. Fakt can automate all of this.

---

## The Boilerplate Crisis

### Research Findings

From [Best Practices for Unit Testing in Kotlin](https://phauer.com/2018/best-practices-unit-testing-kotlin/):

1. **Data Class Test Helpers**:
   - Manual builder functions are recommended best practice
   - Developers spend significant time writing these helpers
   - Copy-paste errors are common
   - Updates to data classes require updating builders

2. **Sealed Hierarchy Testing**:
   - Comprehensive test coverage requires instantiating all states
   - Boilerplate multiplies with nested sealed classes
   - Easy to miss states (until compiler complains)

3. **Flow Testing**:
   - Manual fake producers require understanding of `MutableSharedFlow`, `StateFlow`
   - Turbine library helps but still requires setup
   - Controllable emissions need careful state management

### Community Consensus

**Data Classes**: **DON'T MOCK THEM**
- Source: [How to mock data class?](https://androidpro.io/how-to-mock-data-class/)
- Mocking a data class is an anti-pattern
- Use real instances with test data builders instead
- Fakt should generate the builders, not mock the class

**Sealed Classes**: **FACTORY HELPERS**
- Source: [Sealed classes made easy](https://www.reddit.com/r/Kotlin/comments/1aip16b/sealed_classes_made_easy/)
- Common pattern: Helper functions to create each state
- Manual boilerplate for every hierarchy
- Fakt can automate this entirely

**Flows**: **FAKE PRODUCERS**
- Source: [Kotlin Flows Testing Guide](https://betulnecanli.medium.com/flow-testing-full-guide-a3e0980f66c8)
- Best practice: Replace real repository with fake that exposes Flow
- Manual: Create `MutableSharedFlow`, expose as `Flow`, emit test data
- Fakt can generate controllable producers

---

## Phase 2 Features

### 2.1 Test Data Builders for Data Classes
**Priority**: MEDIUM-HIGH (Quick Win)
**Complexity**: Low (1-2 weeks)
**Detailed Docs**: [dataClasses/APPROACH.md](./dataClasses/APPROACH.md)

**Problem**: Creating test instances of complex data classes is verbose and error-prone.

```kotlin
// Manual approach (boilerplate!)
fun createTestUser(
    id: String = "test-id",
    name: String = "Test User",
    email: String = "test@example.com",
    age: Int = 25,
    address: Address = createTestAddress(),
    preferences: UserPreferences = createTestPreferences()
): User {
    return User(id, name, email, age, address, preferences)
}
```

**Fakt's Solution**: Auto-generate these builders with smart defaults.

```kotlin
// Generated by Fakt
fun createTestUser(
    id: String = "test-id-1",
    name: String = "Test Name",
    email: String = "test@example.com",
    age: Int = 0,
    address: Address = createTestAddress(),
    preferences: UserPreferences = createTestPreferences()
): User = User(id, name, email, age, address, preferences)
```

**Success Metric**: Zero manual builder functions needed for data classes.

---

### 2.2 Sealed Hierarchy Factory Helpers
**Priority**: MEDIUM (Common Pattern)
**Complexity**: Medium (2-3 weeks)
**Detailed Docs**: [sealedHierarchies/APPROACH.md](./sealedHierarchies/APPROACH.md)

**Problem**: Testing state machines requires manual instantiation of every state.

```kotlin
// Production code
sealed interface UIState {
    object Loading : UIState
    data class Success(val data: String) : UIState
    data class Error(val exception: Exception) : UIState
}

// Manual test helpers (boilerplate!)
object TestUIState {
    val loading = UIState.Loading
    fun success(data: String = "test-data") = UIState.Success(data)
    fun error(exception: Exception = Exception("Test error")) = UIState.Error(exception)
}
```

**Fakt's Solution**: Generate factory objects for entire hierarchies.

```kotlin
// Generated by Fakt
object FakeUIState {
    val loading: UIState.Loading = UIState.Loading
    fun success(data: String = "test-data"): UIState.Success = UIState.Success(data)
    fun error(exception: Exception = Exception("Fake error")): UIState.Error = UIState.Error(exception)
}

// Usage in tests
@Test
fun `test loading state`() {
    viewModel.setState(FakeUIState.loading)
    // ...
}
```

**Success Metric**: Comprehensive sealed state coverage with zero manual helpers.

---

### 2.3 Controllable Flow Fake Producers
**Priority**: MEDIUM-HIGH (Modern Kotlin Apps)
**Complexity**: Medium-High (3-4 weeks)
**Detailed Docs**: [flowProducers/APPROACH.md](./flowProducers/APPROACH.md)

**Problem**: Testing components that consume Flows requires manual fake producers.

```kotlin
// Manual approach (complex!)
class FakeUserRepository : UserRepository {
    private val usersFlow = MutableSharedFlow<List<User>>(replay = 1)

    override fun observeUsers(): Flow<List<User>> = usersFlow.asSharedFlow()

    suspend fun emitUsers(users: List<User>) {
        usersFlow.emit(users)
    }
}
```

**Fakt's Solution**: Generate controllable fake producers automatically.

```kotlin
// Generated by Fakt
class FakeUserRepositoryImpl : UserRepository {
    // Controllable emitter exposed for tests
    val usersFlowController = MutableSharedFlow<List<User>>(replay = 1)

    override fun observeUsers(): Flow<List<User>> = usersFlowController.asSharedFlow()
}

fun fakeUserRepository(configure: FakeUserRepositoryConfig.() -> Unit = {}): UserRepository {
    return FakeUserRepositoryImpl().apply {
        FakeUserRepositoryConfig(this).configure()
    }
}

// Usage in tests
@Test
fun `test user updates`() = runTest {
    val fake = fakeUserRepository()

    // Emit test data
    fake.usersFlowController.emit(listOf(User("1", "Alice")))

    viewModel.observeUsers()

    // Assert on state changes
}
```

**Success Metric**: Flow testing without manual `MutableSharedFlow` management.

---

### 2.4 Abstract Class Concrete Implementations
**Priority**: LOW-MEDIUM (Less Common)
**Complexity**: Medium (2-3 weeks)
**Detailed Docs**: [abstractClasses/APPROACH.md](./abstractClasses/APPROACH.md)

**Problem**: Testing concrete methods that depend on abstract members.

```kotlin
// Production code
abstract class BaseViewModel(val analyticsService: AnalyticsService) {
    abstract fun loadData(): Flow<Data>

    fun trackScreenView() {
        analyticsService.trackEvent("screen_view")
        // Additional concrete logic
    }
}

// Manual test approach
class TestViewModel(analyticsService: AnalyticsService) : BaseViewModel(analyticsService) {
    override fun loadData(): Flow<Data> = flowOf(Data.test())
}
```

**Fakt's Solution**: Generate concrete implementations with configurable abstract members.

```kotlin
// Generated by Fakt
class FakeBaseViewModelImpl(
    analyticsService: AnalyticsService
) : BaseViewModel(analyticsService) {
    var loadDataBehavior: () -> Flow<Data> = { flowOf() }

    override fun loadData(): Flow<Data> = loadDataBehavior()

    internal fun configureLoadData(behavior: () -> Flow<Data>) {
        loadDataBehavior = behavior
    }
}

// Usage
val fake = fakeBaseViewModel(analyticsService) {
    loadData { flowOf(Data.test()) }
}
```

**Success Metric**: Abstract class testing without manual subclassing.

---

## Implementation Strategy

### Week 1-2: Data Class Builders (Quick Win)
- Analyze data class primary constructor
- Generate builder functions with smart defaults
- Handle nested data classes (recursive builders)
- Support nullable types and collections
- Test coverage: Simple, complex, nested data classes

### Week 3-5: Sealed Hierarchy Helpers
- Detect sealed classes and interfaces
- Analyze entire hierarchy (all subclasses)
- Generate factory object with methods for each state
- Handle data class children (integrate with builders)
- Handle object children (singleton references)
- Test coverage: Simple, nested, complex hierarchies

### Week 6-9: Flow Producers (Core Feature)
- Extend existing fake generation for Flow-returning methods
- Generate `MutableSharedFlow` controllers
- Support `StateFlow`, `SharedFlow`, regular `Flow`
- Provide test-friendly APIs (emit, complete, error)
- Integration with Turbine patterns
- Test coverage: Flow types, backpressure, errors

### Week 10: Abstract Classes
- Extend class analysis for abstract classes
- Generate concrete implementations
- Handle abstract properties and methods
- Constructor parameter support (from Phase 1.1)
- Test coverage: Simple, complex, generic abstract classes

---

## Success Metrics

### Developer Experience (Qualitative)
- âœ… **Zero Boilerplate**: No manual builder functions needed
- âœ… **Type-safe Defaults**: Smart default values for all types
- âœ… **Clear Intent**: Generated helpers are readable and intuitive
- âœ… **Seamless Integration**: Works with existing test patterns

### Productivity (Quantitative)
- ðŸŽ¯ **50%+ Test Setup Reduction**: Measured by lines of test helper code
- ðŸŽ¯ **Faster Test Writing**: Time to write first test for new feature
- ðŸŽ¯ **Fewer Copy-paste Errors**: Reduced bugs in test data setup
- ðŸŽ¯ **Better Coverage**: Easier to test all sealed states

### Adoption Indicators
- ðŸŽ¯ **Community Feedback**: Positive sentiment about DX improvement
- ðŸŽ¯ **Feature Usage**: Data builders used in 80%+ of projects
- ðŸŽ¯ **Documentation Shares**: Guides and examples shared widely

---

## Best Practices Alignment

### "Don't Mock Data Classes" âœ…
- Aligns with industry consensus
- Generates real instance builders instead
- Encourages state-based testing
- Reference: [Android Testing Best Practices](https://developer.android.com/training/testing/fundamentals/test-doubles)

### "Fakes Over Mocks" âœ…
- Flow producers are true fakes (working implementations)
- Sealed helpers encourage state testing
- Abstract class fakes maintain real behavior
- Reference: [Google's Now in Android](https://github.com/android/nowinandroid/wiki/Testing-strategy-and-how-to-test)

### Kotlin Idioms âœ…
- Data classes for data
- Sealed hierarchies for state
- Flows for async streams
- Reference: [Kotlin Best Practices](https://phauer.com/2018/best-practices-unit-testing-kotlin/)

---

## Risk Mitigation

### Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Smart defaults don't work for all types | Medium | Medium | Comprehensive type mapping, allow customization |
| Nested data classes create circular refs | Low | High | Detect cycles, generate with optional params |
| Flow producers don't fit all patterns | Medium | Medium | Survey common patterns, provide alternatives |
| Abstract class constructors too complex | Medium | Low | Leverage Phase 1.1 infrastructure |

### Market Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Developers prefer manual control | Low | Medium | Make generation opt-in, allow customization |
| Generated code is hard to understand | Medium | High | Clear naming, add documentation comments |
| Feature isn't actually time-saving | Low | High | Benchmark manually vs. generated |

---

## Testing Strategy

### GIVEN-WHEN-THEN Coverage

All Phase 2 features must follow the absolute standard:

```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class DataClassBuilderGenerationTest {

    @Test
    fun `GIVEN simple data class WHEN generating builder THEN should create function with defaults`() = runTest {
        // Given
        val dataClass = """
            data class User(val id: String, val name: String, val age: Int)
        """

        // When
        val result = compilationTestHelper.compile(dataClass)

        // Then
        assertTrue(result.hasFunction("createTestUser"))
        assertTrue(result.getFunction("createTestUser").hasDefaultParameters())
        assertTrue(result.compiles())
    }

    @Test
    fun `GIVEN nested data class WHEN generating builder THEN should handle recursively`() = runTest {
        // Given
        val dataClasses = """
            data class Address(val street: String, val city: String)
            data class User(val name: String, val address: Address)
        """

        // When
        val result = compilationTestHelper.compile(dataClasses)

        // Then
        assertTrue(result.hasFunction("createTestAddress"))
        assertTrue(result.hasFunction("createTestUser"))
        assertTrue(result.getFunction("createTestUser").usesFunction("createTestAddress"))
        assertTrue(result.compiles())
    }
}
```

### Integration Tests

Test entire workflows:

```kotlin
@Test
fun `GIVEN ViewModel with sealed state WHEN using generated helpers THEN should cover all states`() = runTest {
    // Given
    val viewModel = MyViewModel(fakeRepository())

    // When - test all states using generated helpers
    viewModel.setState(FakeUIState.loading)
    assertEquals(UIState.Loading, viewModel.state.value)

    viewModel.setState(FakeUIState.success("data"))
    assertEquals("data", (viewModel.state.value as UIState.Success).data)

    viewModel.setState(FakeUIState.error(Exception("Test")))
    assertTrue(viewModel.state.value is UIState.Error)

    // Then - all states tested with zero boilerplate
}
```

---

## Metro Alignment

### Relevant Metro Patterns

1. **Code Generation Quality**: Metro generates production-quality code
   - Apply: Generated builders should be readable and idiomatic
   - Quality bar: Looks like hand-written code

2. **Smart Defaults**: Metro provides sensible default configurations
   - Pattern: Analyze types to determine appropriate defaults
   - Apply: String â†’ "test-value", Int â†’ 0, Boolean â†’ false

3. **Extensibility**: Metro allows customization
   - Pattern: Generated code can be customized by users
   - Apply: Allow overriding default values easily

### Consultation Checklist

- [ ] Review Metro's code generation formatting
- [ ] Check Metro's approach to default value selection
- [ ] Validate naming conventions with Metro standards

---

## Documentation Deliverables

### For Developers
- [ ] **Data Class Builder Guide**: How to use generated builders
- [ ] **Sealed Hierarchy Testing**: Patterns and examples
- [ ] **Flow Testing Patterns**: Integration with Turbine
- [ ] **Migration Guide**: From manual helpers to Fakt

### For Contributors
- [ ] **Smart Defaults Implementation**: Type â†’ default value mapping
- [ ] **Sealed Analysis Algorithm**: Hierarchy traversal
- [ ] **Flow Controller Generation**: MutableSharedFlow patterns

### Public Facing
- [ ] **Blog Post**: "Stop Writing Test Builders by Hand"
- [ ] **Video Tutorial**: Fakt in action for idiomatic Kotlin
- [ ] **Comparison**: Before/after code samples

---

## Next Steps

1. âœ… Review this README
2. ðŸŽ¯ Read detailed approach docs for each feature:
   - [Data Classes APPROACH.md](./dataClasses/APPROACH.md)
   - [Sealed Hierarchies APPROACH.md](./sealedHierarchies/APPROACH.md)
   - [Flow Producers APPROACH.md](./flowProducers/APPROACH.md)
   - [Abstract Classes APPROACH.md](./abstractClasses/APPROACH.md)
3. ðŸŽ¯ Start with Data Class Builders (quick win, clear value)
4. ðŸŽ¯ Validate sealed hierarchy patterns with real projects
5. ðŸŽ¯ Prototype Flow controller generation

---

## References

- **Main Roadmap**: [../roadmap.md](../roadmap.md)
- **Research Document**: `Kotlin Test Fake Research Roadmap.md`
- **Best Practices**: [Philipp Hauer's Kotlin Testing Guide](https://phauer.com/2018/best-practices-unit-testing-kotlin/)
- **Flow Testing**: [Kotlin Flows Testing Guide](https://betulnecanli.medium.com/flow-testing-full-guide-a3e0980f66c8)
- **Testing Guidelines**: [../../validation/testing-guidelines.md](../../validation/testing-guidelines.md)

---

**Phase 2 Success = Developer productivity revolution.** ðŸŽ¨
