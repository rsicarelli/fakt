# Data Class Test Builders: Technical Approach

> **Feature**: Auto-generated test data builder functions
> **Priority**: MEDIUM-HIGH (Quick Win)
> **Complexity**: Low (1-2 weeks)
> **Target**: Zero manual builder boilerplate

## Problem Statement

### The Data Class Testing Consensus

**Community Consensus: DON'T MOCK DATA CLASSES**

From [How to mock data class?](https://androidpro.io/how-to-mock-data-class/):
> "Mocking a data class is an anti-pattern. Data classes are meant to hold data, not behavior. Use real instances with test data instead."

From [Best Practices for Unit Testing in Kotlin](https://phauer.com/2018/best-practices-unit-testing-kotlin/):
> "Create helper functions (builders) in your test source set that return data class instances with sensible default values. This drastically improves test readability."

**The Right Approach**: Use real instances, but automate the builder creation.

### The Manual Builder Pain

```kotlin
// Production code
data class User(
    val id: String,
    val name: String,
    val email: String,
    val age: Int,
    val address: Address,
    val preferences: UserPreferences,
    val createdAt: LocalDateTime,
    val isActive: Boolean
)

// Manual test builder (tedious!)
fun createTestUser(
    id: String = "test-id-${UUID.randomUUID()}",
    name: String = "Test User",
    email: String = "test@example.com",
    age: Int = 25,
    address: Address = createTestAddress(),
    preferences: UserPreferences = createTestPreferences(),
    createdAt: LocalDateTime = LocalDateTime.now(),
    isActive: Boolean = true
): User {
    return User(id, name, email, age, address, preferences, createdAt, isActive)
}

// Must also create builders for nested types!
fun createTestAddress(...): Address { ... }
fun createTestPreferences(...): UserPreferences { ... }
```

**Pain Points**:
1. **Boilerplate Overhead**: Every data class needs a builder
2. **Maintenance Burden**: Add a property ‚Üí update builder
3. **Copy-paste Errors**: Typos in default values
4. **Nested Complexity**: Recursive builders for nested data classes
5. **Inconsistency**: Each developer uses different default values

---

## Fakt's Solution: Smart Test Data Builder Generation

### Core Idea

For every data class, automatically generate a `createTest{ClassName}()` function with:
1. **All parameters optional** with sensible defaults
2. **Type-aware defaults**: Strings, numbers, booleans, nullables, collections
3. **Nested builders**: Automatically call builders for other data classes
4. **Readable defaults**: "test-user-1" better than random UUIDs

### Example Output

```kotlin
// Production code (unchanged)
data class User(
    val id: String,
    val name: String,
    val email: String,
    val age: Int,
    val isActive: Boolean,
    val tags: List<String>,
    val metadata: Map<String, String>?
)

// Generated by Fakt (in test source set)
/**
 * Test data builder for [User].
 * All parameters have sensible defaults and can be overridden.
 */
fun createTestUser(
    id: String = "test-user-id-1",
    name: String = "Test Name",
    email: String = "test@example.com",
    age: Int = 0,
    isActive: Boolean = true,
    tags: List<String> = emptyList(),
    metadata: Map<String, String>? = null
): User = User(
    id = id,
    name = name,
    email = email,
    age = age,
    isActive = isActive,
    tags = tags,
    metadata = metadata
)

// Usage in tests
@Test
fun `test user creation`() {
    // Override only what matters for this test
    val user = createTestUser(
        name = "Alice",
        age = 30
    )

    assertEquals("Alice", user.name)
    assertEquals(30, user.age)
    assertEquals("test@example.com", user.email) // Uses default
}
```

---

## Implementation Plan

### Phase 1: Analysis (Week 1, Day 1-2)

#### 1.1 Detect Data Classes

```kotlin
// In InterfaceAnalyzer (extend to handle data classes)
fun IrClass.isDataClass(): Boolean {
    return isData
}

fun analyzeDataClass(irClass: IrClass): AnalyzedType.DataClass {
    val primaryConstructor = irClass.primaryConstructor
        ?: error("Data class must have primary constructor")

    val parameters = primaryConstructor.valueParameters.map { param ->
        DataClassParameter(
            name = param.name.asString(),
            type = param.type,
            isNullable = param.type.isNullable(),
            defaultValue = param.defaultValue
        )
    }

    return AnalyzedType.DataClass(
        declaration = irClass,
        primaryConstructor = primaryConstructor,
        parameters = parameters
    )
}
```

#### 1.2 Type Analysis

```kotlin
sealed class ParameterType {
    data class Primitive(val kind: PrimitiveKind) : ParameterType()
    data class String : ParameterType()
    data class Collection(val elementType: IrType) : ParameterType()
    data class Map(val keyType: IrType, val valueType: IrType) : ParameterType()
    data class DataClass(val classRef: IrClass) : ParameterType()
    data class Custom(val type: IrType) : ParameterType()
    data class Nullable(val underlyingType: ParameterType) : ParameterType()
}

fun IrType.categorize(): ParameterType {
    return when {
        isString() -> ParameterType.String
        isInt() -> ParameterType.Primitive(PrimitiveKind.INT)
        isBoolean() -> ParameterType.Primitive(PrimitiveKind.BOOLEAN)
        isLong() -> ParameterType.Primitive(PrimitiveKind.LONG)
        isDouble() -> ParameterType.Primitive(PrimitiveKind.DOUBLE)
        isList() -> ParameterType.Collection(getCollectionElementType())
        isMap() -> ParameterType.Map(getMapKeyType(), getMapValueType())
        isNullable() -> ParameterType.Nullable(makeNotNull().categorize())
        isDataClass() -> ParameterType.DataClass(getClassOrFail())
        else -> ParameterType.Custom(this)
    }
}
```

### Phase 2: Smart Default Generation (Week 1, Day 3-5)

#### 2.1 Default Value Strategy

```kotlin
class SmartDefaultGenerator(
    private val pluginContext: IrPluginContext,
    private val counter: AtomicInteger = AtomicInteger(1)
) {

    fun generateDefault(param: DataClassParameter): IrExpression {
        val type = param.type.categorize()

        return when (type) {
            is ParameterType.String -> generateStringDefault(param.name)
            is ParameterType.Primitive -> generatePrimitiveDefault(type.kind)
            is ParameterType.Collection -> generateCollectionDefault()
            is ParameterType.Map -> generateMapDefault()
            is ParameterType.DataClass -> generateDataClassDefault(type.classRef)
            is ParameterType.Nullable -> IrConstImpl.constNull(...)
            is ParameterType.Custom -> generateCustomDefault(param.type)
        }
    }

    private fun generateStringDefault(paramName: String): IrExpression {
        // Generate contextual default based on parameter name
        val defaultValue = when {
            paramName.contains("id", ignoreCase = true) -> "test-$paramName-${counter.getAndIncrement()}"
            paramName.contains("email", ignoreCase = true) -> "test@example.com"
            paramName.contains("name", ignoreCase = true) -> "Test Name"
            paramName.contains("url", ignoreCase = true) -> "https://example.com"
            else -> "test-$paramName"
        }

        return IrConstImpl.string(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            type = irBuiltIns.stringType,
            value = defaultValue
        )
    }

    private fun generatePrimitiveDefault(kind: PrimitiveKind): IrExpression {
        return when (kind) {
            PrimitiveKind.INT -> IrConstImpl.int(..., 0)
            PrimitiveKind.LONG -> IrConstImpl.long(..., 0L)
            PrimitiveKind.BOOLEAN -> IrConstImpl.boolean(..., true)
            PrimitiveKind.DOUBLE -> IrConstImpl.double(..., 0.0)
            // ... other primitives
        }
    }

    private fun generateCollectionDefault(): IrExpression {
        // Return emptyList() / emptySet() / emptyMap()
        return IrCallImpl(
            ...,
            symbol = irBuiltIns.emptyListFunction
        )
    }

    private fun generateDataClassDefault(dataClass: IrClass): IrExpression {
        // Call the generated builder for this nested data class
        val builderFunction = findGeneratedBuilder(dataClass)

        return IrCallImpl(
            ...,
            symbol = builderFunction.symbol
        )
    }
}
```

#### 2.2 Contextual Defaults

**Smart naming-based defaults**:

| Parameter Name Pattern | Default Value |
|------------------------|---------------|
| `*id` | "test-{param}-1" |
| `*email*` | "test@example.com" |
| `*url*` | "https://example.com" |
| `*name*` | "Test Name" |
| `*phone*` | "555-0100" |
| `*date*`, `*time*` | Current time or epoch |
| Generic string | "test-{param}" |

### Phase 3: Builder Function Generation (Week 2)

#### 3.1 Generate Builder Function

```kotlin
fun generateBuilderFunction(dataClass: AnalyzedType.DataClass): IrSimpleFunction {
    val builderFunction = irFactory.buildFun {
        name = Name.identifier("createTest${dataClass.declaration.name}")
        returnType = dataClass.declaration.defaultType
        visibility = DescriptorVisibilities.PUBLIC
    }

    // Add parameter for each data class property
    dataClass.parameters.forEach { param ->
        builderFunction.addValueParameter {
            name = Name.identifier(param.name)
            type = param.type
        }.also { irParam ->
            // Set default value expression
            irParam.defaultValue = irFactory.createExpressionBody(
                SmartDefaultGenerator().generateDefault(param)
            )
        }
    }

    // Function body: construct data class instance
    builderFunction.body = irFactory.createBlockBody(...).apply {
        statements.add(
            IrReturnImpl(
                ...,
                builderFunction.symbol,
                IrConstructorCallImpl(
                    ...,
                    symbol = dataClass.primaryConstructor.symbol,
                    typeArgumentsCount = 0,
                    constructorTypeArgumentsCount = 0,
                    valueArgumentsCount = dataClass.parameters.size
                ).apply {
                    // Map builder params to constructor args
                    dataClass.parameters.forEachIndexed { index, param ->
                        putValueArgument(
                            index,
                            IrGetValueImpl(
                                ...,
                                builderFunction.valueParameters[index].symbol
                            )
                        )
                    }
                }
            )
        )
    }

    return builderFunction
}
```

#### 3.2 KDoc Generation

```kotlin
fun generateBuilderKDoc(dataClass: AnalyzedType.DataClass): String {
    return """
        /**
         * Test data builder for [${dataClass.declaration.name}].
         * All parameters have sensible defaults and can be overridden.
         *
         * Example:
         * ```
         * val user = createTest${dataClass.declaration.name}(
         *     name = "Alice",
         *     age = 30
         * )
         * ```
         *
         * @see ${dataClass.declaration.name}
         */
    """.trimIndent()
}
```

---

## Edge Cases & Challenges

### Challenge 1: Circular References

```kotlin
data class Node(val value: String, val parent: Node?)
```

**Solution**: Use `null` as default for self-referential types:

```kotlin
fun createTestNode(
    value: String = "test-value",
    parent: Node? = null // ‚úÖ Break circular reference
): Node = Node(value, parent)
```

### Challenge 2: Generic Data Classes

```kotlin
data class Result<T>(val value: T, val error: String?)
```

**Solution**: Generate generic builder:

```kotlin
fun <T> createTestResult(
    value: T, // ‚ùå Can't provide default for unknown type
    error: String? = null
): Result<T> = Result(value, error)
```

**Alternative**: Reified builders for common types:

```kotlin
inline fun <reified T> createTestResult(
    value: T = defaultValue<T>(),
    error: String? = null
): Result<T> = Result(value, error)
```

### Challenge 3: Value Classes (Inline Classes)

```kotlin
@JvmInline
value class UserId(val value: String)

data class User(val id: UserId, val name: String)
```

**Solution**: Generate builders for value classes too:

```kotlin
fun createTestUserId(value: String = "test-id-1"): UserId = UserId(value)

fun createTestUser(
    id: UserId = createTestUserId(),
    name: String = "Test Name"
): User = User(id, name)
```

### Challenge 4: Collections with Complex Elements

```kotlin
data class Team(val members: List<User>)
```

**Solution**: Default to empty, allow easy population:

```kotlin
fun createTestTeam(
    members: List<User> = emptyList()
): Team = Team(members)

// Usage
val team = createTestTeam(
    members = listOf(
        createTestUser(name = "Alice"),
        createTestUser(name = "Bob")
    )
)
```

---

## Testing Strategy

### GIVEN-WHEN-THEN Coverage

```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class DataClassBuilderGenerationTest {

    @Test
    fun `GIVEN simple data class WHEN generating builder THEN should have all parameters with defaults`() = runTest {
        // Given
        val dataClass = """
            data class User(val id: String, val name: String, val age: Int)
        """

        // When
        val result = compilationTestHelper.compile(dataClass)

        // Then
        assertTrue(result.hasFunction("createTestUser"))
        val builder = result.getFunction("createTestUser")
        assertEquals(3, builder.parameters.size)
        assertTrue(builder.parameters.all { it.hasDefault() })
        assertTrue(result.compiles())
    }

    @Test
    fun `GIVEN nested data classes WHEN generating builders THEN should call nested builders`() = runTest {
        // Given
        val dataClasses = """
            data class Address(val street: String, val city: String)
            data class User(val name: String, val address: Address)
        """

        // When
        val result = compilationTestHelper.compile(dataClasses)

        // Then
        assertTrue(result.hasFunction("createTestAddress"))
        assertTrue(result.hasFunction("createTestUser"))

        val userBuilder = result.getFunction("createTestUser")
        val addressParam = userBuilder.parameters.find { it.name == "address" }
        assertNotNull(addressParam)
        assertTrue(addressParam.defaultValue.callsFunction("createTestAddress"))
        assertTrue(result.compiles())
    }

    @Test
    fun `GIVEN data class with smart-named properties WHEN generating defaults THEN should use contextual values`() = runTest {
        // Given
        val dataClass = """
            data class User(val email: String, val phoneNumber: String, val websiteUrl: String)
        """

        // When
        val result = compilationTestHelper.compile(dataClass)

        // Then
        val builder = result.getFunction("createTestUser")
        assertTrue(builder.getParameter("email").defaultValue.contains("@"))
        assertTrue(builder.getParameter("phoneNumber").defaultValue.contains("555"))
        assertTrue(builder.getParameter("websiteUrl").defaultValue.startsWith("https://"))
        assertTrue(result.compiles())
    }
}
```

### Integration Tests

```kotlin
@Test
fun `GIVEN generated builder WHEN used in actual test THEN should work seamlessly`() = runTest {
    // Given: Data class with builder generated by Fakt
    data class Product(
        val id: String,
        val name: String,
        val price: Double,
        val inStock: Boolean
    )

    // When: Use generated builder
    val product1 = createTestProduct() // All defaults
    val product2 = createTestProduct(name = "Custom Product", price = 99.99)

    // Then: Should work as expected
    assertNotNull(product1.id)
    assertEquals("Test Name", product1.name)
    assertEquals(0.0, product1.price)
    assertTrue(product1.inStock)

    assertEquals("Custom Product", product2.name)
    assertEquals(99.99, product2.price)
}
```

---

## Success Criteria

### Must Have (P0)
- ‚úÖ Generate builder functions for all data classes with `@Fake` annotation (or file-level)
- ‚úÖ All parameters have sensible defaults
- ‚úÖ Smart defaults based on parameter names (email, url, phone, etc.)
- ‚úÖ Nested data class support (recursive builders)
- ‚úÖ Nullable types default to `null`
- ‚úÖ Collections default to `emptyList()` / `emptySet()` / `emptyMap()`
- ‚úÖ Generated code compiles and works correctly

### Should Have (P1)
- ‚úÖ KDoc comments on generated functions
- ‚úÖ Value class support
- ‚úÖ Circular reference handling (use `null`)
- ‚úÖ Clear error messages for unsupported cases

### Nice to Have (P2)
- ‚è≥ Generic data class support (limited)
- ‚è≥ Custom default value annotations
- ‚è≥ IDE integration (autocomplete for generated builders)

---

## Metro Alignment

### Relevant Patterns

1. **Code Quality**: Metro generates readable, production-quality code
   - Apply: Builder functions should look hand-written
   - Standard: Proper formatting, naming, KDoc

2. **Smart Defaults**: Metro provides sensible defaults for DI
   - Pattern: Analyze context to determine appropriate defaults
   - Apply: Parameter name analysis for contextual defaults

### Consultation

- [ ] Review Metro's approach to default value generation
- [ ] Check Metro's code formatting and documentation standards

---

## Next Steps

1. ‚úÖ Review this approach document
2. üéØ Implement data class detection and analysis
3. üéØ Create smart default generator with type mapping
4. üéØ Generate builder functions with proper signatures
5. üéØ Handle nested data classes (recursive builders)
6. üéØ Add KDoc comments to generated functions
7. üéØ Test with real-world data classes from projects

---

## References

- **Don't Mock Data Classes**: [Android Pro Guide](https://androidpro.io/how-to-mock-data-class/)
- **Best Practices**: [Philipp Hauer's Guide](https://phauer.com/2018/best-practices-unit-testing-kotlin/)
- **Phase 2 README**: [../README.md](../README.md)
- **Main Roadmap**: [../../roadmap.md](../../roadmap.md)

---

**Data Class Builders = Zero boilerplate, maximum productivity.** üéØ
