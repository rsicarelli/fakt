# Generated API Reference - KtFakes

> **Purpose**: Complete reference for the API generated by KtFakes compiler plugin
> **Status**: Production-Ready with Real Examples
> **Testing Standard**: [ðŸ“‹ Testing Guidelines](.claude/docs/validation/testing-guidelines.md)

## ðŸŽ¯ **Generated API Overview**

For every `@Fake` annotated interface, KtFakes generates three main components:
1. **Implementation Class** - `Fake{InterfaceName}Impl`
2. **Factory Function** - `fake{interfaceName}()`
3. **Configuration DSL** - `Fake{InterfaceName}Config`

## ðŸ—ï¸ **Implementation Class API**

### **Naming Convention**
```kotlin
@Fake 
interface UserService â†’ class FakeUserServiceImpl

@Fake 
interface ApiClient â†’ class FakeApiClientImpl

@Fake 
interface DataRepository â†’ class FakeDataRepositoryImpl
```

### **Generated Structure**
```kotlin
class Fake{InterfaceName}Impl : {InterfaceName} {
    // Behavior storage fields
    private var {methodName}Behavior: {LambdaType} = {DefaultValue}

    // Property implementations (for interface properties)
    override val {propertyName}: {Type} get() = {propertyName}Behavior()

    // Method implementations
    override fun {methodName}({parameters}): {ReturnType} = {methodName}Behavior({arguments})

    // Configuration methods (internal)
    internal fun configure{MethodName}(behavior: {LambdaType}) { {methodName}Behavior = behavior }
}
```

### **Real Example**
```kotlin
// From: @Fake interface TestService
class FakeTestServiceImpl : TestService {
    // Behavior storage
    private var someValueVehavior: () -> String = { "" }
    private var getValueBehavior: () -> String = { "" }
    private var setValueBehavior: (String) -> Unit = { _ -> Unit }

    // Interface implementation
    override val someValue: String get() = someValueBehavior()
    override fun getValue(): String = getValueBehavior()
    override fun setValue(value: String): Unit = setValueBehavior(value)

    // Configuration API (internal)
    internal fun configuresomeValue(behavior: () -> String) { someValueBehavior = behavior }
    internal fun configureGetValue(behavior: () -> String) { getValueBehavior = behavior }
    internal fun configureSetValue(behavior: (String) -> Unit) { setValueBehavior = behavior }
}
```

## ðŸ­ **Factory Function API**

### **Function Signature Pattern**
```kotlin
fun fake{interfaceName}(configure: Fake{InterfaceName}Config.() -> Unit = {}): {InterfaceName}
```

### **Generated Factory Functions**
```kotlin
// Basic interface
fun fakeTestService(configure: FakeTestServiceConfig.() -> Unit = {}): TestService

// Suspend functions interface
fun fakeAsyncUserService(configure: FakeAsyncUserServiceConfig.() -> Unit = {}): AsyncUserService

// Method-only interface
fun fakeAnalyticsService(configure: FakeAnalyticsServiceConfig.() -> Unit = {}): AnalyticsService
```

### **Factory Implementation Pattern**
```kotlin
fun fake{InterfaceName}(configure: Fake{InterfaceName}Config.() -> Unit = {}): {InterfaceName} {
    return Fake{InterfaceName}Impl().apply { Fake{InterfaceName}Config(this).configure() }
}
```

### **Usage Examples**
```kotlin
// Default behavior (smart defaults)
val service = fakeTestService()

// Custom behavior configuration
val customService = fakeTestService {
    getValue { "custom-value" }
    someValue { "doge-someValue" }
    setValue { value -> println("Setting: $value") }
}

// Suspend function configuration
val asyncService = fakeAsyncUserService {
    getUser { id -> "User-$id" }
    updateUser { id, name -> true }
}
```

## ðŸ”§ **Configuration DSL API**

### **DSL Class Structure**
```kotlin
class Fake{InterfaceName}Config(private val fake: Fake{InterfaceName}Impl) {
    // Property configuration
    fun {propertyName}(behavior: () -> {Type}) { fake.configure{PropertyName}(behavior) }

    // Method configuration
    fun {methodName}(behavior: ({ParameterTypes}) -> {ReturnType}) {
        fake.configure{MethodName}(behavior)
    }
}
```

### **Real Configuration DSL Examples**

#### **Basic Interface Configuration**
```kotlin
class FakeTestServiceConfig(private val fake: FakeTestServiceImpl) {
    fun someValue(behavior: () -> String) { fake.configuresomeValue(behavior) }
    fun getValue(behavior: () -> String) { fake.configureGetValue(behavior) }
    fun setValue(behavior: (String) -> Unit) { fake.configureSetValue(behavior) }
}
```

#### **Suspend Functions Configuration**
```kotlin
class FakeAsyncUserServiceConfig(private val fake: FakeAsyncUserServiceImpl) {
    fun getUser(behavior: suspend (String) -> String) { fake.configureGetUser(behavior) }
    fun updateUser(behavior: suspend (String, String) -> Boolean) { fake.configureUpdateUser(behavior) }
}
```

#### **Complex Parameters Configuration**
```kotlin
class FakeApiClientConfig(private val fake: FakeApiClientImpl) {
    fun get(behavior: (String, Map<String, String>) -> Result<String>) { fake.configureGet(behavior) }
    fun post(behavior: (String, Any, Map<String, String>) -> Result<String>) { fake.configurePost(behavior) }
}
```

## ðŸ“Š **Type System Mapping**

### **Lambda Type Generation**
```kotlin
// Method signature â†’ Behavior lambda type
fun getValue(): String â†’ () -> String
fun setValue(value: String) â†’ (String) -> Unit
fun process(a: Int, b: String): Boolean â†’ (Int, String) -> Boolean
suspend fun fetch(id: String): Result<User> â†’ suspend (String) -> Result<User>
```

### **Default Value Generation**
```kotlin
// Return type â†’ Default lambda
String â†’ { "" }
Int â†’ { 0 }
Boolean â†’ { false }
Unit â†’ { Unit }
List<T> â†’ { emptyList() }
Result<T> â†’ { Result.success(defaultValue<T>()) }
T? (nullable) â†’ { null }
suspend () -> T â†’ { defaultValue<T>() }
```

### **Parameter Mapping**
```kotlin
// Interface parameters are preserved exactly in lambda types
fun updateUser(id: String, name: String, active: Boolean): Boolean
// Generated lambda:
(String, String, Boolean) -> Boolean
```

## ðŸ§ª **Generated API Testing**

### **Factory Function Tests**
```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class FactoryFunctionTest {

    @Test
    fun `GIVEN factory function WHEN called with no config THEN should return working fake`() = runTest {
        // Given & When
        val service = fakeTestService()

        // Then
        assertNotNull(service)
        assertEquals("", service.getValue()) // Default behavior
        assertEquals("", service.someValue) // Default property value
    }

    @Test
    fun `GIVEN factory function WHEN configured THEN should use custom behavior`() = runTest {
        // Given
        val service = fakeTestService {
            getValue { "custom-value" }
            someValue { "custom-someValue" }
        }

        // When & Then
        assertEquals("custom-value", service.getValue())
        assertEquals("custom-someValue", service.someValue)
    }
}
```

### **Configuration DSL Tests**
```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ConfigurationDslTest {

    @Test
    fun `GIVEN configuration DSL WHEN setting behaviors THEN should configure implementation`() = runTest {
        // Given
        var setValue_called = false
        val service = fakeTestService {
            setValue { value ->
                setValue_called = true
                println("Called setValue with: $value")
            }
        }

        // When
        service.setValue("test-value")

        // Then
        assertTrue(setValue_called)
    }

    @Test
    fun `GIVEN suspend function config WHEN called THEN should work correctly`() = runTest {
        // Given
        val service = fakeAsyncUserService {
            getUser { id -> "User-$id" }
            updateUser { id, name -> id.isNotEmpty() && name.isNotEmpty() }
        }

        // When & Then
        assertEquals("User-123", service.getUser("123"))
        assertTrue(service.updateUser("123", "John"))
        assertFalse(service.updateUser("", ""))
    }
}
```

### **Type Safety Tests**
```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class TypeSafetyTest {

    @Test
    fun `GIVEN generated implementation WHEN used THEN should be type safe`() = runTest {
        // Given - Type safety validated at compile time
        val service: TestService = fakeTestService {
            getValue { "typed-string" }
            // setValue { 123 } // Would not compile - type mismatch
        }

        // When & Then
        val result: String = service.getValue() // Type preserved
        assertEquals("typed-string", result)
    }
}
```

## ðŸ”— **Generated File Locations**

### **Output Directory Structure**
```
build/generated/ktfake/test/kotlin/
â”œâ”€â”€ TestServiceFakes.kt           # Contains all generated code for TestService
â”œâ”€â”€ AsyncUserServiceFakes.kt      # Contains all generated code for AsyncUserService
â””â”€â”€ AnalyticsServiceFakes.kt      # Contains all generated code for AnalyticsService
```

### **Generated File Content Structure**
```kotlin
// File: TestServiceFakes.kt
package com.example.test

// 1. Implementation class
class FakeTestServiceImpl : TestService { ... }

// 2. Factory function
fun fakeTestService(configure: FakeTestServiceConfig.() -> Unit = {}): TestService { ... }

// 3. Configuration DSL
class FakeTestServiceConfig(private val fake: FakeTestServiceImpl) { ... }
```

## ðŸ”— **Related Documentation**

- **[ðŸ“‹ API Specifications](.claude/docs/api/specifications.md)** - Complete API overview
- **[ðŸ“‹ Annotations Reference](.claude/docs/api/annotations.md)** - @Fake annotation details
- **[ðŸ“‹ Working Examples](.claude/docs/examples/working-examples.md)** - Practical usage patterns
- **[ðŸ“‹ Type Safety Validation](.claude/docs/validation/type-safety-validation.md)** - Type system behavior

---

**This generated API reference reflects the current production implementation with examples from real generated code in the test-sample project.**