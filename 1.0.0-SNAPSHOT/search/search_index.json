{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Fakt","text":"<p>Compile-time type-safe test fakes for Kotlin Multiplatform</p> <p> </p> <p>Fakt is a Kotlin compiler plugin that generates test fakes at compile-time. No runtime reflection. No production dependencies. Just type-safe fakes that break when your interfaces change.</p> <pre><code>@Fake\ninterface AnalyticsService {\n    fun track(event: String)\n}\n\n// Use in tests\nval fake = fakeAnalyticsService {\n    track { event -&gt; println(\"Tracked: $event\") }\n}\n\nfake.track(\"user_signup\")\nassertEquals(1, fake.trackCallCount.value)\n</code></pre>"},{"location":"index.html#why-fakt","title":"Why Fakt?","text":"<p>Writing test fakes manually is tedious and error-prone. Fakt generates type-safe fakes automatically at compile-time, eliminating boilerplate while maintaining compile-time safety.</p> <p>The problem with manual fakes:</p> <ul> <li>Repetitive boilerplate for every interface</li> <li>Manual call tracking (non-thread-safe)</li> <li>Refactoring breaks nothing at compile-time</li> <li>Maintenance burden scales with codebase</li> </ul> <p>How Fakt solves this:</p> <ul> <li>Compile-time generation: Zero reflection, works on ALL KMP targets</li> <li>Type safety: Refactoring breaks tests immediately</li> <li>StateFlow tracking: Thread-safe, reactive call counting</li> <li>Zero overhead: No production dependencies, test-only code</li> <li>Clean DSL: Intuitive configuration interface</li> </ul>"},{"location":"index.html#key-features","title":"Key Features","text":""},{"location":"index.html#universal-multiplatform-support","title":"\u2705 Universal Multiplatform Support","text":"<p>Works on all Kotlin targets without reflection: JVM, Android, iOS, Native, JavaScript, WebAssembly.</p> <p>Unlike runtime mocking frameworks (MockK, Mockito), Fakt generates code at the IR level\u2014native compilation everywhere.</p>"},{"location":"index.html#zero-production-overhead","title":"\u2705 Zero Production Overhead","text":"<p>Fakt has zero runtime cost and zero production dependencies:</p> <ul> <li>Annotation-only runtime (BINARY retention, no dependencies)</li> <li>Test-only generation (generated in test source sets)</li> <li>No production leakage</li> <li>IR-level generation (not text-based)</li> </ul>"},{"location":"index.html#built-in-stateflow-call-tracking","title":"\u2705 Built-In StateFlow Call Tracking","text":"<p>Every generated fake includes reactive, thread-safe call tracking via Kotlin <code>StateFlow</code>:</p> <pre><code>val fake = fakeUserRepository()\n\nfake.getUser(\"123\")\nfake.getUser(\"456\")\n\n// Thread-safe, reactive call counting\nassertEquals(2, fake.getUserCallCount.value)\n</code></pre>"},{"location":"index.html#full-language-support","title":"\u2705 Full Language Support","text":"<ul> <li>Suspend functions: Full coroutine support</li> <li>Generics: Class-level, method-level, constraints, variance</li> <li>Properties: val/var with getter/setter tracking</li> <li>Smart defaults: Identity functions for generics, sensible primitives</li> </ul>"},{"location":"index.html#quick-example","title":"Quick Example","text":"<p>1. Annotate an interface:</p> <pre><code>import com.rsicarelli.fakt.Fake\n\n@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n    suspend fun saveUser(user: User): Result&lt;Unit&gt;\n}\n</code></pre> <p>2. Build your project:</p> <pre><code>./gradlew build\n</code></pre> <p>3. Use in tests:</p> <pre><code>import kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\n\nclass UserRepositoryTest {\n    @Test\n    fun `GIVEN fake repository WHEN saving user THEN returns success`() = runTest {\n        val fake = fakeUserRepository {\n            saveUser { user -&gt; Result.success(Unit) }\n        }\n\n        val result = fake.saveUser(User(\"123\", \"Alice\"))\n\n        assertTrue(result.isSuccess)\n        assertEquals(1, fake.saveUserCallCount.value)\n    }\n}\n</code></pre>"},{"location":"index.html#get-started","title":"Get Started","text":"<p>Ready to eliminate test boilerplate?</p> <ul> <li>Installation - Add Fakt to your project</li> <li>Quick Start - Your first fake in 5 minutes</li> <li>Features - What Fakt supports</li> </ul>"},{"location":"index.html#platform-support","title":"Platform Support","text":"Platform Targets Status JVM <code>jvm()</code> \u2705 Android <code>androidTarget()</code> \u2705 iOS <code>iosArm64()</code>, <code>iosX64()</code>, <code>iosSimulatorArm64()</code> \u2705 macOS <code>macosArm64()</code>, <code>macosX64()</code> \u2705 Linux <code>linuxArm64()</code>, <code>linuxX64()</code> \u2705 Windows <code>mingwX64()</code> \u2705 JavaScript <code>js(IR)</code> - Browser &amp; Node.js \u2705 WebAssembly <code>wasmJs()</code> \u2705 watchOS <code>watchosArm64()</code>, <code>watchosX64()</code>, <code>watchosSimulatorArm64()</code> \u2705 tvOS <code>tvosArm64()</code>, <code>tvosX64()</code>, <code>tvosSimulatorArm64()</code> \u2705 <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p>"},{"location":"index.html#requirements","title":"Requirements","text":"<ul> <li>Kotlin: 2.2.20+</li> <li>Gradle: 8.0+</li> <li>JVM: 11+</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>Fakt is licensed under the Apache License 2.0. See LICENSE for details.</p> <pre><code>Copyright (C) 2025 Rodrigo Sicarelli\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\n</code></pre>"},{"location":"faq.html","title":"Frequently Asked Questions","text":"<p>Common questions about Fakt, answered with honesty and technical context.</p>"},{"location":"faq.html#stability-safety","title":"Stability &amp; Safety","text":""},{"location":"faq.html#is-fakt-safe-to-use-in-production-testing","title":"Is Fakt safe to use in production testing?","text":"<p>Short answer: Yes. Fakt is functionally stable and ready for production use in test suites.</p> <p>Longer answer: Fakt follows a two-phase FIR \u2192 IR compilation architecture inspired by production compiler plugins like Metro. While the Kotlin compiler plugin API is not a stable API (marked <code>@UnsafeApi</code>), Fakt:</p> <ul> <li>Generates code at compile-time with zero runtime dependencies</li> <li>Has been tested across Kotlin 2.2.20+ and all KMP targets</li> <li>Uses forward compatibility patterns (N+.2 version support)</li> <li>Is versioned as 1.0.0-SNAPSHOT to signal pre-1.0 status</li> </ul> <p>Generated fakes are production-quality code that compiles to native binaries without reflection.</p> <p>Compiler Plugin API Stability</p> <p>The Kotlin compiler plugin API can change between Kotlin versions. Fakt is tested against each Kotlin release and updated as needed. Pin your Kotlin version in production CI/CD.</p>"},{"location":"faq.html#why-100-snapshot-instead-of-100","title":"Why \u201c1.0.0-SNAPSHOT\u201d instead of \u201c1.0.0\u201d?","text":"<p>We\u2019re following semantic versioning strictly:</p> <ul> <li>SNAPSHOT signals that we\u2019re still validating real-world usage patterns</li> <li>1.0.0 will be released after community feedback and battle-testing</li> <li>The compiler plugin API is functionally complete and stable for production testing</li> </ul> <p>We prioritize honesty over marketing. SNAPSHOT doesn\u2019t mean \u201cbroken\u201d\u2014it means \u201cwe\u2019re listening to feedback before declaring 1.0.\u201d</p>"},{"location":"faq.html#comparison-with-other-tools","title":"Comparison with Other Tools","text":""},{"location":"faq.html#why-not-use-mockk-or-mockito","title":"Why not use MockK or Mockito?","text":"<p>MockK and Mockito are runtime mocking frameworks that use reflection. This limits them to JVM/Android targets and adds runtime overhead.</p> <p>Fakt generates fakes at compile-time using Kotlin IR, which means:</p> <ul> <li>\u2705 Works on ALL KMP targets (iOS, Native, JS, WASM) without reflection</li> <li>\u2705 Zero runtime cost (no reflection proxy overhead)</li> <li>\u2705 Compile-time type safety (refactoring breaks tests immediately)</li> <li>\u2705 Generated code you can read and debug</li> </ul> <p>Use MockK/Mockito when: - You need dynamic mocking (testing framework internals) - You\u2019re mocking concrete classes with complex inheritance - You\u2019re on JVM-only projects and don\u2019t need KMP</p> <p>Use Fakt when: - You\u2019re building Kotlin Multiplatform projects - You want type-safe, cross-platform test doubles - You prefer explicit, readable fake implementations - You want zero runtime cost and no reflection</p>"},{"location":"faq.html#how-does-fakt-compare-to-hand-written-fakes","title":"How does Fakt compare to hand-written fakes?","text":"<p>Fakt generates the same code you\u2019d write manually, but faster and without mistakes:</p> Aspect Hand-Written Fakes Fakt Fakes Boilerplate ~50 lines per interface Auto-generated Call tracking Manual (<code>var count = 0</code>) StateFlow (thread-safe) Refactoring safety Breaks silently Breaks at compile-time Maintenance Scales with codebase Zero maintenance Customization Full control DSL configuration <p>Fakt doesn\u2019t replace hand-written fakes for complex scenarios (stateful mocks, partial implementations). It eliminates boilerplate for the 80% case.</p>"},{"location":"faq.html#feature-support","title":"Feature Support","text":""},{"location":"faq.html#does-fakt-support-generics","title":"Does Fakt support generics?","text":"<p>Yes. Fakt fully supports:</p> <ul> <li>\u2705 Class-level generics (<code>interface Repository&lt;T&gt;</code>)</li> <li>\u2705 Method-level generics (<code>fun &lt;T&gt; transform(value: T): T</code>)</li> <li>\u2705 Generic constraints (<code>&lt;T : Comparable&lt;T&gt;&gt;</code>)</li> <li>\u2705 Variance (<code>out T</code>, <code>in T</code>)</li> </ul> <p>Generated fakes preserve type parameters and use smart defaults:</p> <pre><code>@Fake\ninterface Repository&lt;T&gt; {\n    fun save(item: T): Result&lt;Unit&gt;\n    fun &lt;R&gt; transform(item: T, mapper: (T) -&gt; R): R\n}\n\n// Generated fake works as expected\nval fake = fakeRepository&lt;User&gt; {\n    save { item -&gt; Result.success(Unit) }\n    transform { item, mapper -&gt; mapper(item) }\n}\n</code></pre> <p>Current limitation: Some complex nested generics with multiple constraints may require manual implementation. We track edge cases in GitHub issues.</p>"},{"location":"faq.html#does-fakt-support-suspend-functions","title":"Does Fakt support suspend functions?","text":"<p>Yes. Suspend functions are fully supported:</p> <pre><code>@Fake\ninterface ApiClient {\n    suspend fun fetchData(id: String): Result&lt;Data&gt;\n}\n\nval fake = fakeApiClient {\n    fetchData { id -&gt;\n        delay(100) // Suspends correctly\n        Result.success(Data(id))\n    }\n}\n</code></pre> <p>Fakt preserves coroutine semantics\u2014no weird <code>runBlocking</code> wrappers needed.</p>"},{"location":"faq.html#does-fakt-support-properties-valvar","title":"Does Fakt support properties (val/var)?","text":"<p>Yes. Both read-only (<code>val</code>) and mutable (<code>var</code>) properties are supported:</p> <pre><code>@Fake\ninterface Settings {\n    val theme: String\n    var fontSize: Int\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n    fontSize { 14 }\n}\n\nassertEquals(\"dark\", fake.theme)\nassertEquals(1, fake.themeCallCount.value)\n\nfake.fontSize = 16\nassertEquals(1, fake.setFontSizeCallCount.value)\n</code></pre> <p>Mutable properties generate both getter and setter call counters.</p>"},{"location":"faq.html#can-i-fake-data-classes-or-sealed-classes","title":"Can I fake data classes or sealed classes?","text":"<p>No. Fakt only generates fakes for:</p> <ul> <li>\u2705 Interfaces</li> <li>\u2705 Abstract classes</li> <li>\u2705 Open classes (overridable members only)</li> </ul> <p>Data classes and sealed classes work fine as parameter/return types, but you can\u2019t put <code>@Fake</code> on them directly.</p> <p>Why: Data classes have fixed implementations (compiler-generated). Faking them would be misleading\u2014use builders or copy() instead.</p>"},{"location":"faq.html#performance","title":"Performance","text":""},{"location":"faq.html#what-about-performance-impact-on-build-times","title":"What about performance impact on build times?","text":"<p>Fakt uses intelligent caching across KMP targets. First target compilation typically adds ~40ms for 100+ interfaces. Subsequent targets (JVM, iOS, Android) hit cache and add ~1ms each.</p> <p>For large projects (1000+ interfaces), expect:</p> <ul> <li>First compilation: ~200-400ms</li> <li>Cached targets: near-zero overhead (~1-2ms each)</li> </ul> <p>Example from a real KMP project:</p> <pre><code>DISCOVERY: 1ms (100 interfaces, 21 classes)\nGENERATION: 39ms (121 new fakes, avg 333\u00b5s/fake)\nTOTAL: 40ms (iosArm64 first compilation)\n\ncompileKotlinJvm:     1ms (121 from cache)\ncompileKotlinAndroid: 1ms (121 from cache)\n</code></pre> <p>See Performance Guide for detailed benchmarks and telemetry configuration.</p>"},{"location":"faq.html#multi-module-projects","title":"Multi-Module Projects","text":""},{"location":"faq.html#does-fakt-work-with-multi-module-projects","title":"Does Fakt work with multi-module projects?","text":"<p>Yes, with experimental multi-module support:</p> <pre><code>// Producer module: :core:analytics/build.gradle.kts\n@Fake\ninterface Analytics\n\n// Collector module: :core:analytics-fakes/build.gradle.kts\nplugins {\n    id(\"com.rsicarelli.fakt\")\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\n// Consumer module: :app/build.gradle.kts\ndependencies {\n    commonTest {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre> <p>For comprehensive documentation, see: - Multi-Module Overview - Architecture and when to use - Getting Started - Step-by-step setup guide - kmp-multi-module sample - Working example</p> <p>Experimental Feature</p> <p>Multi-module support is marked <code>@ExperimentalFaktMultiModule</code>. It works but the API may change before 1.0.</p>"},{"location":"faq.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq.html#generated-fakes-arent-appearing-in-my-ide","title":"Generated fakes aren\u2019t appearing in my IDE","text":"<p>Solutions:</p> <ol> <li>Rebuild the project: <code>./gradlew clean build</code></li> <li>Invalidate IDE caches: File \u2192 Invalidate Caches \u2192 Invalidate and Restart</li> <li>Check build directory: Fakes are in <code>build/generated/fakt/commonTest/kotlin/</code></li> <li>Verify Gradle sync: Ensure Gradle sync completed successfully</li> </ol>"},{"location":"faq.html#im-getting-unresolved-reference-fakexxx","title":"I\u2019m getting \u201cUnresolved reference: fakeXxx\u201d","text":"<p>Common causes:</p> <ol> <li>Missing build step: Run <code>./gradlew build</code> first</li> <li>Wrong source set: Import from test code (<code>src/commonTest/</code>), not main</li> <li>Package mismatch: Generated fakes are in the same package as the interface</li> <li>Gradle sync issue: Re-sync Gradle in your IDE</li> </ol>"},{"location":"faq.html#compilation-fails-with-irtypealiassymbol-not-found","title":"Compilation fails with \u201cIrTypeAliasSymbol not found\u201d","text":"<p>This usually means:</p> <ol> <li>Kotlin version mismatch: Ensure you\u2019re on Kotlin 2.2.20+</li> <li>Fakt version incompatibility: Update Fakt to match your Kotlin version</li> </ol> <p>See Compatibility for version requirements.</p>"},{"location":"faq.html#contributing-reporting-issues","title":"Contributing &amp; Reporting Issues","text":""},{"location":"faq.html#how-can-i-contribute-to-fakt","title":"How can I contribute to Fakt?","text":"<p>Contributions are welcome! Please:</p> <ol> <li>Follow GIVEN-WHEN-THEN testing standard</li> <li>Ensure all generated code compiles without errors</li> <li>Test both single-platform and KMP scenarios</li> <li>Run <code>make format</code> before committing</li> </ol> <p>See Contributing Guide for development workflows.</p>"},{"location":"faq.html#where-do-i-report-bugs","title":"Where do I report bugs?","text":"<p>Report issues on GitHub Issues. Please include:</p> <ul> <li>Kotlin version</li> <li>Fakt version</li> <li>KMP targets (if applicable)</li> <li>Minimal reproduction (interface + error message)</li> <li>Full compilation logs (<code>./gradlew build --info</code>)</li> </ul>"},{"location":"faq.html#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Troubleshooting - Common issues and solutions</li> <li>GitHub Discussions - Ask the community</li> <li>GitHub Issues - Report bugs</li> </ul>"},{"location":"troubleshooting.html","title":"Troubleshooting","text":"<p>Common issues and solutions.</p>"},{"location":"troubleshooting.html#generated-fakes-not-appearing","title":"Generated Fakes Not Appearing","text":"<p>Symptoms: IDE doesn\u2019t recognize <code>fakeXxx()</code> factory functions</p> <p>Solutions:</p> <ol> <li>Rebuild the project: <code>./gradlew clean build</code></li> <li>Invalidate IDE caches: File \u2192 Invalidate Caches \u2192 Invalidate and Restart</li> <li>Check build directory: Fakes are in <code>build/generated/fakt/commonTest/kotlin/</code></li> <li>Verify Gradle sync: Ensure Gradle sync completed successfully</li> </ol>"},{"location":"troubleshooting.html#unresolved-reference-fakexxx","title":"Unresolved Reference: fakeXxx","text":"<p>Common causes:</p> <ol> <li>Missing build step: Run <code>./gradlew build</code> first</li> <li>Wrong source set: Import from test code (<code>src/commonTest/</code>), not main</li> <li>Package mismatch: Generated fakes are in the same package as the interface</li> <li>Gradle sync issue: Re-sync Gradle in your IDE</li> </ol>"},{"location":"troubleshooting.html#compilation-fails-with-irtypealiassymbol-not-found","title":"Compilation Fails with \u201cIrTypeAliasSymbol not found\u201d","text":"<p>Causes:</p> <ol> <li>Kotlin version mismatch: Ensure you\u2019re on Kotlin 2.2.20+</li> <li>Fakt version incompatibility: Update Fakt to match your Kotlin version</li> </ol> <p>Solution:</p> <pre><code>// gradle/libs.versions.toml\n[versions]\nkotlin = \"2.2.20\"\nfakt = \"1.0.0-SNAPSHOT\"\n</code></pre>"},{"location":"troubleshooting.html#build-is-slow","title":"Build is Slow","text":"<p>Solutions:</p> <ol> <li> <p>Use LogLevel.QUIET in CI/CD: <pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)\n}\n</code></pre></p> </li> <li> <p>Check cache hit rate with <code>LogLevel.INFO</code></p> </li> <li> <p>Verify incremental compilation is enabled</p> </li> </ol>"},{"location":"troubleshooting.html#still-having-issues","title":"Still Having Issues?","text":"<ul> <li>FAQ - Common questions</li> <li>GitHub Issues - Report bugs</li> <li>GitHub Discussions - Ask questions</li> </ul>"},{"location":"guides/migration.html","title":"Migration from MockK/Mockito","text":"<p>Migrating from runtime mocking frameworks to Fakt compile-time fakes.</p>"},{"location":"guides/migration.html#why-migrate","title":"Why Migrate?","text":"Aspect MockK/Mockito Fakt Platform Support JVM/Android only All KMP targets Runtime Cost Reflection overhead Zero (compile-time) Type Safety Runtime errors Compile-time errors Debugging Proxy magic Generated code Refactoring Silent failures Breaks at compile-time"},{"location":"guides/migration.html#mockk-fakt","title":"MockK \u2192 Fakt","text":"<p>MockK:</p> <pre><code>@Test\nfun `test with MockK`() {\n    val mock = mockk&lt;UserRepository&gt;()\n    every { mock.getUser(any()) } returns User(\"123\", \"Alice\")\n\n    val service = UserService(mock)\n    service.processUser(\"123\")\n\n    verify(exactly = 1) { mock.getUser(\"123\") }\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN fake repository WHEN processing user THEN calls getUser`() {\n    val fake = fakeUserRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    val service = UserService(fake)\n    service.processUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n}\n</code></pre>"},{"location":"guides/migration.html#mockito-fakt","title":"Mockito \u2192 Fakt","text":"<p>Mockito:</p> <pre><code>@Test\nfun `test with Mockito`() {\n    val mock = mock(UserRepository::class.java)\n    `when`(mock.getUser(anyString())).thenReturn(User(\"123\", \"Alice\"))\n\n    val service = UserService(mock)\n    service.processUser(\"123\")\n\n    verify(mock, times(1)).getUser(\"123\")\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN fake repository WHEN processing user THEN calls getUser`() {\n    val fake = fakeUserRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    val service = UserService(fake)\n    service.processUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n}\n</code></pre>"},{"location":"guides/migration.html#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Add Fakt plugin to <code>build.gradle.kts</code></li> <li>[ ] Annotate interfaces with <code>@Fake</code></li> <li>[ ] Build project to generate fakes</li> <li>[ ] Replace <code>mockk&lt;T&gt;()</code> / <code>mock(T::class.java)</code> with <code>fakeT {}</code></li> <li>[ ] Replace <code>every { }</code> / <code>when()</code> with DSL configuration</li> <li>[ ] Replace <code>verify { }</code> with call counter assertions</li> <li>[ ] Remove MockK/Mockito dependencies</li> </ul>"},{"location":"guides/migration.html#next-steps","title":"Next Steps","text":"<ul> <li>Testing Patterns - Best practices</li> <li>Performance - Build time impact</li> </ul>"},{"location":"guides/performance.html","title":"Performance","text":"<p>Fakt\u2019s compile-time impact and telemetry system.</p>"},{"location":"guides/performance.html#build-time-impact","title":"Build Time Impact","text":"<p>Fakt uses intelligent caching across KMP targets:</p> <p>First target compilation:</p> <pre><code>DISCOVERY: 1ms (100 interfaces, 21 classes)\nGENERATION: 39ms (121 new fakes, avg 333\u00b5s/fake)\nTOTAL: 40ms\n</code></pre> <p>Subsequent targets (cached):</p> <pre><code>compileKotlinJvm:     1ms (121 from cache)\ncompileKotlinAndroid: 1ms (121 from cache)\ncompileKotlinIosX64:  1ms (121 from cache)\n</code></pre>"},{"location":"guides/performance.html#telemetry-configuration","title":"Telemetry Configuration","text":"<p>Four log levels for debugging and performance analysis:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.LogLevel\n\nfakt {\n    logLevel.set(LogLevel.INFO)   // Default: concise summary\n    // LogLevel.QUIET  - Zero output (CI/CD)\n    // LogLevel.DEBUG  - Detailed breakdown with FIR + IR details\n}\n</code></pre>"},{"location":"guides/performance.html#log-level-outputs","title":"Log Level Outputs","text":"<p>INFO (default):</p> <pre><code>\u2705 10 fakes generated in 1.2s (6 cached)\n   Discovery: 120ms | Analysis: 340ms | Generation: 580ms\n   Cache hit rate: 40% (6/15)\n</code></pre> <p>DEBUG:</p> <pre><code>[DISCOVERY] 120ms - 15 interfaces, 3 classes\n[FILTERING] 85ms - Cache hits: 6/15 (40%)\n[ANALYSIS] 340ms\n  \u251c\u2500 UserRepository (18ms)\n  \u251c\u2500 Analytics (42ms)\n  \u251c\u2500 FIR + IR node inspection, type resolution\n</code></pre> <p>Includes full FIR + IR details, type resolution, etc. (~5-10ms overhead)</p>"},{"location":"guides/performance.html#cache-strategy","title":"Cache Strategy","text":"<p>Fakt caches generated code across:</p> <ul> <li>KMP targets (jvm, ios, android, etc.)</li> <li>Incremental compilation runs</li> <li>Clean builds (invalidates cache)</li> </ul>"},{"location":"guides/performance.html#best-practices","title":"Best Practices","text":""},{"location":"guides/performance.html#use-quiet-in-cicd","title":"\u2705 Use QUIET in CI/CD","text":"<pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)  // Zero overhead\n}\n</code></pre>"},{"location":"guides/performance.html#use-debug-for-troubleshooting","title":"\u2705 Use DEBUG for Troubleshooting","text":"<pre><code>fakt {\n    logLevel.set(LogLevel.DEBUG)  // ~5-10ms overhead\n}\n</code></pre>"},{"location":"guides/performance.html#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Plugin options</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"guides/testing-patterns.html","title":"Testing Patterns","text":"<p>Best practices for using Fakt-generated fakes in your test suites.</p>"},{"location":"guides/testing-patterns.html#given-when-then-pattern","title":"GIVEN-WHEN-THEN Pattern","text":"<p>Follow BDD-style test naming with Fakt fakes:</p> <pre><code>@Test\nfun `GIVEN configured repository WHEN saving user THEN returns success`() = runTest {\n    // GIVEN\n    val fake = fakeUserRepository {\n        saveUser { user -&gt; Result.success(Unit) }\n    }\n    val service = UserService(fake)\n\n    // WHEN\n    val result = service.createUser(\"Alice\")\n\n    // THEN\n    assertTrue(result.isSuccess)\n    assertEquals(1, fake.saveUserCallCount.value)\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#isolated-fakes-per-test","title":"Isolated Fakes Per Test","text":"<p>Create fresh fakes for each test to avoid shared state:</p> <pre><code>class UserServiceTest {\n    @Test\n    fun `test case 1`() {\n        val fake = fakeRepository { /* config */ }\n        // Test with this fake\n    }\n\n    @Test\n    fun `test case 2`() {\n        val fake = fakeRepository { /* different config */ }\n        // Fresh, independent fake\n    }\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#verify-behavior-not-implementation","title":"Verify Behavior, Not Implementation","text":"<p>Use call counters to verify interactions:</p> <pre><code>@Test\nfun `GIVEN service WHEN processing user THEN calls repository once`() {\n    val fakeRepo = fakeRepository()\n    val service = UserService(fakeRepo)\n\n    service.processUser(\"123\")\n\n    assertEquals(1, fakeRepo.getUserCallCount.value)\n    assertEquals(1, fakeRepo.saveUserCallCount.value)\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#test-edge-cases","title":"Test Edge Cases","text":"<p>Configure fakes to test error handling:</p> <pre><code>@Test\nfun `GIVEN repository failure WHEN saving user THEN handles error`() = runTest {\n    val fake = fakeRepository {\n        saveUser { user -&gt;\n            Result.failure(NetworkException())\n        }\n    }\n    val service = UserService(fake)\n\n    val result = service.createUser(\"Alice\")\n\n    assertTrue(result.isFailure)\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#use-turbine-for-reactive-testing","title":"Use Turbine for Reactive Testing","text":"<p>Test StateFlow call counters reactively:</p> <pre><code>@Test\nfun `GIVEN fake WHEN calling repeatedly THEN emits counts`() = runTest {\n    val fake = fakeAnalytics()\n\n    fake.trackCallCount.test {\n        assertEquals(0, awaitItem())\n\n        fake.track(\"event1\")\n        assertEquals(1, awaitItem())\n\n        fake.track(\"event2\")\n        assertEquals(2, awaitItem())\n    }\n}\n</code></pre>"},{"location":"guides/testing-patterns.html#next-steps","title":"Next Steps","text":"<ul> <li>Migration Guide - From MockK/Mockito</li> <li>Performance - Build time impact</li> </ul>"},{"location":"introduction/features.html","title":"Features","text":"<p>Comprehensive overview of what Fakt supports and how it works.</p>"},{"location":"introduction/features.html#supported-class-types","title":"Supported Class Types","text":"<p>Fakt can generate fakes for these Kotlin types:</p>"},{"location":"introduction/features.html#interfaces","title":"\u2705 Interfaces","text":"<p>The primary use case\u2014clean contracts without implementation:</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): User\n    fun deleteUser(id: String): Boolean\n}\n</code></pre>"},{"location":"introduction/features.html#abstract-classes","title":"\u2705 Abstract Classes","text":"<p>Abstract classes with abstract members:</p> <pre><code>@Fake\nabstract class BaseService {\n    abstract fun start(): Boolean\n    abstract val isRunning: Boolean\n}\n</code></pre>"},{"location":"introduction/features.html#open-classes","title":"\u2705 Open Classes","text":"<p>Open classes with overridable members (only overridable members are faked):</p> <pre><code>@Fake\nopen class NetworkClient {\n    open suspend fun fetch(url: String): Result&lt;String&gt; =\n        Result.failure(NotImplementedError())\n}\n</code></pre>"},{"location":"introduction/features.html#data-classes","title":"\u274c Data Classes","text":"<p>Data classes have compiler-generated implementations and can\u2019t be faked. Use builders or <code>copy()</code> instead.</p> <p>Works as parameter/return types:</p> <pre><code>data class User(val id: String, val name: String)\n\n@Fake  // \u2705 This works\ninterface UserRepository {\n    fun getUser(id: String): User  // \u2705 Data class as return type\n}\n</code></pre>"},{"location":"introduction/features.html#sealed-classesinterfaces","title":"\u274c Sealed Classes/Interfaces","text":"<p>Sealed hierarchies can\u2019t be faked directly. Use exhaustive when-expressions or visitor patterns.</p> <p>Works as parameter/return types:</p> <pre><code>sealed interface Result&lt;out T&gt;\ndata class Success&lt;T&gt;(val value: T) : Result&lt;T&gt;\ndata class Failure(val error: Throwable) : Result&lt;Nothing&gt;\n\n@Fake  // \u2705 This works\ninterface Repository {\n    fun save(data: String): Result&lt;Unit&gt;  // \u2705 Sealed class as return type\n}\n</code></pre>"},{"location":"introduction/features.html#type-system-support","title":"Type System Support","text":""},{"location":"introduction/features.html#generics","title":"\u2705 Generics","text":"<p>Full generic support with smart defaults:</p> <p>Class-level generics:</p> <pre><code>@Fake\ninterface Repository&lt;T&gt; {\n    fun save(item: T): Result&lt;Unit&gt;\n    fun getAll(): List&lt;T&gt;\n}\n\nval fake = fakeRepository&lt;User&gt; {\n    save { item -&gt; Result.success(Unit) }\n    getAll { emptyList() }\n}\n</code></pre> <p>Method-level generics:</p> <pre><code>@Fake\ninterface Transformer {\n    fun &lt;T, R&gt; transform(input: T, mapper: (T) -&gt; R): R\n}\n\nval fake = fakeTransformer {\n    transform { input, mapper -&gt; mapper(input) }  // Identity function default\n}\n</code></pre> <p>Generic constraints:</p> <pre><code>@Fake\ninterface ComparableRepository&lt;T : Comparable&lt;T&gt;&gt; {\n    fun findMax(items: List&lt;T&gt;): T?\n}\n\nval fake = fakeComparableRepository&lt;Int&gt; {\n    findMax { items -&gt; items.maxOrNull() }\n}\n</code></pre> <p>Variance:</p> <pre><code>@Fake\ninterface Producer&lt;out T&gt; {\n    fun produce(): T\n}\n\n@Fake\ninterface Consumer&lt;in T&gt; {\n    fun consume(item: T)\n}\n</code></pre>"},{"location":"introduction/features.html#nullable-types","title":"\u2705 Nullable Types","text":"<p>Full support for nullable types with <code>null</code> defaults:</p> <pre><code>@Fake\ninterface UserService {\n    fun findUser(id: String): User?\n    suspend fun getCurrentUser(): User?\n}\n\nval fake = fakeUserService {\n    findUser { id -&gt; null }  // Default: null\n    getCurrentUser { User(\"123\", \"Alice\") }\n}\n</code></pre>"},{"location":"introduction/features.html#complex-standard-library-types","title":"\u2705 Complex Standard Library Types","text":"<p>Fakt handles common stdlib types with smart defaults:</p> Type Default Behavior <code>Result&lt;T&gt;</code> <code>Result.failure(NotImplementedError())</code> <code>List&lt;T&gt;</code> <code>emptyList()</code> <code>Set&lt;T&gt;</code> <code>emptySet()</code> <code>Map&lt;K, V&gt;</code> <code>emptyMap()</code> <code>Sequence&lt;T&gt;</code> <code>emptySequence()</code> <code>Array&lt;T&gt;</code> <code>emptyArray()</code> <code>Pair&lt;A, B&gt;</code> <code>Pair(defaultA, defaultB)</code> <code>Triple&lt;A, B, C&gt;</code> <code>Triple(defaultA, defaultB, defaultC)</code> <p>Example:</p> <pre><code>@Fake\ninterface DataRepository {\n    suspend fun fetchItems(): Result&lt;List&lt;Item&gt;&gt;\n    fun getCache(): Map&lt;String, Item&gt;\n}\n\nval fake = fakeDataRepository {\n    fetchItems { Result.success(listOf(Item(\"test\"))) }\n    getCache { emptyMap() }  // Default\n}\n</code></pre>"},{"location":"introduction/features.html#kotlin-language-features","title":"Kotlin Language Features","text":""},{"location":"introduction/features.html#suspend-functions","title":"\u2705 Suspend Functions","text":"<p>Full coroutine support\u2014no weird <code>runBlocking</code> wrappers:</p> <pre><code>@Fake\ninterface ApiClient {\n    suspend fun login(username: String, password: String): Result&lt;Token&gt;\n    suspend fun fetchData(): List&lt;Data&gt;\n}\n\nval fake = fakeApiClient {\n    login { username, password -&gt;\n        delay(100)  // Suspends correctly\n        Result.success(Token(\"fake-token\"))\n    }\n    fetchData {\n        delay(50)\n        emptyList()\n    }\n}\n\n// Use in tests\nrunTest {\n    val result = fake.login(\"alice\", \"pass123\")\n    assertTrue(result.isSuccess)\n}\n</code></pre>"},{"location":"introduction/features.html#properties","title":"\u2705 Properties","text":"<p>Both read-only (<code>val</code>) and mutable (<code>var</code>) properties:</p> <p>Read-only properties:</p> <pre><code>@Fake\ninterface Config {\n    val apiUrl: String\n    val timeout: Int\n}\n\nval fake = fakeConfig {\n    apiUrl { \"https://api.example.com\" }\n    timeout { 30 }\n}\n\nassertEquals(\"https://api.example.com\", fake.apiUrl)\nassertEquals(1, fake.apiUrlCallCount.value)  // Call tracking\n</code></pre> <p>Mutable properties:</p> <pre><code>@Fake\ninterface Settings {\n    var theme: String\n    var fontSize: Int\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n    fontSize { 14 }\n}\n\n// Getter tracking\nassertEquals(\"dark\", fake.theme)\nassertEquals(1, fake.getThemeCallCount.value)\n\n// Setter tracking\nfake.theme = \"light\"\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"introduction/features.html#default-parameters","title":"\u2705 Default Parameters","text":"<p>Methods with default parameters are supported (defaults are ignored):</p> <pre><code>@Fake\ninterface Logger {\n    fun log(message: String, level: LogLevel = LogLevel.INFO)\n}\n\nval fake = fakeLogger {\n    log { message, level -&gt;\n        println(\"[$level] $message\")\n    }\n}\n\nfake.log(\"Error occurred\", LogLevel.ERROR)\nfake.log(\"Info message\")  // Uses interface's default\n</code></pre>"},{"location":"introduction/features.html#inheritance","title":"\u2705 Inheritance","text":"<p>Fakt handles inheritance correctly:</p> <pre><code>interface BaseRepository {\n    fun getId(): String\n}\n\n@Fake\ninterface UserRepository : BaseRepository {\n    suspend fun getUser(id: String): User\n}\n\nval fake = fakeUserRepository {\n    getId { \"repo-123\" }  // Inherited method\n    getUser { id -&gt; User(id, \"Alice\") }\n}\n</code></pre>"},{"location":"introduction/features.html#call-tracking","title":"Call Tracking","text":""},{"location":"introduction/features.html#built-in-stateflow-counters","title":"Built-In StateFlow Counters","text":"<p>Every method and property gets automatic call tracking:</p> <pre><code>@Fake\ninterface Analytics {\n    fun track(event: String)\n    suspend fun identify(userId: String)\n    val sessionId: String\n}\n\nval fake = fakeAnalytics {\n    track { event -&gt; println(event) }\n    identify { userId -&gt; }\n    sessionId { \"session-123\" }\n}\n\nfake.track(\"event1\")\nfake.track(\"event2\")\n\n// Thread-safe call counting\nassertEquals(2, fake.trackCallCount.value)\nassertEquals(0, fake.identifyCallCount.value)\n\n// Property tracking\nval id = fake.sessionId\nassertEquals(1, fake.sessionIdCallCount.value)\n</code></pre>"},{"location":"introduction/features.html#reactive-testing","title":"Reactive Testing","text":"<p>StateFlow counters work with Kotlin Flow test utilities:</p> <pre><code>import app.cash.turbine.test\n\n@Test\nfun `GIVEN fake WHEN calling method THEN counter updates reactively`() = runTest {\n    val fake = fakeRepository()\n\n    fake.getUserCallCount.test {\n        assertEquals(0, awaitItem())\n\n        fake.getUser(\"123\")\n        assertEquals(1, awaitItem())\n\n        fake.getUser(\"456\")\n        assertEquals(2, awaitItem())\n    }\n}\n</code></pre>"},{"location":"introduction/features.html#code-generation-patterns","title":"Code Generation Patterns","text":""},{"location":"introduction/features.html#smart-default-behaviors","title":"Smart Default Behaviors","text":"<p>Fakt generates sensible defaults based on return type:</p> Return Type Generated Default <code>Unit</code> <code>{ }</code> <code>Boolean</code> <code>{ false }</code> <code>Int</code>, <code>Long</code>, etc. <code>{ 0 }</code> <code>Double</code>, <code>Float</code> <code>{ 0.0 }</code> <code>String</code> <code>{ \"\" }</code> <code>List&lt;T&gt;</code> <code>{ emptyList() }</code> <code>T?</code> (nullable) <code>{ null }</code> <code>T -&gt; T</code> (identity) <code>{ it }</code> <code>Result&lt;T&gt;</code> <code>{ Result.failure(NotImplementedError)}</code>"},{"location":"introduction/features.html#configuration-dsl","title":"Configuration DSL","text":"<p>Every fake gets a type-safe DSL for configuration:</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n    suspend fun saveUser(user: User): Result&lt;Unit&gt;\n}\n\n// Generated DSL\nval fake = fakeUserRepository {\n    getUser { id -&gt;  // Type-safe lambda\n        Result.success(User(id, \"Alice\"))\n    }\n    saveUser { user -&gt;  // Compiler knows parameter types\n        Result.success(Unit)\n    }\n}\n</code></pre>"},{"location":"introduction/features.html#factory-functions","title":"Factory Functions","text":"<p>Generated factory functions follow Kotlin conventions:</p> <pre><code>// For interface UserRepository:\nfun fakeUserRepository(\n    configure: FakeUserRepositoryConfig.() -&gt; Unit = {}\n): FakeUserRepositoryImpl\n\n// For interface ApiClient:\nfun fakeApiClient(\n    configure: FakeApiClientConfig.() -&gt; Unit = {}\n): FakeApiClientImpl\n</code></pre> <p>Naming: <code>fake{InterfaceName}</code> (camelCase from interface name)</p>"},{"location":"introduction/features.html#multi-module-support-experimental","title":"Multi-Module Support (Experimental)","text":"<p>Cross-module fake consumption via dedicated <code>-fakes</code> modules:</p> <pre><code>// Producer module: :core:analytics\n@Fake\ninterface Analytics\n\n// Collector module: :core:analytics-fakes\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\n// Consumer module: :app\ndependencies {\n    commonTest {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre> <p>For complete documentation, see Multi-Module Overview.</p>"},{"location":"introduction/features.html#performance-features","title":"Performance Features","text":""},{"location":"introduction/features.html#intelligent-caching","title":"Intelligent Caching","text":"<p>Fakt caches generated code across KMP targets:</p> <ul> <li>First target: Full generation (~40ms for 100 interfaces)</li> <li>Subsequent targets: Cache hits (~1ms each)</li> </ul>"},{"location":"introduction/features.html#telemetry-configuration","title":"Telemetry Configuration","text":"<p>Four log levels for debugging and performance analysis:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.LogLevel\n\nfakt {\n    logLevel.set(LogLevel.INFO)   // Default: concise summary\n    // LogLevel.QUIET  - Zero output (CI/CD)\n    // LogLevel.DEBUG  - Detailed breakdown with FIR + IR details\n}\n</code></pre> <p>See Performance Guide for benchmarks.</p>"},{"location":"introduction/features.html#platform-support","title":"Platform Support","text":"<p>Works on ALL Kotlin Multiplatform targets:</p> <ul> <li>\u2705 JVM, Android</li> <li>\u2705 iOS (arm64, x64, simulator)</li> <li>\u2705 macOS, Linux, Windows</li> <li>\u2705 JavaScript (IR), WebAssembly</li> <li>\u2705 watchOS, tvOS</li> </ul> <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p>"},{"location":"introduction/features.html#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Get started with fakes</li> <li>Suspend Functions - Async patterns</li> <li>Generics - Generic type handling</li> <li>Call Tracking - StateFlow counters</li> </ul>"},{"location":"introduction/installation.html","title":"Installation","text":"<p>Add Fakt to your Kotlin project in minutes. Works with both multiplatform and single-platform projects.</p>"},{"location":"introduction/installation.html#gradle-plugin-recommended","title":"Gradle Plugin (Recommended)","text":""},{"location":"introduction/installation.html#version-catalog","title":"Version Catalog","text":"<p><code>gradle/libs.versions.toml</code>:</p> <pre><code>[versions]\nfakt = \"1.0.0-SNAPSHOT\"\nkotlin = \"2.2.20\"\n\n[plugins]\nkotlin-multiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nfakt = { id = \"com.rsicarelli.fakt\", version.ref = \"fakt\" }\n\n[libraries]\nfakt-runtime = { module = \"com.rsicarelli.fakt:runtime\", version.ref = \"fakt\" }\n</code></pre>"},{"location":"introduction/installation.html#root-build-file","title":"Root Build File","text":"<p>Root <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform) apply false\n    alias(libs.plugins.fakt) apply false\n}\n</code></pre>"},{"location":"introduction/installation.html#module-build-file","title":"Module Build File","text":"<p>Module <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\nkotlin {\n    // Your KMP targets\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain.dependencies {\n            implementation(libs.fakt.runtime)\n        }\n    }\n}\n</code></pre> <p>\u2026and that\u2019s it!</p>"},{"location":"introduction/installation.html#single-platform-projects","title":"Single-Platform Projects","text":"<p>Fakt works with single-platform Kotlin projects too:</p>"},{"location":"introduction/installation.html#jvm-only","title":"JVM-Only","text":"<pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\ndependencies {\n    implementation(libs.fakt.runtime)\n}\n</code></pre>"},{"location":"introduction/installation.html#android-only","title":"Android-Only","text":"<pre><code>plugins {\n    id(\"com.android.library\")\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\ndependencies {\n    implementation(libs.fakt.runtime)\n}\n</code></pre>"},{"location":"introduction/installation.html#requirements","title":"Requirements","text":"Requirement Version Kotlin 2.2.20+ Gradle 8.0+ JVM 11+"},{"location":"introduction/installation.html#ide-support","title":"IDE Support","text":"<p>Fakt-generated code appears in <code>build/generated/fakt/</code> and is automatically indexed by IntelliJ IDEA and Android Studio.</p> <p>K2 IDE Mode</p> <p>Enable K2 mode for better autocomplete of generated factories:</p> <p>Settings \u2192 Languages &amp; Frameworks \u2192 Kotlin \u2192 Enable K2 mode</p>"},{"location":"introduction/installation.html#kotlin-version-compatibility","title":"Kotlin Version Compatibility","text":"Fakt Version Kotlin Version Support 1.0.0-SNAPSHOT 2.2.20 - 2.2.30 <p>Fakt follows forward compatibility on a best-effort basis (usually N+.2 minor versions).</p>"},{"location":"introduction/installation.html#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Your first fake in 5 minutes</li> <li>Features - What Fakt supports</li> <li>Configuration - Plugin options</li> </ul>"},{"location":"introduction/overview.html","title":"Overview","text":"<p>Fakt is a Kotlin compiler plugin that eliminates the boilerplate of writing test fakes by generating them at compile-time.</p>"},{"location":"introduction/overview.html#the-problem","title":"The Problem","text":"<p>Writing test fakes manually is tedious and error-prone. A simple interface requires ~50 lines of boilerplate:</p> <pre><code>interface AnalyticsService {\n    fun track(event: String)\n}\n\n// Manual fake: repetitive boilerplate\nclass FakeAnalyticsService : AnalyticsService {\n    private var trackBehavior: ((String) -&gt; Unit)? = null\n    private var _trackCallCount = 0\n    val trackCallCount: Int get() = _trackCallCount\n\n    override fun track(event: String) {\n        _trackCallCount++\n        trackBehavior?.invoke(event) ?: Unit\n    }\n\n    fun configureTrack(behavior: (String) -&gt; Unit) {\n        trackBehavior = behavior\n    }\n}\n\n// Manual configuration (no DSL)\nval fake = FakeAnalyticsService().apply {\n    configureTrack { event -&gt; println(\"Tracked: $event\") }\n}\n</code></pre> <p>Issues with manual fakes:</p> <ul> <li>Repetitive boilerplate for every interface</li> <li>Non-thread-safe call tracking (<code>var count = 0</code>)</li> <li>Silent refactoring failures (interface changes don\u2019t break tests)</li> <li>Maintenance burden scales with codebase</li> </ul>"},{"location":"introduction/overview.html#the-solution","title":"The Solution","text":"<p>Add <code>@Fake</code> annotation. Fakt generates everything automatically:</p> <pre><code>@Fake\ninterface AnalyticsService {\n    fun track(event: String)\n}\n\n// Generated factory + DSL (zero boilerplate)\nval fake = fakeAnalyticsService {\n    track { event -&gt; println(\"Tracked: $event\") }\n}\n\nfake.track(\"user_signup\")\nassertEquals(1, fake.trackCallCount.value)\n</code></pre> <p>What Fakt generates:</p> <ol> <li>Implementation class with thread-safe StateFlow call tracking</li> <li>Factory function with clean DSL (<code>fakeXxx {}</code>)</li> <li>Configuration DSL for behavior setup</li> </ol>"},{"location":"introduction/overview.html#architecture-two-phase-fir-ir-compilation","title":"Architecture: Two-Phase FIR \u2192 IR Compilation","text":"<p>Fakt uses a two-phase compilation architecture inspired by production compiler plugins like Metro:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1: FIR (Frontend Intermediate Representation)           \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Detects @Fake annotations on interfaces                     \u2502\n\u2502  \u2022 Validates interface structure                               \u2502\n\u2502  \u2022 Passes validated interfaces to IR phase                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 2: IR (Intermediate Representation)                     \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Analyzes interface metadata (methods, properties, types)    \u2502\n\u2502  \u2022 Generates IR nodes (implementation + factory + DSL)         \u2502\n\u2502  \u2022 Outputs Kotlin code in test source sets                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  OUTPUT: Generated Kotlin Code (test source sets only)         \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 FakeXxxImpl.kt         - Fake implementation class          \u2502\n\u2502  \u2022 fakeXxx() factory      - Type-safe factory function         \u2502\n\u2502  \u2022 FakeXxxConfig          - Configuration DSL                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"introduction/overview.html#why-ir-level-generation","title":"Why IR-Level Generation?","text":"<p>Fakt generates code at the Intermediate Representation (IR) level, not text-based generation:</p> <p>\u2705 Full type system access - Proper generic handling (constraints, variance, bounds) - Correct type resolution across modules - Type-safe code generation</p> <p>\u2705 Performance - Faster than KSP or annotation processors - Works with Kotlin\u2019s incremental compilation - Intelligent caching across KMP targets</p> <p>\u2705 Future-proof - Aligned with Kotlin compiler evolution - Compatible with K2 compiler - Industry-standard approach (Metro, Room, etc.)</p>"},{"location":"introduction/overview.html#generated-code-example","title":"Generated Code Example","text":"<p>For this interface:</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n    val currentUser: User?\n}\n</code></pre> <p>Fakt generates:</p> <pre><code>class FakeUserRepositoryImpl : UserRepository {\n    // Thread-safe StateFlow call tracking\n    private val _getUserCallCount = MutableStateFlow(0)\n    val getUserCallCount: StateFlow&lt;Int&gt; get() = _getUserCallCount\n\n    private val _currentUserCallCount = MutableStateFlow(0)\n    val currentUserCallCount: StateFlow&lt;Int&gt; get() = _currentUserCallCount\n\n    // Smart default behaviors\n    private var getUserBehavior: suspend (String) -&gt; Result&lt;User&gt; = {\n        Result.failure(NotImplementedError(\"getUser not configured\"))\n    }\n    private var currentUserBehavior: () -&gt; User? = { null }\n\n    override suspend fun getUser(id: String): Result&lt;User&gt; {\n        _getUserCallCount.update { it + 1 }\n        return getUserBehavior(id)\n    }\n\n    override val currentUser: User?\n        get() {\n            _currentUserCallCount.update { it + 1 }\n            return currentUserBehavior()\n        }\n\n    // Internal configuration methods\n    internal fun configureGetUser(behavior: suspend (String) -&gt; Result&lt;User&gt;) {\n        getUserBehavior = behavior\n    }\n\n    internal fun configureCurrentUser(behavior: () -&gt; User?) {\n        currentUserBehavior = behavior\n    }\n}\n\n// Factory function\nfun fakeUserRepository(\n    configure: FakeUserRepositoryConfig.() -&gt; Unit = {}\n): FakeUserRepositoryImpl = FakeUserRepositoryImpl().apply {\n    FakeUserRepositoryConfig(this).configure()\n}\n\n// Configuration DSL\nclass FakeUserRepositoryConfig(private val fake: FakeUserRepositoryImpl) {\n    fun getUser(behavior: suspend (String) -&gt; Result&lt;User&gt;) {\n        fake.configureGetUser(behavior)\n    }\n\n    fun currentUser(behavior: () -&gt; User?) {\n        fake.configureCurrentUser(behavior)\n    }\n}\n</code></pre>"},{"location":"introduction/overview.html#key-technical-achievements","title":"Key Technical Achievements","text":""},{"location":"introduction/overview.html#universal-kmp-support","title":"\u2705 Universal KMP Support","text":"<p>Fakt works on ALL Kotlin Multiplatform targets without reflection:</p> <ul> <li>JVM, Android, iOS, Native, JavaScript, WebAssembly</li> <li>No platform-specific dependencies</li> <li>Same API across all targets</li> </ul>"},{"location":"introduction/overview.html#zero-production-overhead","title":"\u2705 Zero Production Overhead","text":"<ul> <li>Zero runtime dependencies (annotation is BINARY retention only)</li> <li>Test-only generation (never appears in production builds)</li> <li>No reflection (works on Native/WASM)</li> </ul>"},{"location":"introduction/overview.html#built-in-stateflow-call-tracking","title":"\u2705 Built-In StateFlow Call Tracking","text":"<p>Thread-safe, reactive call counting out of the box:</p> <pre><code>val fake = fakeRepository()\nfake.getUser(\"123\")\n\n// Thread-safe\nassertEquals(1, fake.getUserCallCount.value)\n\n// Reactive (works with Flow test utilities)\nfake.getUserCallCount.test {\n    fake.getUser(\"456\")\n    assertEquals(2, awaitItem())\n}\n</code></pre>"},{"location":"introduction/overview.html#smart-defaults","title":"\u2705 Smart Defaults","text":"<p>Fakt generates sensible default behaviors:</p> Type Default Behavior <code>Unit</code> <code>{ }</code> <code>Boolean</code> <code>{ false }</code> <code>Int</code>, <code>Long</code>, etc. <code>{ 0 }</code> <code>String</code> <code>{ \"\" }</code> <code>List&lt;T&gt;</code> <code>{ emptyList() }</code> <code>Result&lt;T&gt;</code> <code>{ Result.failure(NotImplementedError)}</code> Generic <code>T -&gt; T</code> <code>{ it }</code> (identity function) Nullable <code>T?</code> <code>{ null }</code>"},{"location":"introduction/overview.html#what-fakt-supports","title":"What Fakt Supports","text":"<p>Class Types: - \u2705 Interfaces - \u2705 Abstract classes - \u2705 Open classes (overridable members only)</p> <p>Type System: - \u2705 Full generics (class-level, method-level, constraints, variance) - \u2705 Nullable types - \u2705 Complex stdlib types (<code>Result&lt;T&gt;</code>, <code>List&lt;T&gt;</code>, etc.)</p> <p>Kotlin Features: - \u2705 Suspend functions - \u2705 Properties (<code>val</code>, <code>var</code>) - \u2705 Methods with parameters - \u2705 Inheritance</p>"},{"location":"introduction/overview.html#current-limitations","title":"Current Limitations","text":"<p>Fakt is honest about what it doesn\u2019t support (yet):</p> <ul> <li>\u274c Data classes as <code>@Fake</code> targets (work fine as parameter/return types)</li> <li>\u274c Sealed hierarchies as <code>@Fake</code> targets</li> <li>\u274c Default parameters in interface methods</li> </ul> <p>See Limitations for details and workarounds.</p>"},{"location":"introduction/overview.html#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Add Fakt to your project</li> <li>Quick Start - Your first fake in 5 minutes</li> <li>Features - Detailed feature breakdown</li> </ul>"},{"location":"introduction/quick-start.html","title":"Quick Start","text":"<p>Get your first Fakt fake running in 5 minutes.</p>"},{"location":"introduction/quick-start.html#step-1-annotate-an-interface","title":"Step 1: Annotate an Interface","text":"<p>Create an interface and mark it with <code>@Fake</code>:</p> <pre><code>// src/commonMain/kotlin/com/example/Analytics.kt\npackage com.example\n\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n}\n</code></pre>"},{"location":"introduction/quick-start.html#step-2-build-your-project","title":"Step 2: Build Your Project","text":"<p>Run Gradle build to generate the fake:</p> <pre><code>./gradlew build\n</code></pre> <p>Fakt generates <code>FakeAnalyticsImpl</code> in <code>build/generated/fakt/commonTest/kotlin/com/example/</code>.</p>"},{"location":"introduction/quick-start.html#step-3-use-in-tests","title":"Step 3: Use in Tests","text":"<p>The generated fake includes a factory function and DSL:</p> <pre><code>// src/commonTest/kotlin/com/example/AnalyticsTest.kt\npackage com.example\n\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AnalyticsTest {\n    @Test\n    fun `GIVEN configured fake WHEN tracking event THEN captures call`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val fake = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n        }\n\n        fake.track(\"user_signup\")\n\n        assertEquals(listOf(\"user_signup\"), events)\n        assertEquals(1, fake.trackCallCount.value)\n    }\n}\n</code></pre>"},{"location":"introduction/quick-start.html#what-just-happened","title":"What Just Happened?","text":"<p>Fakt generated three things for you:</p>"},{"location":"introduction/quick-start.html#1-implementation-class","title":"1. Implementation Class","text":"<pre><code>class FakeAnalyticsImpl : Analytics {\n    private var trackBehavior: (String) -&gt; Unit = { }\n    private val _trackCallCount = MutableStateFlow(0)\n    val trackCallCount: StateFlow&lt;Int&gt; get() = _trackCallCount\n\n    override fun track(event: String) {\n        _trackCallCount.update { it + 1 }\n        trackBehavior(event)\n    }\n\n    internal fun configureTrack(behavior: (String) -&gt; Unit) {\n        trackBehavior = behavior\n    }\n}\n</code></pre>"},{"location":"introduction/quick-start.html#2-factory-function","title":"2. Factory Function","text":"<pre><code>fun fakeAnalytics(\n    configure: FakeAnalyticsConfig.() -&gt; Unit = {}\n): FakeAnalyticsImpl = FakeAnalyticsImpl().apply {\n    FakeAnalyticsConfig(this).configure()\n}\n</code></pre>"},{"location":"introduction/quick-start.html#3-configuration-dsl","title":"3. Configuration DSL","text":"<pre><code>class FakeAnalyticsConfig(private val fake: FakeAnalyticsImpl) {\n    fun track(behavior: (String) -&gt; Unit) {\n        fake.configureTrack(behavior)\n    }\n}\n</code></pre>"},{"location":"introduction/quick-start.html#generated-code-location","title":"Generated Code Location","text":"<p>Fakt generates code in test source sets:</p> Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code> <code>androidUnitTest/</code> <code>build/generated/fakt/androidUnitTest/kotlin/</code> <p>Note</p> <p>Generated code never appears in production builds. Fakt is test-only.</p>"},{"location":"introduction/quick-start.html#more-complex-example","title":"More Complex Example","text":"<p>Here\u2019s a more realistic interface with suspend functions and generics:</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n    suspend fun saveUser(user: User): Result&lt;Unit&gt;\n    val currentUser: User?\n}\n</code></pre> <p>Using it in tests:</p> <pre><code>import kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertTrue\n\nclass UserRepositoryTest {\n    @Test\n    fun `GIVEN fake repository WHEN saving user THEN returns success`() = runTest {\n        val savedUsers = mutableListOf&lt;User&gt;()\n\n        val fake = fakeUserRepository {\n            saveUser { user -&gt;\n                savedUsers.add(user)\n                Result.success(Unit)\n            }\n            getUser { id -&gt;\n                Result.success(User(id, \"Alice\"))\n            }\n            currentUser { User(\"123\", \"Bob\") }\n        }\n\n        val result = fake.saveUser(User(\"456\", \"Charlie\"))\n\n        assertTrue(result.isSuccess)\n        assertEquals(1, savedUsers.size)\n        assertEquals(\"Charlie\", savedUsers.first().name)\n        assertEquals(1, fake.saveUserCallCount.value)\n    }\n}\n</code></pre>"},{"location":"introduction/quick-start.html#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - More examples</li> <li>Suspend Functions - Async support</li> <li>Call Tracking - StateFlow patterns</li> <li>Testing Patterns - Best practices</li> </ul>"},{"location":"introduction/why-fakt.html","title":"Why Fakt?","text":"<p>The story behind building a compile-time fake generator for Kotlin testing.</p>"},{"location":"introduction/why-fakt.html#the-problem-manual-fakes-are-tedious-mocks-are-costly","title":"The Problem: Manual Fakes Are Tedious, Mocks Are Costly","text":"<p>Modern Kotlin development faces a testing dilemma. Writing test doubles (fakes, mocks, stubs) manually is time-consuming and error-prone. Runtime mocking frameworks solve the boilerplate problem but introduce severe performance penalties and architectural limitations. Fakt was created to address both challenges.</p>"},{"location":"introduction/why-fakt.html#the-manual-fake-burden","title":"The Manual Fake Burden","text":"<p>Consider a simple interface requiring a test double:</p> <pre><code>interface AnalyticsService {\n    fun track(event: String)\n    suspend fun flush(): Result&lt;Unit&gt;\n}\n</code></pre> <p>A proper, production-quality fake requires ~60-80 lines of boilerplate:</p> <pre><code>class FakeAnalyticsService : AnalyticsService {\n    // Behavior configuration\n    private var trackBehavior: ((String) -&gt; Unit)? = null\n    private var flushBehavior: (suspend () -&gt; Result&lt;Unit&gt;)? = null\n\n    // Call tracking (non-thread-safe!)\n    private var _trackCallCount = 0\n    val trackCallCount: Int get() = _trackCallCount\n\n    private var _flushCallCount = 0\n    val flushCallCount: Int get() = _flushCallCount\n\n    // Interface implementation\n    override fun track(event: String) {\n        _trackCallCount++\n        trackBehavior?.invoke(event) ?: Unit\n    }\n\n    override suspend fun flush(): Result&lt;Unit&gt; {\n        _flushCallCount++\n        return flushBehavior?.invoke() ?: Result.success(Unit)\n    }\n\n    // Configuration methods\n    fun configureTrack(behavior: (String) -&gt; Unit) {\n        trackBehavior = behavior\n    }\n\n    fun configureFlush(behavior: suspend () -&gt; Result&lt;Unit&gt;) {\n        flushBehavior = behavior\n    }\n}\n</code></pre> <p>Critical issues: - Non-thread-safe call tracking (<code>var count = 0</code>) breaks under concurrent tests - Maintenance burden scales with interface complexity (N methods = ~30N lines) - Silent refactoring failures (interface signature changes don\u2019t break unused fakes) - Copy-paste errors accumulate across dozens of fakes</p> <p>For a codebase with 50+ interfaces requiring fakes, this represents thousands of lines of brittle, repetitive boilerplate.</p>"},{"location":"introduction/why-fakt.html#the-runtime-mocking-crisis-two-independent-failures","title":"The Runtime Mocking Crisis: Two Independent Failures","text":"<p>Runtime mocking frameworks (MockK, Mockito) solve the boilerplate problem through reflection and bytecode instrumentation. However, this \u201cmagic\u201d approach faces two critical, independent failures that make it unsustainable for modern Kotlin development.</p>"},{"location":"introduction/why-fakt.html#failure-1-the-jvm-mock-tax-performance-crisis","title":"Failure 1: The JVM \u201cMock Tax\u201d (Performance Crisis)","text":"<p>Kotlin\u2019s design\u2014final classes by default\u2014creates a fundamental conflict with Java-based mocking tools. Mockito was built for a world where Java classes are <code>open</code> by default, allowing runtime subclassing. Kotlin\u2019s <code>final</code> classes block this mechanism.</p>"},{"location":"introduction/why-fakt.html#the-four-bad-workarounds","title":"The Four Bad Workarounds","text":"<p>Kotlin developers are forced to choose between four sub-optimal solutions:</p> <ol> <li>Manual <code>open</code> keyword - Pollutes production code with test-only concerns</li> <li><code>all-open</code> compiler plugin - Compromises Kotlin\u2019s safety guarantees</li> <li>Mockito\u2019s <code>mock-maker-inline</code> - Uses bytecode instrumentation (slow)</li> <li>MockK\u2019s default behavior - Bundles instrumentation by default (hidden cost)</li> </ol>"},{"location":"introduction/why-fakt.html#verified-performance-penalties","title":"Verified Performance Penalties","text":"<p>Independent benchmarks<sup>1</sup> quantify the \u201cMock Tax\u201d\u2014severe performance degradation when mocking idiomatic Kotlin patterns:</p> Mocking Pattern Framework Comparison Verified Penalty <code>mockkObject</code> (Singletons) MockK vs. Dependency Injection 1,391x slower <code>mockkStatic</code> (Top-level functions) MockK vs. Interface-based DI 146x slower <code>verify { ... }</code> (Interaction verification) MockK vs. State-based testing 47x slower <code>relaxed</code> mocks (Unstubbed calls) MockK vs. Strict mocks 3.7x slower <code>mock-maker-inline</code> Mockito vs. <code>all-open</code> plugin 2.7-3x slower<sup>26</sup><sup>2</sup> <p>Real-world impact: A production test suite with 2,668 tests experienced a 2.7x slowdown (7.3s \u2192 20.0s) when using <code>mock-maker-inline</code> instead of the <code>all-open</code> plugin<sup>2</sup>. For large projects, this \u201cMock Tax\u201d accumulates to 40% slower test suites<sup>1</sup>.</p> <p>The testing framework actively punishes developers for using Kotlin\u2019s most idiomatic features (objects, top-level functions, extension functions).</p>"},{"location":"introduction/why-fakt.html#failure-2-the-kmp-dead-end-architectural-impossibility","title":"Failure 2: The KMP Dead End (Architectural Impossibility)","text":"<p>Kotlin Multiplatform (KMP) has exploded in adoption\u2014Google, Netflix, Cash App, and JetBrains all use it in production. But runtime mocking is fundamentally incompatible with non-JVM targets.</p>"},{"location":"introduction/why-fakt.html#why-runtime-mocking-cannot-work-in-kmp","title":"Why Runtime Mocking Cannot Work in KMP","text":"<p>Runtime mocking relies on JVM-specific features:</p> <ul> <li>Reflection - Inspect and modify code at runtime</li> <li>Bytecode instrumentation - Change class definitions after loading</li> <li>Dynamic proxies - Generate \u201cmagic\u201d classes on the fly</li> </ul> <p>Kotlin/Native (iOS, Desktop) and Kotlin/Wasm compile to native machine code. They have no JVM. Reflection is severely limited<sup>3</sup><sup>4</sup>, bytecode doesn\u2019t exist, and dynamic proxies are impossible.</p> <p>Conclusion: MockK and Mockito cannot run in <code>commonTest</code> source sets targeting Native or Wasm<sup>5</sup><sup>6</sup>. Runtime mocking is a dead end for the entire KMP ecosystem.</p>"},{"location":"introduction/why-fakt.html#the-ksp-workaround-crisis","title":"The KSP \u201cWorkaround\u201d Crisis","text":"<p>The KMP community attempted compile-time code generation via KSP (Kotlin Symbol Processing), creating tools like Mockative, MocKMP, and Mokkery. This ecosystem is in crisis:</p> <p>Kotlin 2.0 Breakage (Verified): - The K2 compiler \u201cfails to handle common metadata tasks properly\u201d in <code>commonTest</code> source sets<sup>7</sup> - Real-world example: StreetComplete app (10,000+ tests) forced to migrate from Mockative to Mokkery due to K2 incompatibility<sup>7</sup> - Mockative maintainer not providing clear K2 migration path<sup>7</sup></p> <p>Feature Limitations: - Mokkery cannot mock: <code>object</code>, <code>sealed</code>, top-level functions, final classes (without <code>all-open</code>)<sup>7</sup> - MocKMP can only mock interfaces, no relaxed mocks<sup>8</sup></p> <p>Strategic failure: The KSP \u201csolutions\u201d cannot even solve the original Kotlin problems (objects, top-level functions) that create JVM performance penalties.</p>"},{"location":"introduction/why-fakt.html#the-philosophical-foundation-why-fakes-reduce-brittleness","title":"The Philosophical Foundation: Why Fakes Reduce Brittleness","text":"<p>Beyond performance, the \u201cfakes over mocks\u201d movement represents a fundamental shift in testing philosophy, rooted in decades of TDD (Test-Driven Development) debate.</p>"},{"location":"introduction/why-fakt.html#state-based-vs-interaction-based-testing","title":"State-Based vs. Interaction-Based Testing","text":"<p>Martin Fowler\u2019s seminal \u201cMocks Aren\u2019t Stubs\u201d<sup>9</sup> describes two testing schools:</p> <p>State-Based Testing (Classic/Detroit School): - Uses fakes and stubs to provide inputs - Verifies the resulting state of the system - Test assertion: \u201cAfter calling <code>saveUser</code>, is the user in the fake repository?\u201d</p> <p>Interaction-Based Testing (London School): - Uses mocks to verify method calls - Verifies how a unit communicates with collaborators - Test assertion: \u201cWas <code>repository.saveUser()</code> called exactly once with the correct user?\u201d</p>"},{"location":"introduction/why-fakt.html#the-refactoring-problem","title":"The Refactoring Problem","text":"<p>Mock-based tests couple to implementation details, not outcomes<sup>10</sup>. Consider this refactoring:</p> <p>Before: <pre><code>// SUT implementation\nfun checkout() {\n    repository.saveOrder(order)\n}\n\n// Mock-based test\nverify { repository.saveOrder(order) }\n</code></pre></p> <p>After (valid refactoring): <pre><code>// SUT implementation\nfun checkout() {\n    repository.saveOrderWithAudit(order, auditLog = true) // New overload\n}\n\n// Mock-based test BREAKS (false negative)\nverify { repository.saveOrder(order) } // \u274c Fails!\n</code></pre></p> <p>The outcome is identical (order is saved), but the process changed. The mock-based test reports a failure even though no bug was introduced. This creates a vicious cycle: brittle tests discourage refactoring, leading to code rot.</p> <p>Google\u2019s \u201cTesting on the Toilet\u201d papers define resilience as a critical test quality: \u201cA test shouldn\u2019t fail if the code under test isn\u2019t defective\u201d<sup>11</sup>. Mock-based tests violate this principle.</p>"},{"location":"introduction/why-fakt.html#the-virtuous-cycle-of-fakes","title":"The Virtuous Cycle of Fakes","text":"<p>Fake-based testing with state verification creates resilient tests:</p> <pre><code>// Fake-based test (survives refactoring)\nval fake = fakeRepository()\nviewModel.checkout()\n\n// Assert the OUTCOME, not the process\nassertEquals(1, fake.orders.size)\nassertTrue(fake.orders.contains(order))\n</code></pre> <p>This test continues passing after the refactoring because it verifies what happened (order was saved), not how it happened (which method was called). Kent Beck observed that mocks \u201cslow down refactoring\u2026 because of the higher coupling between your tests and the actual implementation\u201d<sup>12</sup>.</p>"},{"location":"introduction/why-fakt.html#industry-validation-googles-now-in-android-playbook","title":"Industry Validation: Google\u2019s \u201cNow in Android\u201d Playbook","text":"<p>The \u201cfakes over mocks\u201d philosophy isn\u2019t theoretical\u2014it\u2019s the explicit, documented strategy of Google\u2019s flagship Android reference app.</p>"},{"location":"introduction/why-fakt.html#the-official-directive","title":"The Official Directive","text":"<p>Google\u2019s \u201cNow in Android\u201d (NiA) testing strategy wiki states unambiguously:</p> <p>\u201cDon\u2019t use mocking frameworks. Instead, use fakes.\u201d<sup>14</sup></p> <p>This decision is deliberate. The documentation explains the goal is to create \u201cless brittle tests that may exercise more production code, instead of just verifying specific calls against mocks\u201c<sup>13</sup>.</p>"},{"location":"introduction/why-fakt.html#pattern-1-test-only-hooks","title":"Pattern 1: Test-Only Hooks","text":"<p>NiA uses \u201ctest-only hooks\u201d to control fake behavior<sup>14</sup>:</p> <pre><code>// Production interface\ninterface NewsRepository {\n    fun getNews(): Flow&lt;List&lt;Article&gt;&gt;\n}\n\n// Test repository with hooks\nclass TestNewsRepository : NewsRepository {\n    private val newsFlow = MutableStateFlow&lt;List&lt;Article&gt;&gt;(emptyList())\n\n    // Production method\n    override fun getNews(): Flow&lt;List&lt;Article&gt;&gt; = newsFlow\n\n    // Test-only hook (not in interface)\n    fun sendNews(articles: List&lt;Article&gt;) {\n        newsFlow.value = articles\n    }\n}\n\n// Test usage\n@Test\nfun `GIVEN breaking news WHEN loading THEN displays alert`() = runTest {\n    val fake = TestNewsRepository()\n    val viewModel = NewsViewModel(fake)\n\n    // Use test-only hook to control fake\n    fake.sendNews(listOf(Article(breaking = true)))\n\n    // Assert resulting state\n    assertTrue(viewModel.uiState.value.showAlert)\n}\n</code></pre> <p>This pattern transforms testing from passive \u201csetup-then-verify\u201d (mocks) to active \u201cact-and-assert\u201d (fakes).</p>"},{"location":"introduction/why-fakt.html#pattern-2-high-fidelity-testing","title":"Pattern 2: High-Fidelity Testing","text":"<p>NiA doesn\u2019t fake everything\u2014it uses real implementations when controllable<sup>13</sup>:</p> <ul> <li>DataStore: Uses real <code>DataStore</code> writing to temporary folders wiped after each test</li> <li>Benefit: Tests exercise serialization, error handling, and migration logic</li> </ul> <p>This reveals a mature testing hierarchy: 1. First choice: Real implementation in controlled environment 2. Second choice: Fake for uncontrollable dependencies (network) 3. Last resort (banned): Mocks from frameworks</p>"},{"location":"introduction/why-fakt.html#the-asynchronous-testing-synergy","title":"The Asynchronous Testing Synergy","text":"<p>Kotlin\u2019s modern async stack\u2014<code>runTest</code>, <code>TestDispatcher</code>, and Turbine\u2014is inherently state-based, creating natural synergy with fakes.</p>"},{"location":"introduction/why-fakt.html#official-jetbrains-tooling","title":"Official JetBrains Tooling","text":"<p><code>runTest</code> + <code>TestDispatcher</code><sup>15</sup>: - Official <code>kotlinx-coroutines-test</code> library - Provides <code>TestScope</code> with virtual time control - Best practice: Inject <code>CoroutineDispatcher</code> into ViewModels/Repositories</p> <pre><code>@Test\nfun `GIVEN delay WHEN loading THEN skips virtual time`() = runTest {\n    val fake = fakeRepository()\n    val viewModel = ViewModel(fake, testScheduler) // Inject TestDispatcher\n\n    viewModel.loadData() // Internally: delay(5000)\n\n    // Test completes instantly (virtual time)\n    assertEquals(LoadingState.Success, viewModel.state.value)\n}\n</code></pre>"},{"location":"introduction/why-fakt.html#cash-apps-turbine-de-facto-standard","title":"Cash App\u2019s Turbine (De Facto Standard)","text":"<p>Turbine<sup>16</sup> is the universally adopted library for testing <code>Flow</code>:</p> <pre><code>@Test\nfun `GIVEN repository updates WHEN observing THEN emits new state`() = runTest {\n    val fake = fakeRepository {\n        getUser { User(id = \"123\", name = \"Alice\") }\n    }\n\n    viewModel.userFlow.test {\n        fake.sendUser(User(id = \"123\", name = \"Bob\")) // Test-only hook\n        assertEquals(\"Bob\", awaitItem().name) // State-based assertion\n    }\n}\n</code></pre> <p>Key insight: Turbine\u2019s API (<code>awaitItem()</code>) is designed for state verification, not interaction verification. The most natural way to produce data for Turbine is a fake with <code>MutableStateFlow</code> backing.</p>"},{"location":"introduction/why-fakt.html#the-golden-path","title":"The Golden Path","text":"<p>The modern Kotlin testing stack is: - <code>runTest</code> (virtual time) - Turbine (Flow testing) - Fakes (state-based data sources)</p> <p>This entire ecosystem is state-based by design. Compile-time fake generation completes this stack by automating the \u201chandwritten fake\u201d pattern.</p>"},{"location":"introduction/why-fakt.html#the-solution-compile-time-fake-generation","title":"The Solution: Compile-Time Fake Generation","text":"<p>Fakt solves both the JVM performance crisis and the KMP dead end through deep compiler integration\u2014a FIR \u2192 IR two-phase architecture that succeeds where KSP-based solutions fundamentally fail.</p>"},{"location":"introduction/why-fakt.html#why-ksp-based-solutions-failed","title":"Why KSP-Based Solutions Failed","text":"<p>The KMP testing ecosystem attempted to solve the mocking crisis through KSP (Kotlin Symbol Processing)\u2014a code generation tool that operates at the symbol level. This approach has proven architecturally inadequate.</p> <p>The K2 Compiler Breakage (Verified):</p> <p>Kotlin 2.0\u2019s release broke KSP-based mocking libraries. The K2 compiler \u201cfails to handle common metadata tasks properly\u201d in <code>commonTest</code> source sets<sup>7</sup>, creating a real-world migration crisis:</p> <ul> <li>StreetComplete app (10,000+ tests) forced to migrate from Mockative to Mokkery</li> <li>Mockative maintainer provided no clear K2 migration path</li> <li>Mokkery itself was forced to abandon KSP and build a full compiler plugin just to survive<sup>7</sup></li> </ul> <p>Architectural Limitations:</p> Issue KSP (Symbol-Level) Compiler Plugin (IR-Level) Access Level After type resolution During compilation (FIR/IR) Type System Read-only symbol view Full type manipulation Generic Support Limited (no type substitution) Complete (IrTypeSubstitutor) K2 Stability BROKEN (forced migrations) Stable (official extension points) Cross-Module Fragile (metadata issues) Robust (IR graph traversal) <p>The Verdict: KSP is the wrong tool for production-quality fake generation. A compiler-level solution is the only viable path.</p>"},{"location":"introduction/why-fakt.html#the-mokkery-exception-compiler-plugins-as-the-survivor-architecture","title":"The Mokkery Exception: Compiler Plugins as the Survivor Architecture","text":"<p>While the KSP ecosystem collapsed, one library thrived: Mokkery<sup>17</sup>.</p> <p>Mokkery is a Kotlin/IR compiler plugin\u2014not a KSP processor. This architectural choice proved decisive during the K2 migration. While Mockative and MocKMP struggled with broken <code>commonTest</code> generation, Mokkery\u2019s developer was proactively testing K2 betas in February 2024 and shipped stable K2 support by May 2024<sup>18</sup>.</p> <p>The Real-World Impact:</p> <p>The K2 migration created a forced ecosystem migration. StreetComplete, a popular open-source Android app with 10,000+ tests, had to abandon Mockative for Mokkery when K2 broke their test suite<sup>19</sup>. The Mockative maintainer himself publicly suggested users investigate Mokkery as a viable alternative<sup>7</sup>.</p> <p>This ecosystem schism validated a critical insight: compiler plugins, not KSP, are the only stable architecture for KMP test tooling.</p> <p>Why Mokkery Succeeded:</p> <p>Mokkery operates inside the Kotlin compiler as an IR transformer. When you write <code>mock&lt;UserRepository&gt;()</code>, Mokkery\u2019s plugin replaces that call with a fully-generated implementation class at the IR level<sup>20</sup>. This eliminates KSP\u2019s fundamental problem: fragile source-set code generation.</p> <p>Mokkery\u2019s API is intentionally designed as a MockK analogue<sup>21</sup>, providing zero-friction migration for KMP developers:</p> <pre><code>// Mokkery: Familiar MockK-like DSL\nval repository = mock&lt;BookRepository&gt;()\nevery { repository.findAll() } returns flowOf(Book(\"...\"))\nverify(exhaustiveOrder) { repository.findById(\"1\") }\n</code></pre> <p>Mokkery is production-ready (v2.10.2), actively maintained, and the current incumbent for KMP mocking<sup>22</sup>. For teams committed to interaction-based testing, Mokkery is a credible, stable solution.</p> <p>The Compiler Plugin Validation:</p> <p>Mokkery\u2019s success proves the architectural validity of compiler plugins for KMP testing. Both Mokkery and Fakt share this fundamental design decision. This isn\u2019t coincidental\u2014it\u2019s the only path that survives K2\u2019s stricter compilation model.</p> <p>Where Mokkery and Fakt Diverge:</p> <p>The critical difference isn\u2019t architecture\u2014it\u2019s testing paradigm coverage.</p> <p>Mokkery is a mocking library designed exclusively for interaction-based testing (verifying that methods were called). Fakt is a fake generator that supports both paradigms: state-based testing (primary) with built-in interaction tracking through StateFlow call counting.</p> <p>This distinction reveals itself in Mokkery\u2019s documented limitations<sup>23</sup>. As a mocking library, Mokkery is architecturally unable to mock:</p> <ul> <li><code>object</code> singletons</li> <li><code>sealed class</code> and <code>sealed interface</code> hierarchies</li> <li>Top-level functions and extension functions</li> <li>Final classes from third-party dependencies</li> </ul> <p>These aren\u2019t bugs\u2014they\u2019re the glass ceiling of the mocking paradigm. Mocking requires \u201cfully overridable\u201d types (interfaces, abstract classes). Sealed types, objects, and final classes cannot be \u201cmocked\u201d at runtime.</p> <p>Fakt\u2019s Dual Paradigm Advantage:</p> <p>Fakt doesn\u2019t mock\u2014it generates real implementations with support for both testing approaches. Every generated fake includes:</p> <ul> <li>Behavior configuration (state-based testing)</li> <li>StateFlow call tracking (interaction-based testing)</li> <li>Thread-safety (no <code>var count = 0</code> footguns)</li> </ul> <p>As documented earlier in \u201cSupporting Both Testing Paradigms,\u201d the same Fakt fake can verify state and interactions:</p> <pre><code>val fake = fakeUserRepository {\n    save { user -&gt; user.copy(id = \"generated-id\") }\n}\n\n// State-based verification\nval result = fake.save(User(\"test\"))\nassertEquals(\"generated-id\", result.id) // What happened?\n\n// Interaction-based verification (same fake)\nassertEquals(1, fake.saveCallCount.value) // How many times?\n</code></pre> <p>This dual paradigm support means you\u2019re not forced to choose philosophies\u2014Fakt adapts to your testing needs.</p> <p>The Brittleness Trade-off:</p> <p>Consider this refactoring scenario that highlights the paradigm difference:</p> <pre><code>// Original implementation\nfun checkout() {\n    repository.saveOrder(order)\n}\n\n// Mokkery test (interaction-based ONLY)\nverify(exactly = 1) { repository.saveOrder(order) }\n\n// Refactored implementation (same outcome, different method signature)\nfun checkout() {\n    repository.saveOrderWithAudit(order, auditLog = true)\n}\n\n// Result: Mokkery test BREAKS (false negative)\n// The outcome is identical, but the process changed\n</code></pre> <p>The outcome is identical (order saved), but the process changed. The mock-based test fails even though no bug exists. This is the brittleness Martin Fowler warned about\u2014tests coupled to how code works, not what it achieves<sup>9</sup>.</p> <p>The same refactoring with Fakt:</p> <pre><code>// Fakt test (state-based verification)\nval fake = fakeRepository()\nviewModel.checkout()\nassertEquals(1, fake.orders.size) // Assert OUTCOME, not process\n// Test survives refactoring\n</code></pre> <p>This test survives because it verifies state (was the order saved?), not interactions (which method was called?). And when you do need interaction verification, Fakt provides it through StateFlow: <code>assertEquals(1, fake.saveOrderCallCount.value)</code>.</p> <p>Complementary Solutions:</p> <p>Mokkery and Fakt serve different philosophical commitments:</p> Choose Mokkery When: Choose Fakt When: Interaction-based testing is your standard State-based testing is your primary approach MockK muscle memory drives your team Need both paradigms in one tool Side-effect verification without observable state Building test fixtures with controllable behavior Committed to London School exclusively Following Google\u2019s NiA pattern (state-based) <p>For teams with MockK expertise, Mokkery is the natural KMP migration path. For teams adopting state-based testing or needing flexibility between both paradigms, Fakt completes the Kotlin async testing stack (<code>runTest</code> + Turbine + Fakes).</p> <p>The Architectural Depth Difference:</p> <p>Mokkery and Fakt differ even at the compiler level:</p> <ul> <li>Mokkery: IR-only plugin (single-phase, anonymous IR classes, invisible output)</li> <li>Fakt: FIR \u2192 IR plugin (two-phase, readable <code>.kt</code> files, full debuggability)</li> </ul> <p>Fakt\u2019s two-phase architecture provides richer semantic information (full type resolution at FIR) and debuggable output (step through generated fakes with breakpoints). Mokkery\u2019s IR-only approach is invisible (no physical files), which works well for mocking but limits debuggability.</p> <p>Conclusion:</p> <p>Mokkery validates the compiler plugin architecture as the survivor of the K2 schism. It\u2019s an excellent solution for teams committed to interaction-based testing. Fakt extends this foundation by supporting both testing paradigms\u2014state-based verification with optional interaction tracking\u2014while generating real implementations that handle sealed types, objects, and other idiomatic Kotlin patterns that mocking fundamentally cannot support.</p> <p>The choice isn\u2019t \u201cwhich is better\u201d\u2014it\u2019s about paradigm needs. Mokkery excels at interaction-based testing. Fakt provides dual paradigm support with architectural advantages for Kotlin\u2019s full type system.</p>"},{"location":"introduction/why-fakt.html#fakts-fir-ir-two-phase-architecture","title":"Fakt\u2019s FIR \u2192 IR Two-Phase Architecture","text":"<p>Fakt uses a Metro-inspired production compiler plugin architecture with deep integration into Kotlin\u2019s compilation pipeline:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1: FIR (Frontend IR)                         \u2502\n\u2502  \u2022 FaktFirExtensionRegistrar                         \u2502\n\u2502  \u2022 Detects @Fake annotations on interfaces          \u2502\n\u2502  \u2022 Validates structure, thread-safety requirements   \u2502\n\u2502  \u2022 Full access to type system during resolution      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 2: IR (Intermediate Representation)          \u2502\n\u2502  \u2022 UnifiedFaktIrGenerationExtension                  \u2502\n\u2502  \u2022 InterfaceAnalyzer: Dynamic interface discovery    \u2502\n\u2502  \u2022 IrCodeGenerator: Type-safe code generation        \u2502\n\u2502  \u2022 Generates readable .kt files (not IR nodes)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  OUTPUT: Generated Kotlin Source Code               \u2502\n\u2502  \u2022 FakeXxxImpl.kt (implementation class)             \u2502\n\u2502  \u2022 fakeXxx() factory (type-safe DSL)                 \u2502\n\u2502  \u2022 Thread-safe StateFlow call tracking               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Metro Alignment: Fakt follows the production-validated pattern from Metro, Zac Sweers\u2019 dependency injection compiler plugin used by Google, Netflix, and Cash App. Metro\u2019s two-phase FIR \u2192 IR architecture has proven stable across Kotlin 1.9, 2.0, and 2.1.</p> <p>Why Not IR-Native Generation?</p> <p>Fakt generates readable <code>.kt</code> source files, not IR nodes directly. For test fakes\u2014code developers constantly debug\u2014transparency outweighs marginal performance gains. Generated fakes are real Kotlin files you can step through with breakpoints, not decompiled bytecode.</p>"},{"location":"introduction/why-fakt.html#supporting-both-testing-paradigms","title":"Supporting Both Testing Paradigms","text":"<p>Fakt doesn\u2019t force you to choose between state-based or interaction-based testing. Every generated fake supports both philosophies simultaneously.</p> <p>State-Based Testing (Classic/Detroit School):</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun save(user: User): User\n}\n\n// Generated: Behavior configuration DSL\nval fake = fakeUserRepository {\n    save { user -&gt; user.copy(id = \"generated-id\") }\n}\n\n// Test: Verify STATE\n@Test\nfun `GIVEN user WHEN saving THEN returns persisted user`() = runTest {\n    val result = fake.save(User(\"test\"))\n    assertEquals(\"generated-id\", result.id) // State verification\n}\n</code></pre> <p>Interaction-Based Testing (London School):</p> <pre><code>// Same generated fake includes automatic call tracking\n@Test\nfun `GIVEN multiple saves WHEN called THEN tracks interaction count`() = runTest {\n    fake.save(User(\"user1\"))\n    fake.save(User(\"user2\"))\n\n    // Verify INTERACTIONS (thread-safe StateFlow)\n    assertEquals(2, fake.saveCallCount.value)\n}\n</code></pre> <p>The Technical Achievement:</p> <p>Every generated method/property includes: - Behavior configuration (state-based testing) - StateFlow call tracking (interaction-based testing) - Thread-safety (no <code>var count = 0</code> footguns) - Zero runtime overhead (compile-time generation)</p> <p>One tool. Both paradigms. Zero dogma.</p>"},{"location":"introduction/why-fakt.html#how-fakt-works","title":"How Fakt Works","text":"<pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n}\n\n// Generated at compile-time (zero runtime overhead)\nval fake = fakeUserRepository {\n    getUser { id -&gt; Result.success(User(id, \"Alice\")) }\n}\n\n// State-based: Configure behavior\nfake.getUser(\"123\") // Returns User(\"123\", \"Alice\")\n\n// Interaction-based: Verify calls\nassertEquals(1, fake.getUserCallCount.value) // Thread-safe StateFlow\n</code></pre>"},{"location":"introduction/why-fakt.html#technical-advantages","title":"Technical Advantages","text":"<p>Universal Platform Support: - JVM, Android, Native (iOS/Desktop), JavaScript, WebAssembly - No reflection required (works on Native/Wasm) - Zero runtime dependencies</p> <p>Zero Performance Overhead: - Eliminates 1,391x MockK penalty<sup>1</sup> - No bytecode instrumentation - Generated code as fast as handwritten fakes</p> <p>100% Debuggable: - Readable <code>.kt</code> files in <code>build/generated/fakt/</code> - Set breakpoints, inspect variables - Step through generated implementations line-by-line</p> <p>Compiler-Level Stability: - Uses official Kotlin compiler extension points - Survives K2 compiler updates (unlike KSP tools) - Aligned with Metro\u2019s production-tested patterns</p> <p>Built-In Thread Safety: - StateFlow call tracking (not <code>var count = 0</code>) - No concurrent test flakiness - Reactive (works with Turbine for Flow testing)</p>"},{"location":"introduction/why-fakt.html#when-not-to-use-fakes","title":"When NOT to Use Fakes","text":"<p>Fakt isn\u2019t a silver bullet. Some scenarios favor other tools:</p> <p>Third-Party APIs \u2192 Use WireMock<sup>24</sup> or Pact<sup>25</sup> - Hand-written fakes for external APIs are \u201cdangerous illusions of fidelity\u201d - WireMock tests full HTTP client stack - Pact validates contracts with provider teams</p> <p>Legacy Code Without Interfaces \u2192 Use Pragmatic Mocks - Mocking frameworks can mock concrete classes via reflection - Allows testing before major refactoring - \u201cFakes-only\u201d demands all-or-nothing interface refactoring</p> <p>Side Effects Without Observable State \u2192 Use Mocks - Fire-and-forget analytics, logging - Interaction timing/ordering matters - Fakes provide no value without state to assert</p>"},{"location":"introduction/why-fakt.html#the-path-forward","title":"The Path Forward","text":"<p>Fakt represents the convergence of: - Industry best practices (Google\u2019s NiA pattern) - Verified performance data (1,391x MockK penalty eliminated) - Architectural necessity (KMP requires compile-time solutions) - Dual paradigm support (state-based AND interaction-based testing) - Compiler-level stability (FIR \u2192 IR architecture survives K2 updates)</p> <p>For JVM-only teams, Fakt delivers 40% faster test suites<sup>1</sup> and more resilient tests. For KMP teams, Fakt is the only stable fake generator for <code>commonTest</code>, complementing Mokkery\u2019s mocking capabilities with dual paradigm support and full Kotlin type system coverage.</p>"},{"location":"introduction/why-fakt.html#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Add Fakt to your project in 5 minutes</li> <li>Quick Start - Generate your first fake</li> <li>Testing Patterns - Hybrid strategies and best practices</li> <li>Migration Guide - Moving from MockK/Mockito</li> </ul>"},{"location":"introduction/why-fakt.html#works-cited","title":"Works Cited","text":"<ol> <li> <p>Benchmarking Mockk \u2014 Avoid these patterns for fast unit tests. Kevin Block. https://medium.com/@_kevinb/benchmarking-mockk-avoid-these-patterns-for-fast-unit-tests-220fc225da55 \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Mocking Kotlin classes with Mockito \u2014 the fast way. Brais Gab\u00edn Moreira. https://medium.com/21buttons-tech/mocking-kotlin-classes-with-mockito-the-fast-way-631824edd5ba \u21a9\u21a9</p> </li> <li> <p>Reflection | Kotlin Documentation. https://kotlinlang.org/docs/reflection.html \u21a9</p> </li> <li> <p>Reflection? - Native - Kotlin Discussions. https://discuss.kotlinlang.org/t/reflection/4054 \u21a9</p> </li> <li> <p>Did someone try to use Mockk on KMM project. Kotlin Slack. https://slack-chats.kotlinlang.org/t/10131532/did-someone-try-to-use-mockk-on-kmm-project \u21a9</p> </li> <li> <p>Mock common tests in kotlin using multiplatform. Stack Overflow. https://stackoverflow.com/questions/65491916/mock-common-tests-in-kotlin-using-multiplatform \u21a9</p> </li> <li> <p>Mocking in Kotlin Multiplatform: KSP vs Compiler Plugins. Martin Hristev. https://medium.com/@mhristev/mocking-in-kotlin-multiplatform-ksp-vs-compiler-plugins-4424751b83d7 \u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>MocKMP: a Mocking processor for Kotlin/Multiplatform. Salomon BRYS. https://medium.com/kodein-koders/mockmp-a-mocking-processor-for-kotlin-multiplatform-51957c484fe5 \u21a9</p> </li> <li> <p>Mocks Aren\u2019t Stubs. Martin Fowler. https://martinfowler.com/articles/mocksArentStubs.html \u21a9\u21a9</p> </li> <li> <p>Unit Testing \u2014 Why must you mock me? Craig Walker. https://medium.com/@walkercp/unit-testing-why-must-you-mock-me-69293508dd13 \u21a9</p> </li> <li> <p>Testing on the Toilet: Effective Testing. Google Testing Blog. https://testing.googleblog.com/2014/05/testing-on-toilet-effective-testing.html \u21a9</p> </li> <li> <p>Trade-offs to consider when choosing to use Mocks vs Fakes. HackMD. https://hackmd.io/@pierodibello/Trade-offs-to-consider-when-choosing-to-use-Mocks-vs-Fakes \u21a9</p> </li> <li> <p>android/nowinandroid: A fully functional Android app built entirely with Kotlin and Jetpack Compose. GitHub. https://github.com/android/nowinandroid \u21a9\u21a9</p> </li> <li> <p>Testing strategy and how to test. Now in Android Wiki. https://github.com/android/nowinandroid/wiki/Testing-strategy-and-how-to-test \u21a9\u21a9</p> </li> <li> <p>Testing Kotlin coroutines on Android. Android Developers. https://developer.android.com/kotlin/coroutines/test \u21a9</p> </li> <li> <p>Flow testing with Turbine. Cash App Code Blog. https://code.cash.app/flow-testing-with-turbine \u21a9</p> </li> <li> <p>lupuuss/Mokkery: The mocking library for Kotlin Multiplatform. GitHub. https://github.com/lupuuss/Mokkery \u21a9</p> </li> <li> <p>Kotlin 2.0.0 support \u00b7 Issue #1 \u00b7 lupuuss/Mokkery. GitHub. https://github.com/lupuuss/Mokkery/issues/1 \u21a9</p> </li> <li> <p>Use multiplatform mocking library for tests \u00b7 Issue #5420 \u00b7 streetcomplete/StreetComplete. GitHub. https://github.com/streetcomplete/StreetComplete/issues/5420 \u21a9</p> </li> <li> <p>Kotlin 2.2.0 support \u00b7 Issue #83 \u00b7 lupuuss/Mokkery. GitHub. https://github.com/lupuuss/Mokkery/issues/83 \u21a9</p> </li> <li> <p>Mocking | Mokkery. https://mokkery.dev/docs/Guides/Mocking/ \u21a9</p> </li> <li> <p>A to Z of Testing in Kotlin Multiplatform. Kinto Technologies. https://blog.kinto-technologies.com/posts/2024-12-24-tests-in-kmp/ \u21a9</p> </li> <li> <p>Limitations | Mokkery. https://mokkery.dev/docs/Limitations/ \u21a9</p> </li> <li> <p>Why we should use wiremock instead of Mockito. Stack Overflow. https://stackoverflow.com/questions/50726017/why-we-should-use-wiremock-instead-of-mockito \u21a9</p> </li> <li> <p>Stop Breaking My API: A Practical Guide to Contract Testing with Pact. Medium. https://medium.com/@mohsenny/stop-breaking-my-api-a-practical-guide-to-contract-testing-with-pact-33858d113386 \u21a9</p> </li> <li> <p>Effective migration to Kotlin on Android. Aris Papadopoulos. https://medium.com/android-news/effective-migration-to-kotlin-on-android-cfb92bfaa49b \u21a9</p> </li> </ol>"},{"location":"multi-module/index.html","title":"Multi-Module Support","text":"<p>Fakt\u2019s multi-module support enables fake reuse across multiple Gradle modules through dedicated collector modules.</p> <p>Experimental API</p> <p>Multi-module support is marked <code>@ExperimentalFaktMultiModule</code>. The API is production-ready but may evolve based on real-world feedback. Explicit opt-in is required.</p>"},{"location":"multi-module/index.html#what-is-multi-module-support","title":"What is Multi-Module Support?","text":"<p>Multi-module support allows you to:</p> <ul> <li>Generate fakes once in a producer module with <code>@Fake</code> interfaces</li> <li>Collect fakes in a dedicated collector module</li> <li>Use fakes across multiple consumer modules in tests</li> </ul> <p>This eliminates fake duplication and enables clean dependency management in large projects.</p>"},{"location":"multi-module/index.html#architecture-producer-collector-consumer","title":"Architecture: Producer \u2192 Collector \u2192 Consumer","text":"<p>Fakt\u2019s multi-module pattern uses three distinct roles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PRODUCER MODULE (:core:analytics)                              \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Contains @Fake annotated interfaces                          \u2502\n\u2502  \u2022 Fakt generates fakes at compile-time                         \u2502\n\u2502  \u2022 Output: build/generated/fakt/commonTest/kotlin/              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  COLLECTOR MODULE (:core:analytics-fakes) \u2020                     \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Collects generated fakes from producer                       \u2502\n\u2502  \u2022 FakeCollectorTask copies fakes with platform detection       \u2502\n\u2502  \u2022 Output: build/generated/collected-fakes/{platform}/kotlin/   \u2502\n\u2502  \u2022 Published as standard Gradle dependency                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  CONSUMER MODULES (:app, :features:login, etc.)                 \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Depend on collector module in tests                          \u2502\n\u2502  \u2022 Use fakes via generated factory functions                    \u2502\n\u2502  \u2022 No direct dependency on producer's test code                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u2020 Naming is flexible - can be :analytics-fakes, :analytics-test,\n  :analytics-test-fixtures, or any name you choose\n</code></pre>"},{"location":"multi-module/index.html#when-to-use-multi-module","title":"When to Use Multi-Module?","text":""},{"location":"multi-module/index.html#use-multi-module-when","title":"\u2705 Use Multi-Module When","text":"<ul> <li>Multiple modules need the same fakes (e.g., <code>core/logger</code> used by 10+ feature modules)</li> <li>Publishing fakes as artifacts (Maven Central, internal repository)</li> <li>Strict module boundaries (DDD, Clean Architecture, modular monoliths)</li> <li>Large teams with module ownership (dedicated teams per module)</li> <li>Shared test infrastructure (common fakes for integration tests)</li> </ul>"},{"location":"multi-module/index.html#use-single-module-when","title":"\u274c Use Single-Module When","text":"<ul> <li>Single module or 2-3 closely related modules</li> <li>Fakes only used locally (not shared across modules)</li> <li>Small team or early prototyping (prefer simplicity)</li> <li>Rapid iteration (multi-module adds slight build overhead)</li> </ul>"},{"location":"multi-module/index.html#decision-example","title":"Decision Example","text":"<p>Scenario: E-commerce app with 20 modules (5 core, 15 features)</p> <ul> <li>Core modules: <code>analytics</code>, <code>auth</code>, <code>logger</code>, <code>network</code>, <code>storage</code></li> <li>Feature modules: <code>login</code>, <code>checkout</code>, <code>profile</code>, <code>search</code>, etc.</li> </ul> <p>Analysis: - All 15 features depend on <code>core/logger</code> and <code>core/analytics</code> - Features share authentication via <code>core/auth</code></p> <p>Decision: Use multi-module - Create 5 collector modules (one per core module) - Features depend on collectors in tests - Benefits: Fake reuse, clean dependencies, single source of truth</p>"},{"location":"multi-module/index.html#quick-example","title":"Quick Example","text":""},{"location":"multi-module/index.html#producer-module","title":"Producer Module","text":"<p>Define <code>@Fake</code> interfaces in your core module:</p> <pre><code>// :core:analytics/src/commonMain/kotlin/Analytics.kt\npackage com.example.core.analytics\n\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    suspend fun identify(userId: String)\n}\n</code></pre> <p>Build the module\u2014Fakt generates fakes in <code>build/generated/fakt/commonTest/kotlin/</code>.</p>"},{"location":"multi-module/index.html#collector-module","title":"Collector Module","text":"<p>Create a dedicated module to collect the generated fakes:</p> <pre><code>// :core:analytics-fakes/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.rsicarelli.fakt\")\n}\n\nkotlin {\n    // Configure your KMP targets (jvm, ios, etc.)\n\n    sourceSets.commonMain.dependencies {\n        // CRITICAL: api() exposes original types to consumers\n        api(projects.core.analytics)\n\n        // Add dependencies needed by generated fakes\n        implementation(libs.coroutines)\n    }\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Naming Flexibility</p> <p>The collector module can be named anything you prefer:</p> <ul> <li><code>:core:analytics-fakes</code> \u2705 (recommended convention)</li> <li><code>:core:analytics-test</code> \u2705</li> <li><code>:core:analytics-test-fixtures</code> \u2705</li> <li><code>:test:analytics</code> \u2705</li> <li><code>:testFixtures:analytics</code> \u2705</li> </ul> <p>Fakt doesn\u2019t impose any naming convention. Choose what fits your project best.</p>"},{"location":"multi-module/index.html#consumer-module","title":"Consumer Module","text":"<p>Use the collected fakes in your tests:</p> <pre><code>// :app/build.gradle.kts\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre> <pre><code>// :app/src/commonTest/kotlin/AppTest.kt\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AppTest {\n    @Test\n    fun `GIVEN app WHEN tracking event THEN should log event`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val analytics = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n        }\n\n        // Use analytics in your test...\n        analytics.track(\"user_login\")\n\n        assertEquals(listOf(\"user_login\"), events)\n        assertEquals(1, analytics.trackCallCount.value)\n    }\n}\n</code></pre>"},{"location":"multi-module/index.html#how-it-works-under-the-hood","title":"How It Works Under the Hood","text":""},{"location":"multi-module/index.html#1-producer-fake-generation","title":"1. Producer: Fake Generation","text":"<p>When you build the producer module:</p> <pre><code>./gradlew :core:analytics:build\n</code></pre> <p>Fakt\u2019s IR generator creates fakes in test source sets:</p> <pre><code>core/analytics/build/generated/fakt/\n\u251c\u2500\u2500 commonTest/kotlin/com/example/core/analytics/\n\u2502   \u251c\u2500\u2500 FakeAnalyticsImpl.kt\n\u2502   \u251c\u2500\u2500 fakeAnalytics.kt (factory)\n\u2502   \u2514\u2500\u2500 FakeAnalyticsConfig.kt (DSL)\n\u251c\u2500\u2500 jvmTest/kotlin/  (if JVM target)\n\u2514\u2500\u2500 iosTest/kotlin/  (if iOS target)\n</code></pre>"},{"location":"multi-module/index.html#2-collector-intelligent-fake-collection","title":"2. Collector: Intelligent Fake Collection","text":"<p>When you build the collector module:</p> <pre><code>./gradlew :core:analytics-fakes:build\n</code></pre> <p><code>FakeCollectorTask</code> runs and:</p> <ol> <li>Discovers all generated fakes from producer</li> <li>Analyzes package structure to detect target platform</li> <li>Copies fakes to appropriate source set directory</li> <li>Registers as source roots for compilation</li> </ol> <p>Platform Detection Example:</p> <pre><code>// Fake with package: com.example.jvm.database\n// \u2192 Placed in: jvmMain/kotlin/\n\n// Fake with package: com.example.ios.camera\n// \u2192 Placed in: iosMain/kotlin/\n\n// Fake with package: com.example.shared.network\n// \u2192 Placed in: commonMain/kotlin/ (fallback)\n</code></pre> <p>See Advanced Topics for algorithm details.</p>"},{"location":"multi-module/index.html#3-consumer-standard-dependency","title":"3. Consumer: Standard Dependency","text":"<p>Consumers declare standard Gradle dependencies:</p> <pre><code>dependencies {\n    commonTestImplementation(projects.core.analyticsFakes)\n}\n</code></pre> <p>The collector module exposes: - Original interfaces (via <code>api(projects.core.analytics)</code>) - Generated fakes (compiled from collected sources)</p>"},{"location":"multi-module/index.html#real-world-example-kmp-multi-module-sample","title":"Real-World Example: kmp-multi-module Sample","text":"<p>Fakt includes a production-quality sample with:</p> <ul> <li>11 producer modules (5 core + 6 features)</li> <li>11 collector modules (one per producer)</li> <li>1 consumer module (app using all fakes)</li> </ul> <p>Structure:</p> <pre><code>samples/kmp-multi-module/\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 analytics/ \u2192 analytics-fakes/\n\u2502   \u251c\u2500\u2500 auth/ \u2192 auth-fakes/\n\u2502   \u251c\u2500\u2500 logger/ \u2192 logger-fakes/\n\u2502   \u251c\u2500\u2500 network/ \u2192 network-fakes/\n\u2502   \u2514\u2500\u2500 storage/ \u2192 storage-fakes/\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 dashboard/ \u2192 dashboard-fakes/\n\u2502   \u251c\u2500\u2500 login/ \u2192 login-fakes/\n\u2502   \u251c\u2500\u2500 notifications/ \u2192 notifications-fakes/\n\u2502   \u251c\u2500\u2500 order/ \u2192 order-fakes/\n\u2502   \u251c\u2500\u2500 profile/ \u2192 profile-fakes/\n\u2502   \u2514\u2500\u2500 settings/ \u2192 settings-fakes/\n\u2502\n\u2514\u2500\u2500 app/ (uses all 11 fake modules)\n</code></pre> <p>Test Example (composing multiple fakes):</p> <pre><code>// features/login/src/commonTest/kotlin/LoginUseCaseTest.kt\n@Test\nfun `GIVEN login use case WHEN login succeeds THEN should track event`() = runTest {\n    // Arrange: Configure 4 different fakes from 4 collector modules\n    val authProvider = fakeAuthProvider {\n        login { Result.success(User(\"123\", \"Alice\")) }\n    }\n\n    val logger = fakeLogger {\n        info { message -&gt; println(\"LOG: $message\") }\n    }\n\n    val storage = fakeTokenStorage {\n        save { token -&gt; Result.success(Unit) }\n    }\n\n    val analytics = fakeAnalytics {\n        track { event -&gt; println(\"EVENT: $event\") }\n    }\n\n    val useCase = LoginUseCase(authProvider, logger, storage, analytics)\n\n    // Act\n    val result = useCase.login(Credentials(\"alice\", \"password\"))\n\n    // Assert\n    assertTrue(result.isSuccess)\n    assertEquals(1, analytics.trackCallCount.value)\n}\n</code></pre>"},{"location":"multi-module/index.html#key-benefits","title":"Key Benefits","text":""},{"location":"multi-module/index.html#fake-reuse","title":"\u2705 Fake Reuse","text":"<p>Generate fakes once, use everywhere:</p> <pre><code>// Core module defines interface\ncore/logger @Fake interface Logger\n\n// 15 feature modules reuse the same fake\nfeatures/login     \u2192 depends on logger-fakes\nfeatures/checkout  \u2192 depends on logger-fakes\nfeatures/profile   \u2192 depends on logger-fakes\n// ... 12 more features\n</code></pre>"},{"location":"multi-module/index.html#clean-dependencies","title":"\u2705 Clean Dependencies","text":"<p>Consumers depend on collector modules, not producer test code:</p> <pre><code>// \u274c BAD: Direct dependency on producer's test source set\ntestImplementation(projects.core.analytics) {\n    capabilities {\n        requireCapability(\"com.example:analytics-test-fixtures\")\n    }\n}\n\n// \u2705 GOOD: Standard dependency on collector module\ntestImplementation(projects.core.analyticsFakes)\n</code></pre>"},{"location":"multi-module/index.html#publishable-artifacts","title":"\u2705 Publishable Artifacts","text":"<p>Collectors are standard Gradle modules and can be published:</p> <pre><code>./gradlew :core:analytics-fakes:publishToMavenLocal\n./gradlew :core:analytics-fakes:publish\n</code></pre> <p>Useful for: - Internal artifact repositories - Shared test infrastructure across projects - Multi-repo setups</p>"},{"location":"multi-module/index.html#platform-awareness","title":"\u2705 Platform Awareness","text":"<p>Fakt automatically places fakes in the correct KMP source set:</p> <ul> <li>JVM-specific fakes \u2192 <code>jvmMain/kotlin/</code></li> <li>iOS-specific fakes \u2192 <code>iosMain/kotlin/</code></li> <li>Shared fakes \u2192 <code>commonMain/kotlin/</code></li> </ul> <p>No manual configuration required.</p>"},{"location":"multi-module/index.html#getting-started","title":"Getting Started","text":"<p>Ready to set up multi-module support? Follow the Getting Started Guide for a step-by-step tutorial.</p> <p>Next Steps:</p> <ul> <li>Getting Started - 15-minute tutorial</li> <li>Advanced Topics - Platform detection, performance, publishing</li> <li>Troubleshooting - Common issues &amp; solutions</li> <li>Migration Guide - Single-module \u2192 Multi-module</li> <li>Technical Reference - FakeCollectorTask deep dive</li> </ul>"},{"location":"multi-module/index.html#comparison-with-single-module","title":"Comparison with Single-Module","text":"Aspect Single-Module Multi-Module Setup Zero config (default) Requires collector modules Fake Access Local to module only Cross-module reuse Dependencies No extra dependencies Collector module dependencies Build Time Fast (no collection overhead) Slight overhead (collection task) Publishable No (test code not published) Yes (collectors are modules) Best For 1-3 modules, rapid prototyping Large projects, shared infrastructure"},{"location":"multi-module/index.html#requirements","title":"Requirements","text":"<ul> <li>Fakt: 1.0.0-SNAPSHOT+</li> <li>Kotlin: 2.2.20+</li> <li>Gradle: 8.0+</li> <li>Multi-Module Project: Producer + Collector + Consumer setup</li> </ul>"},{"location":"multi-module/index.html#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"multi-module/index.html#can-i-mix-single-module-and-multi-module","title":"Can I mix single-module and multi-module?","text":"<p>Yes. Some modules can use single-module (fakes stay local), while others use multi-module (fakes collected and shared). Choose per module based on needs.</p>"},{"location":"multi-module/index.html#do-i-need-a-collector-for-every-producer","title":"Do I need a collector for every producer?","text":"<p>No. Only create collectors for modules whose fakes you want to share. If a module\u2019s fakes are only used locally, skip the collector.</p>"},{"location":"multi-module/index.html#what-if-i-dont-follow-the-fakes-naming-convention","title":"What if I don\u2019t follow the <code>-fakes</code> naming convention?","text":"<p>No problem. Fakt doesn\u2019t enforce any naming convention. Name your collector modules however you prefer:</p> <ul> <li><code>:core:analytics-fakes</code> (recommended convention)</li> <li><code>:core:analytics-test</code></li> <li><code>:testFixtures:analytics</code></li> <li><code>:test:analytics</code></li> <li>Anything else</li> </ul>"},{"location":"multi-module/index.html#can-i-publish-collectors-to-maven-central","title":"Can I publish collectors to Maven Central?","text":"<p>Yes. Collectors are standard Gradle modules and can be published like any other artifact. Useful for shared test infrastructure.</p>"},{"location":"multi-module/index.html#does-multi-module-work-with-android","title":"Does multi-module work with Android?","text":"<p>Yes. Fully supported for Android projects (single-platform or KMP).</p>"},{"location":"multi-module/index.html#whats-the-build-time-impact","title":"What\u2019s the build time impact?","text":"<p>Minimal. First target compilation adds ~5-10ms per fake module for collection. Subsequent targets are cached (~1-2ms). See Performance for details.</p>"},{"location":"multi-module/index.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Set up your first multi-module project</li> <li>Advanced Topics - Deep technical details</li> <li>Troubleshooting - Debug common issues</li> </ul>"},{"location":"multi-module/advanced.html","title":"Advanced Topics","text":"<p>Deep technical details for power users and complex multi-module setups.</p>"},{"location":"multi-module/advanced.html#platform-detection","title":"Platform Detection","text":"<p>Fakt\u2019s <code>FakeCollectorTask</code> automatically detects target platforms by analyzing package structures.</p>"},{"location":"multi-module/advanced.html#how-it-works","title":"How It Works","text":"<p>Algorithm: 1. Extract package declaration from generated fake file 2. Split package into segments (e.g., <code>com.example.ios.auth</code> \u2192 <code>[\"com\", \"example\", \"ios\", \"auth\"]</code>) 3. Match segments against available KMP source sets 4. Prioritize shortest match (most general) 5. Fallback to <code>commonMain</code> if no match</p> <p>Examples:</p> <pre><code>// Input: package com.example.jvm.database\n// Available: [commonMain, jvmMain, iosMain]\n// Matches: jvmMain (from \"jvm\" segment)\n// Output: jvmMain/kotlin/com/example/jvm/database/FakeDatabaseImpl.kt\n\n// Input: package com.example.ios.camera  \n// Available: [commonMain, iosMain, iosArm64Main, iosX64Main]\n// Matches: iosMain (7 chars), iosArm64Main (13 chars), iosX64Main (10 chars)\n// Selected: iosMain (shortest = most general)\n// Output: iosMain/kotlin/com/example/ios/camera/FakeCameraImpl.kt\n\n// Input: package com.example.shared.network\n// Available: [commonMain, jvmMain, jsMain]\n// Matches: (none - \"shared\" doesn't match any source set)\n// Output: commonMain/kotlin/com/example/shared/network/FakeNetworkImpl.kt (fallback)\n</code></pre>"},{"location":"multi-module/advanced.html#package-naming-conventions","title":"Package Naming Conventions","text":"<p>Use platform identifiers in package names for automatic detection:</p> Platform Package Segment Example JVM <code>jvm.*</code> <code>com.example.jvm.database</code> Android <code>android.*</code> <code>com.example.android.storage</code> iOS <code>ios.*</code> <code>com.example.ios.camera</code> JS <code>js.*</code> <code>com.example.js.browser</code> Native <code>native.*</code> <code>com.example.native.file</code> WASM <code>wasm.*</code> <code>com.example.wasm.api</code> Common <code>shared.*</code>, <code>common.*</code> <code>com.example.shared.logger</code> (fallback)"},{"location":"multi-module/advanced.html#build-system-integration","title":"Build System Integration","text":""},{"location":"multi-module/advanced.html#task-dependencies","title":"Task Dependencies","text":"<p>FakeCollectorTask automatically wires dependencies:</p> <pre><code>Producer Compilation\n:core:analytics:compileKotlinMetadata\n:core:analytics:compileKotlinJvm\n:core:analytics:compileKotlinIos\n    \u2193 dependsOn\nCollector Collection\n:core:analytics-fakes:collectFakes\n    \u2193 dependsOn\nCollector Compilation\n:core:analytics-fakes:compileKotlinJvm\n:core:analytics-fakes:compileKotlinIos\n    \u2193 testImplementation dependency\nConsumer Compilation\n:app:compileTestKotlinJvm\n:app:compileTestKotlinIos\n</code></pre>"},{"location":"multi-module/advanced.html#incremental-compilation","title":"Incremental Compilation","text":"<p>Fakt supports Gradle incremental compilation:</p> <ul> <li>First build: Full fake generation + collection (~40ms for 100 interfaces)</li> <li>No changes: Skip generation and collection (cached)</li> <li>Producer changed: Regenerate fakes + recollect (~40ms)</li> <li>Collector config changed: Recollect only (~10ms)</li> <li>Consumer changed: No regeneration/recollection (uses compiled artifacts)</li> </ul>"},{"location":"multi-module/advanced.html#configuration-cache-compatibility","title":"Configuration Cache Compatibility","text":"<p>Fakt is fully compatible with Gradle configuration cache:</p> <pre><code>./gradlew build --configuration-cache\n</code></pre> <p>FakeCollectorTask uses: - <code>Property&lt;T&gt;</code> for all configuration - File collections instead of file paths - No direct <code>Project</code> references at execution time</p>"},{"location":"multi-module/advanced.html#performance-optimization","title":"Performance Optimization","text":""},{"location":"multi-module/advanced.html#build-time-impact","title":"Build Time Impact","text":"<p>Typical overhead per fake module:</p> Scenario Time per Module Total (10 modules) Clean build (first) ~40-50ms ~400-500ms Incremental (changed) ~10-15ms ~100-150ms Incremental (cached) ~1-2ms ~10-20ms"},{"location":"multi-module/advanced.html#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"multi-module/advanced.html#1-enable-build-cache","title":"1. Enable Build Cache","text":"<pre><code>// gradle.properties\norg.gradle.caching=true\norg.gradle.configuration-cache=true\n</code></pre> <pre><code>./gradlew build --build-cache\n</code></pre>"},{"location":"multi-module/advanced.html#2-parallel-compilation","title":"2. Parallel Compilation","text":"<pre><code>// gradle.properties\norg.gradle.parallel=true\norg.gradle.workers.max=8\n</code></pre>"},{"location":"multi-module/advanced.html#3-increase-heap-size","title":"3. Increase Heap Size","text":"<pre><code>// gradle.properties\norg.gradle.jvmargs=-Xmx4g -XX:MaxMetaspaceSize=1g\n</code></pre>"},{"location":"multi-module/advanced.html#4-use-loglevelquiet-in-ci","title":"4. Use LogLevel.QUIET in CI","text":"<pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.QUIET)\n}\n</code></pre>"},{"location":"multi-module/advanced.html#analyzing-build-performance","title":"Analyzing Build Performance","text":"<pre><code># Generate build scan\n./gradlew build --scan\n\n# Profile build\n./gradlew build --profile\n\n# Check task times\n./gradlew build --info | grep \"Execution time\"\n</code></pre>"},{"location":"multi-module/advanced.html#publishing-fake-modules","title":"Publishing Fake Modules","text":"<p>Collector modules are standard Gradle modules and can be published to repositories.</p>"},{"location":"multi-module/advanced.html#publishing-to-maven-local","title":"Publishing to Maven Local","text":"<pre><code>./gradlew :core:analytics-fakes:publishToMavenLocal\n</code></pre>"},{"location":"multi-module/advanced.html#publishing-to-maven-central","title":"Publishing to Maven Central","text":"<p>Add to collector\u2019s <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    `maven-publish`\n    signing\n}\n\npublishing {\n    publications {\n        create&lt;MavenPublication&gt;(\"maven\") {\n            from(components[\"kotlin\"])\n\n            groupId = \"com.example\"\n            artifactId = \"analytics-fakes\"\n            version = \"1.0.0\"\n\n            pom {\n                name.set(\"Analytics Fakes\")\n                description.set(\"Test fakes for Analytics interface\")\n                url.set(\"https://github.com/example/project\")\n\n                licenses {\n                    license {\n                        name.set(\"Apache License 2.0\")\n                        url.set(\"https://www.apache.org/licenses/LICENSE-2.0\")\n                    }\n                }\n\n                developers {\n                    developer {\n                        id.set(\"example\")\n                        name.set(\"Example Developer\")\n                    }\n                }\n\n                scm {\n                    connection.set(\"scm:git:git://github.com/example/project.git\")\n                    url.set(\"https://github.com/example/project\")\n                }\n            }\n        }\n    }\n\n    repositories {\n        maven {\n            name = \"sonatype\"\n            url = uri(\"https://oss.sonatype.org/service/local/staging/deploy/maven2/\")\n            credentials {\n                username = project.findProperty(\"ossrhUsername\") as String?\n                password = project.findProperty(\"ossrhPassword\") as String?\n            }\n        }\n    }\n}\n\nsigning {\n    sign(publishing.publications[\"maven\"])\n}\n</code></pre>"},{"location":"multi-module/advanced.html#using-published-fakes","title":"Using Published Fakes","text":"<pre><code>// Consumer module\ndependencies {\n    commonTestImplementation(\"com.example:analytics-fakes:1.0.0\")\n}\n</code></pre>"},{"location":"multi-module/advanced.html#ide-integration","title":"IDE Integration","text":""},{"location":"multi-module/advanced.html#intellij-idea-android-studio","title":"IntelliJ IDEA / Android Studio","text":"<p>Fakt-generated fakes are automatically indexed by IDEs.</p> <p>Setup: 1. Build project: <code>./gradlew build</code> 2. Sync Gradle: File \u2192 Reload All Gradle Projects 3. Verify: Type <code>fake</code> and check autocomplete suggestions</p> <p>Troubleshooting: - Fakes not appearing: File \u2192 Invalidate Caches \u2192 Invalidate and Restart - Wrong platform fakes: Check package naming conventions - Compilation errors: Verify collector targets match producer</p>"},{"location":"multi-module/advanced.html#debugging-generated-code","title":"Debugging Generated Code","text":"<p>Navigate to generated fakes:</p> <pre><code>core/analytics-fakes/build/generated/collected-fakes/\n\u251c\u2500\u2500 commonMain/kotlin/  # IDE can navigate here\n\u251c\u2500\u2500 jvmMain/kotlin/\n\u2514\u2500\u2500 iosMain/kotlin/\n</code></pre> <p>Add breakpoints in generated code for debugging.</p>"},{"location":"multi-module/advanced.html#multi-repository-setups","title":"Multi-Repository Setups","text":"<p>For projects spanning multiple Git repositories:</p>"},{"location":"multi-module/advanced.html#repository-a-shared-infrastructure","title":"Repository A (Shared Infrastructure)","text":"<pre><code>// repo-a/core/analytics/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.rsicarelli.fakt\")\n    `maven-publish`\n}\n\npublishing {\n    publications {\n        create&lt;MavenPublication&gt;(\"maven\") {\n            from(components[\"kotlin\"])\n            groupId = \"com.company.shared\"\n            artifactId = \"analytics\"\n            version = \"2.0.0\"\n        }\n    }\n}\n\n// repo-a/core/analytics-fakes/build.gradle.kts\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\npublishing {\n    publications {\n        create&lt;MavenPublication&gt;(\"maven\") {\n            from(components[\"kotlin\"])\n            groupId = \"com.company.shared\"\n            artifactId = \"analytics-fakes\"\n            version = \"2.0.0\"\n        }\n    }\n}\n</code></pre>"},{"location":"multi-module/advanced.html#repository-b-consumer","title":"Repository B (Consumer)","text":"<pre><code>// repo-b/app/build.gradle.kts\ndependencies {\n    implementation(\"com.company.shared:analytics:2.0.0\")\n    commonTestImplementation(\"com.company.shared:analytics-fakes:2.0.0\")\n}\n</code></pre>"},{"location":"multi-module/advanced.html#custom-collector-configurations","title":"Custom Collector Configurations","text":""},{"location":"multi-module/advanced.html#collecting-multiple-producers","title":"Collecting Multiple Producers","text":"<p>One collector can aggregate multiple producers:</p> <pre><code>// Not currently supported - create separate collectors instead\n// Future enhancement: fakt.collectFakesFrom(projects.core.analytics, projects.core.logger)\n\n// Current pattern: One collector per producer\n// :core:analytics-fakes \u2192 collects :core:analytics\n// :core:logger-fakes \u2192 collects :core:logger\n</code></pre>"},{"location":"multi-module/advanced.html#excluding-specific-fakes","title":"Excluding Specific Fakes","text":"<p>Generated fakes are all-or-nothing from a producer. To exclude specific fakes:</p> <p>Option 1: Don\u2019t add <code>@Fake</code> annotation Option 2: Create separate producer modules for different fake groups</p>"},{"location":"multi-module/advanced.html#advanced-dependency-management","title":"Advanced Dependency Management","text":""},{"location":"multi-module/advanced.html#transitive-dependencies","title":"Transitive Dependencies","text":"<p>Collector modules must declare ALL dependencies used by generated fakes:</p> <pre><code>// If generated fakes use:\n// - suspend functions \u2192 kotlinx-coroutines\n// - Flow \u2192 kotlinx-coroutines\n// - Result&lt;T&gt; \u2192 kotlin-stdlib (already included)\n// - Custom types from other modules \u2192 add those modules\n\nkotlin {\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)  // Original interfaces\n        implementation(libs.coroutines)  // Used by suspend fakes\n        implementation(projects.core.logger)  // Used by fakes\n    }\n}\n</code></pre>"},{"location":"multi-module/advanced.html#avoiding-circular-dependencies","title":"Avoiding Circular Dependencies","text":"<p>Problem: Feature A fakes need Feature B, Feature B fakes need Feature A</p> <p>Solution: Extract shared interfaces to core module</p> <pre><code>Before (circular):\nfeatures/payment \u2192 depends on features/user\nfeatures/user \u2192 depends on features/payment\n\nAfter (hierarchical):\ncore/payment-api @Fake interface PaymentProvider\ncore/user-api @Fake interface UserProvider\nfeatures/payment \u2192 depends on core/payment-api, core/user-api\nfeatures/user \u2192 depends on core/user-api, core/payment-api\n</code></pre>"},{"location":"multi-module/advanced.html#experimental-features","title":"Experimental Features","text":""},{"location":"multi-module/advanced.html#platform-specific-collector-targets","title":"Platform-Specific Collector Targets","text":"<p>Limit collector to specific platforms:</p> <pre><code>kotlin {\n    // Only JVM and iOS (skip JS, Native, etc.)\n    jvm()\n    iosArm64()\n\n    // Collector will only generate for these targets\n}\n</code></pre> <p>Use when producer supports many platforms but you only test on a subset.</p>"},{"location":"multi-module/advanced.html#next-steps","title":"Next Steps","text":"<ul> <li>Troubleshooting - Debug common issues</li> <li>Technical Reference - FakeCollectorTask deep dive</li> <li>Migration Guide - Single-module \u2192 Multi-module</li> </ul>"},{"location":"multi-module/getting-started.html","title":"Getting Started with Multi-Module","text":"<p>Set up Fakt multi-module support in 15 minutes with this step-by-step tutorial.</p>"},{"location":"multi-module/getting-started.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>\u2705 Kotlin Multiplatform or JVM project with multiple Gradle modules</li> <li>\u2705 Fakt plugin installed (see Installation)</li> <li>\u2705 Basic understanding of Gradle module structure</li> <li>\u2705 Type-safe project accessors enabled in <code>settings.gradle.kts</code></li> </ul> <p>Type-Safe Project Accessors</p> <p>If you don\u2019t have type-safe accessors enabled, add to <code>settings.gradle.kts</code>: <pre><code>enableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n</code></pre> Then sync Gradle to generate <code>projects.*</code> accessors.</p>"},{"location":"multi-module/getting-started.html#tutorial-overview","title":"Tutorial Overview","text":"<p>We\u2019ll create a simple multi-module setup:</p> <pre><code>my-project/\n\u251c\u2500\u2500 core/analytics/           # Producer (defines @Fake interfaces)\n\u251c\u2500\u2500 core/analytics-fakes/     # Collector (collects generated fakes)\n\u2514\u2500\u2500 app/                      # Consumer (uses fakes in tests)\n</code></pre> <p>Time: ~15 minutes</p>"},{"location":"multi-module/getting-started.html#step-1-create-producer-module","title":"Step 1: Create Producer Module","text":"<p>The producer module contains <code>@Fake</code> annotated interfaces.</p>"},{"location":"multi-module/getting-started.html#create-module-structure","title":"Create Module Structure","text":"<pre><code>mkdir -p core/analytics/src/commonMain/kotlin/com/example/core/analytics\n</code></pre>"},{"location":"multi-module/getting-started.html#configure-buildgradlekts","title":"Configure build.gradle.kts","text":"<pre><code>// core/analytics/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    // Configure your KMP targets\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation(\"com.rsicarelli.fakt:runtime:1.0.0-SNAPSHOT\")\n            }\n        }\n\n        commonTest {\n            dependencies {\n                implementation(kotlin(\"test\"))\n            }\n        }\n    }\n}\n\n// Optional: Enable detailed logging\nfakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.INFO)\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#define-fake-interface","title":"Define @Fake Interface","text":"<pre><code>// core/analytics/src/commonMain/kotlin/com/example/core/analytics/Analytics.kt\npackage com.example.core.analytics\n\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    suspend fun identify(userId: String)\n    val sessionId: String\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#build-the-producer","title":"Build the Producer","text":"<pre><code>./gradlew :core:analytics:build\n</code></pre> <p>Verify: Check that fakes were generated:</p> <pre><code>ls core/analytics/build/generated/fakt/commonTest/kotlin/com/example/core/analytics/\n# Should see:\n# - FakeAnalyticsImpl.kt\n# - fakeAnalytics.kt\n# - FakeAnalyticsConfig.kt\n</code></pre>"},{"location":"multi-module/getting-started.html#step-2-create-collector-module","title":"Step 2: Create Collector Module","text":"<p>The collector module collects generated fakes and makes them available to other modules.</p>"},{"location":"multi-module/getting-started.html#create-module-structure_1","title":"Create Module Structure","text":"<pre><code>mkdir -p core/analytics-fakes/src\n</code></pre> <p>Naming Convention</p> <p>We use <code>-fakes</code> suffix as a recommended convention, but you can name it anything:</p> <ul> <li><code>core/analytics-fakes</code> \u2705 (recommended)</li> <li><code>core/analytics-test</code> \u2705</li> <li><code>core/analytics-test-fixtures</code> \u2705</li> <li><code>test/analytics</code> \u2705</li> </ul>"},{"location":"multi-module/getting-started.html#configure-buildgradlekts_1","title":"Configure build.gradle.kts","text":"<pre><code>// core/analytics-fakes/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    // MUST match producer's targets\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                // CRITICAL: api() exposes original types to consumers\n                api(projects.core.analytics)\n\n                // Add dependencies needed by generated fakes\n                implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.1\")\n            }\n        }\n    }\n}\n\nfakt {\n    // Enable multi-module mode\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n\n    // Optional: Enable detailed logging\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.INFO)\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#key-configuration-points","title":"Key Configuration Points","text":""},{"location":"multi-module/getting-started.html#1-use-api-for-producer-dependency","title":"1. Use <code>api()</code> for Producer Dependency","text":"<pre><code>// \u2705 CORRECT: api() exposes types to consumers\napi(projects.core.analytics)\n\n// \u274c WRONG: implementation() hides types\nimplementation(projects.core.analytics)\n</code></pre> <p>Why: Consumers need access to original interface types (e.g., <code>Analytics</code>). Using <code>api()</code> makes them transitive.</p>"},{"location":"multi-module/getting-started.html#2-match-producers-targets","title":"2. Match Producer\u2019s Targets","text":"<pre><code>// Producer has:\nkotlin {\n    jvm()\n    iosArm64()\n}\n\n// Collector MUST have same targets:\nkotlin {\n    jvm()\n    iosArm64()\n}\n</code></pre> <p>Why: FakeCollectorTask generates platform-specific sources. Mismatched targets cause compilation errors.</p>"},{"location":"multi-module/getting-started.html#3-declare-transitive-dependencies","title":"3. Declare Transitive Dependencies","text":"<p>If generated fakes use coroutines, add:</p> <pre><code>implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.1\")\n</code></pre> <p>Check generated code to identify needed dependencies.</p>"},{"location":"multi-module/getting-started.html#build-the-collector","title":"Build the Collector","text":"<pre><code>./gradlew :core:analytics-fakes:build\n</code></pre> <p>Verify: Check that fakes were collected:</p> <pre><code>ls core/analytics-fakes/build/generated/collected-fakes/commonMain/kotlin/com/example/core/analytics/\n# Should see:\n# - FakeAnalyticsImpl.kt\n# - fakeAnalytics.kt\n# - FakeAnalyticsConfig.kt\n</code></pre>"},{"location":"multi-module/getting-started.html#step-3-register-modules-in-settingsgradlekts","title":"Step 3: Register Modules in settings.gradle.kts","text":"<p>Add both modules to your project:</p> <pre><code>// settings.gradle.kts\nenableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n\nrootProject.name = \"my-project\"\n\ninclude(\":core:analytics\")\ninclude(\":core:analytics-fakes\")\ninclude(\":app\")\n</code></pre> <p>Sync Gradle to generate type-safe accessors (<code>projects.core.analytics</code>, etc.).</p>"},{"location":"multi-module/getting-started.html#step-4-use-fakes-in-consumer-module","title":"Step 4: Use Fakes in Consumer Module","text":"<p>Now use the collected fakes in your app or feature modules.</p>"},{"location":"multi-module/getting-started.html#configure-appbuildgradlekts","title":"Configure app/build.gradle.kts","text":"<pre><code>// app/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                // Main code depends on original interfaces\n                implementation(projects.core.analytics)\n            }\n        }\n\n        commonTest {\n            dependencies {\n                implementation(kotlin(\"test\"))\n\n                // Tests depend on collector module\n                implementation(projects.core.analyticsFakes)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#write-a-test","title":"Write a Test","text":"<pre><code>// app/src/commonTest/kotlin/com/example/app/AppTest.kt\npackage com.example.app\n\nimport com.example.core.analytics.Analytics\nimport kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AppTest {\n    @Test\n    fun `GIVEN analytics fake WHEN tracking event THEN should capture call`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val analytics: Analytics = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n            identify { userId -&gt; println(\"User: $userId\") }\n            sessionId { \"session-123\" }\n        }\n\n        analytics.track(\"user_login\")\n        analytics.track(\"user_signup\")\n\n        assertEquals(listOf(\"user_login\", \"user_signup\"), events)\n        assertEquals(2, analytics.trackCallCount.value)\n    }\n\n    @Test\n    fun `GIVEN analytics fake WHEN getting session THEN returns configured value`() {\n        val analytics = fakeAnalytics {\n            sessionId { \"my-session-id\" }\n        }\n\n        val sessionId = analytics.sessionId\n\n        assertEquals(\"my-session-id\", sessionId)\n        assertEquals(1, analytics.sessionIdCallCount.value)\n    }\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#run-tests","title":"Run Tests","text":"<pre><code>./gradlew :app:test\n</code></pre> <p>Expected: All tests pass \u2705</p>"},{"location":"multi-module/getting-started.html#step-5-verify-the-setup","title":"Step 5: Verify the Setup","text":""},{"location":"multi-module/getting-started.html#build-entire-project","title":"Build Entire Project","text":"<pre><code>./gradlew build\n</code></pre>"},{"location":"multi-module/getting-started.html#check-generated-code-locations","title":"Check Generated Code Locations","text":"<p>Producer (<code>:core:analytics</code>): <pre><code>core/analytics/build/generated/fakt/\n\u251c\u2500\u2500 commonTest/kotlin/com/example/core/analytics/\n\u2502   \u251c\u2500\u2500 FakeAnalyticsImpl.kt\n\u2502   \u251c\u2500\u2500 fakeAnalytics.kt\n\u2502   \u2514\u2500\u2500 FakeAnalyticsConfig.kt\n</code></pre></p> <p>Collector (<code>:core:analytics-fakes</code>): <pre><code>core/analytics-fakes/build/generated/collected-fakes/\n\u251c\u2500\u2500 commonMain/kotlin/com/example/core/analytics/\n\u2502   \u251c\u2500\u2500 FakeAnalyticsImpl.kt\n\u2502   \u251c\u2500\u2500 fakeAnalytics.kt\n\u2502   \u2514\u2500\u2500 FakeAnalyticsConfig.kt\n\u251c\u2500\u2500 jvmMain/kotlin/  (if JVM-specific fakes exist)\n\u2514\u2500\u2500 iosMain/kotlin/  (if iOS-specific fakes exist)\n</code></pre></p> <p>Consumer (<code>:app</code>): - No generated code (uses compiled fakes from collector dependency)</p>"},{"location":"multi-module/getting-started.html#verify-ide-autocomplete","title":"Verify IDE Autocomplete","text":"<p>In your test file, type <code>fake</code> and verify IDE suggests: - <code>fakeAnalytics()</code></p> <p>If not appearing, try: 1. File \u2192 Reload All Gradle Projects 2. File \u2192 Invalidate Caches \u2192 Invalidate and Restart</p>"},{"location":"multi-module/getting-started.html#complete-example-multi-producer-setup","title":"Complete Example: Multi-Producer Setup","text":"<p>Now let\u2019s extend to multiple core modules.</p>"},{"location":"multi-module/getting-started.html#add-more-producers","title":"Add More Producers","text":"<pre><code>mkdir -p core/logger/src/commonMain/kotlin/com/example/core/logger\nmkdir -p core/auth/src/commonMain/kotlin/com/example/core/auth\n</code></pre> <pre><code>// core/logger/src/commonMain/kotlin/Logger.kt\n@Fake\ninterface Logger {\n    fun info(message: String)\n    fun error(message: String)\n}\n\n// core/auth/src/commonMain/kotlin/AuthProvider.kt\n@Fake\ninterface AuthProvider {\n    suspend fun login(credentials: Credentials): Result&lt;User&gt;\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#add-corresponding-collectors","title":"Add Corresponding Collectors","text":"<pre><code>mkdir -p core/logger-fakes/src\nmkdir -p core/auth-fakes/src\n</code></pre> <pre><code>// core/logger-fakes/build.gradle.kts\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.logger)\n}\n\n// core/auth-fakes/build.gradle.kts\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.auth)\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#use-in-consumer","title":"Use in Consumer","text":"<pre><code>// app/build.gradle.kts\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n        implementation(projects.core.loggerFakes)\n        implementation(projects.core.authFakes)\n    }\n}\n</code></pre> <pre><code>// app/src/commonTest/kotlin/LoginTest.kt\n@Test\nfun `GIVEN login flow WHEN user logs in THEN should track and log`() = runTest {\n    // Compose multiple fakes\n    val analytics = fakeAnalytics {\n        track { event -&gt; println(\"Track: $event\") }\n    }\n\n    val logger = fakeLogger {\n        info { message -&gt; println(\"Info: $message\") }\n    }\n\n    val auth = fakeAuthProvider {\n        login { Result.success(User(\"123\", \"Alice\")) }\n    }\n\n    val loginUseCase = LoginUseCase(auth, analytics, logger)\n\n    val result = loginUseCase.execute(Credentials(\"alice\", \"pass\"))\n\n    assertTrue(result.isSuccess)\n    assertEquals(1, analytics.trackCallCount.value)\n    assertEquals(1, logger.infoCallCount.value)\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"multi-module/getting-started.html#pattern-1-type-safe-project-accessors-recommended","title":"Pattern 1: Type-Safe Project Accessors (Recommended)","text":"<pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Benefits: - IDE autocomplete - Compile-time safety - Refactoring support</p>"},{"location":"multi-module/getting-started.html#pattern-2-string-based-paths","title":"Pattern 2: String-Based Paths","text":"<pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(project(\":core:analytics\"))\n}\n</code></pre> <p>Use When: - Type-safe accessors not available - Dynamic module names - Cross-project references</p>"},{"location":"multi-module/getting-started.html#pattern-3-with-custom-logging","title":"Pattern 3: With Custom Logging","text":"<pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.DEBUG)\n\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Log Levels: - <code>QUIET</code> - Zero output (CI/CD) - <code>INFO</code> - Concise summary (default) - <code>DEBUG</code> - Detailed breakdown - <code>TRACE</code> - Full IR details</p>"},{"location":"multi-module/getting-started.html#version-catalog-integration","title":"Version Catalog Integration","text":"<p>Centralize versions using Gradle version catalogs:</p>"},{"location":"multi-module/getting-started.html#gradlelibsversionstoml","title":"gradle/libs.versions.toml","text":"<pre><code>[versions]\nfakt = \"1.0.0-SNAPSHOT\"\nkotlin = \"2.2.20\"\ncoroutines = \"1.10.1\"\n\n[plugins]\nkotlin-multiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nfakt = { id = \"com.rsicarelli.fakt\", version.ref = \"fakt\" }\n\n[libraries]\nfakt-runtime = { module = \"com.rsicarelli.fakt:runtime\", version.ref = \"fakt\" }\ncoroutines = { module = \"org.jetbrains.kotlinx:kotlinx-coroutines-core\", version.ref = \"coroutines\" }\n</code></pre>"},{"location":"multi-module/getting-started.html#using-in-buildgradlekts","title":"Using in build.gradle.kts","text":"<pre><code>// Producer\nplugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\ndependencies {\n    commonMainImplementation(libs.fakt.runtime)\n}\n\n// Collector\nkotlin {\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)\n        implementation(libs.coroutines)\n    }\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#troubleshooting-quick-guide","title":"Troubleshooting Quick Guide","text":""},{"location":"multi-module/getting-started.html#issue-no-fakes-found-in-source-module","title":"Issue: \u201cNo fakes found in source module\u201d","text":"<p>Cause: Producer module has no <code>@Fake</code> interfaces or they weren\u2019t generated.</p> <p>Solution: 1. Verify <code>@Fake</code> annotation exists: <pre><code>grep -r \"@Fake\" core/analytics/src/\n</code></pre> 2. Check fakes were generated: <pre><code>ls core/analytics/build/generated/fakt/\n</code></pre> 3. Rebuild producer: <pre><code>./gradlew :core:analytics:clean :core:analytics:build\n</code></pre></p>"},{"location":"multi-module/getting-started.html#issue-unresolved-reference-fakeanalytics","title":"Issue: \u201cUnresolved reference: fakeAnalytics\u201d","text":"<p>Cause: Consumer doesn\u2019t depend on collector module.</p> <p>Solution: 1. Add dependency in consumer\u2019s <code>build.gradle.kts</code>: <pre><code>commonTestImplementation(projects.core.analyticsFakes)\n</code></pre> 2. Sync Gradle and rebuild: <pre><code>./gradlew --refresh-dependencies build\n</code></pre></p>"},{"location":"multi-module/getting-started.html#issue-targets-mismatch-error","title":"Issue: Targets Mismatch Error","text":"<p>Error: <code>Cannot find source set 'iosMain'</code></p> <p>Cause: Collector has different targets than producer.</p> <p>Solution: Ensure collector has ALL producer\u2019s targets:</p> <pre><code>// Producer\nkotlin {\n    jvm()\n    iosArm64()\n}\n\n// Collector MUST match\nkotlin {\n    jvm()\n    iosArm64()\n}\n</code></pre> <p>For more issues, see Troubleshooting Guide.</p>"},{"location":"multi-module/getting-started.html#next-steps","title":"Next Steps","text":"<p>You\u2019ve successfully set up multi-module support! \ud83c\udf89</p> <p>Explore advanced topics:</p> <ul> <li>Advanced Topics - Platform detection, performance tuning, publishing</li> <li>Troubleshooting - Comprehensive debugging guide</li> <li>Migration Guide - Migrate existing single-module projects</li> <li>Technical Reference - FakeCollectorTask internals</li> </ul>"},{"location":"multi-module/getting-started.html#complete-build-configuration-example","title":"Complete Build Configuration Example","text":"<p>Here\u2019s a complete working example with all three modules:</p>"},{"location":"multi-module/getting-started.html#settingsgradlekts","title":"settings.gradle.kts","text":"<pre><code>pluginManagement {\n    repositories {\n        mavenCentral()\n        gradlePluginPortal()\n        mavenLocal()  // For SNAPSHOT versions\n    }\n}\n\ndependencyResolutionManagement {\n    repositories {\n        mavenCentral()\n        mavenLocal()\n    }\n}\n\nenableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n\nrootProject.name = \"my-project\"\n\ninclude(\":core:analytics\")\ninclude(\":core:analytics-fakes\")\ninclude(\":app\")\n</code></pre>"},{"location":"multi-module/getting-started.html#coreanalyticsbuildgradlekts-producer","title":"core/analytics/build.gradle.kts (Producer)","text":"<pre><code>plugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation(\"com.rsicarelli.fakt:runtime:1.0.0-SNAPSHOT\")\n            }\n        }\n        commonTest {\n            dependencies {\n                implementation(kotlin(\"test\"))\n            }\n        }\n    }\n}\n\nfakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.INFO)\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#coreanalytics-fakesbuildgradlekts-collector","title":"core/analytics-fakes/build.gradle.kts (Collector)","text":"<pre><code>plugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets.commonMain {\n        dependencies {\n            api(projects.core.analytics)\n            implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.1\")\n        }\n    }\n}\n\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.INFO)\n}\n</code></pre>"},{"location":"multi-module/getting-started.html#appbuildgradlekts-consumer","title":"app/build.gradle.kts (Consumer)","text":"<pre><code>plugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                implementation(projects.core.analytics)\n            }\n        }\n        commonTest {\n            dependencies {\n                implementation(kotlin(\"test\"))\n                implementation(projects.core.analyticsFakes)\n                implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.1\")\n            }\n        }\n    }\n}\n</code></pre> <p>Copy these configurations and adjust package names to match your project!</p>"},{"location":"multi-module/migration.html","title":"Migration Guide","text":"<p>Migrate from single-module to multi-module fake consumption.</p>"},{"location":"multi-module/migration.html#when-to-migrate","title":"When to Migrate","text":""},{"location":"multi-module/migration.html#decision-criteria","title":"Decision Criteria","text":"<p>\u2705 Migrate to Multi-Module When: - 3+ modules need the same fakes - Publishing fake artifacts - Strict module boundaries (DDD, Clean Architecture) - Large teams (dedicated module ownership)</p> <p>\u274c Stay Single-Module When: - 1-2 modules total - Fakes only used locally - Small team or prototype - Prefer simplicity over reuse</p>"},{"location":"multi-module/migration.html#costbenefit-analysis","title":"Cost/Benefit Analysis","text":"Aspect Single-Module Multi-Module Setup Time 0 minutes ~30-60 minutes Build Modules N modules N + N collector modules Build Time Baseline +5-10ms per collector Fake Reuse None Full cross-module reuse Publishability No Yes (Maven, etc.)"},{"location":"multi-module/migration.html#migration-strategies","title":"Migration Strategies","text":""},{"location":"multi-module/migration.html#strategy-1-big-bang-all-at-once","title":"Strategy 1: Big Bang (All at Once)","text":"<p>Timeline: 1-2 days</p> <p>Process: 1. Create all collector modules 2. Update all consumer dependencies 3. Test entire project 4. Deploy together</p> <p>Best for: Small projects (&lt; 10 modules), dedicated migration time</p>"},{"location":"multi-module/migration.html#strategy-2-gradual-module-by-module","title":"Strategy 2: Gradual (Module by Module)","text":"<p>Timeline: 1-4 weeks</p> <p>Process: 1. Week 1: Core infrastructure (logger, analytics, etc.) 2. Week 2: Foundation features (auth, storage) 3. Week 3: Business features 4. Week 4: Polish, optimize, document</p> <p>Best for: Large projects, continuous delivery, risk aversion</p>"},{"location":"multi-module/migration.html#strategy-3-hybrid-mixed","title":"Strategy 3: Hybrid (Mixed)","text":"<p>Keep some single-module, migrate others</p> <p>Process: - Migrate frequently-shared fakes (core/logger, core/analytics) - Keep feature-specific fakes single-module</p> <p>Best for: Mixed module ownership, gradual rollout</p>"},{"location":"multi-module/migration.html#step-by-step-migration","title":"Step-by-Step Migration","text":""},{"location":"multi-module/migration.html#phase-1-preparation-30-minutes","title":"Phase 1: Preparation (30 minutes)","text":""},{"location":"multi-module/migration.html#1-enable-type-safe-project-accessors-optional","title":"1. Enable Type-Safe Project Accessors (Optional)","text":"<pre><code>// settings.gradle.kts\nenableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n</code></pre> <p>Sync Gradle to generate <code>projects.*</code> accessors.</p>"},{"location":"multi-module/migration.html#2-identify-fake-candidates","title":"2. Identify Fake Candidates","text":"<pre><code># Find all @Fake interfaces\nfind . -name \"*.kt\" -exec grep -l \"@Fake\" {} \\;\n\n# Group by module\n# - High reuse: core/logger (10+ consumers)\n# - Medium reuse: core/auth (5+ consumers)\n# - Low reuse: features/profile (1-2 consumers)\n</code></pre> <p>Prioritize: High reuse modules first</p>"},{"location":"multi-module/migration.html#phase-2-create-collectors-15-minutes-per-module","title":"Phase 2: Create Collectors (15 minutes per module)","text":""},{"location":"multi-module/migration.html#1-create-collector-module-directory","title":"1. Create Collector Module Directory","text":"<pre><code># Example: core/analytics \u2192 core/analytics-fakes\nmkdir -p core/analytics-fakes/src\n</code></pre>"},{"location":"multi-module/migration.html#2-create-buildgradlekts","title":"2. Create build.gradle.kts","text":"<pre><code>// core/analytics-fakes/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.20\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-SNAPSHOT\"\n}\n\nkotlin {\n    // MUST match producer's targets\n    jvm()\n    iosArm64()\n    // ... all other targets from producer\n\n    sourceSets.commonMain.dependencies {\n        // Use api() to expose types\n        api(projects.core.analytics)\n\n        // Add transitive dependencies\n        implementation(libs.coroutines)\n    }\n}\n\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"multi-module/migration.html#3-register-in-settingsgradlekts","title":"3. Register in settings.gradle.kts","text":"<pre><code>include(\":core:analytics-fakes\")\n</code></pre>"},{"location":"multi-module/migration.html#4-build-and-verify","title":"4. Build and Verify","text":"<pre><code>./gradlew :core:analytics-fakes:build\n\n# Verify fakes collected\nls core/analytics-fakes/build/generated/collected-fakes/\n</code></pre>"},{"location":"multi-module/migration.html#phase-3-update-consumers-5-minutes-per-module","title":"Phase 3: Update Consumers (5 minutes per module)","text":""},{"location":"multi-module/migration.html#1-update-dependencies","title":"1. Update Dependencies","text":"<pre><code>// Before (single-module)\nkotlin {\n    sourceSets.commonTest.dependencies {\n        // No dependency - fakes generated locally\n    }\n}\n\n// After (multi-module)\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre>"},{"location":"multi-module/migration.html#2-test-imports","title":"2. Test Imports","text":"<pre><code>// Before (single-module)\nimport com.example.core.analytics.fakeAnalytics  // Local generated\n\n// After (multi-module)\nimport com.example.core.analytics.fakeAnalytics  // From collector dependency\n// \u2191 Import path unchanged! Fakes use same package as original interface\n</code></pre>"},{"location":"multi-module/migration.html#3-verify-tests-pass","title":"3. Verify Tests Pass","text":"<pre><code>./gradlew :app:test\n</code></pre>"},{"location":"multi-module/migration.html#phase-4-cleanup-optional","title":"Phase 4: Cleanup (Optional)","text":""},{"location":"multi-module/migration.html#1-remove-unused-test-code","title":"1. Remove Unused Test Code","text":"<p>If producer module no longer needs its own fakes:</p> <pre><code>// core/analytics/build.gradle.kts\n// Can remove Fakt plugin if only used for generation\n// Keep if producer's own tests use fakes\n</code></pre>"},{"location":"multi-module/migration.html#2-update-documentation","title":"2. Update Documentation","text":"<p>Update README, wiki, or docs to reflect multi-module setup.</p>"},{"location":"multi-module/migration.html#migration-examples","title":"Migration Examples","text":""},{"location":"multi-module/migration.html#example-1-core-logger-high-reuse","title":"Example 1: Core Logger (High Reuse)","text":"<p>Before: <pre><code>core/logger/\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 commonMain/kotlin/Logger.kt (@Fake)\n    \u2514\u2500\u2500 commonTest/kotlin/  (fakes generated here, not shared)\n\nfeatures/login/\n\u2514\u2500\u2500 src/commonTest/kotlin/  (no access to logger fakes)\n\nfeatures/checkout/\n\u2514\u2500\u2500 src/commonTest/kotlin/  (no access to logger fakes)\n</code></pre></p> <p>After: <pre><code>core/logger/\n\u2514\u2500\u2500 src/commonMain/kotlin/Logger.kt (@Fake)\n\ncore/logger-fakes/\n\u2514\u2500\u2500 build/generated/collected-fakes/  (fakes collected here)\n\nfeatures/login/\n\u2514\u2500\u2500 build.gradle.kts: implementation(projects.core.loggerFakes)\n\nfeatures/checkout/\n\u2514\u2500\u2500 build.gradle.kts: implementation(projects.core.loggerFakes)\n</code></pre></p> <p>Benefits: 2+ feature modules now share logger fakes</p>"},{"location":"multi-module/migration.html#example-2-feature-module-low-reuse","title":"Example 2: Feature Module (Low Reuse)","text":"<p>Decision: Keep single-module (not worth migration overhead)</p> <pre><code>features/profile/\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 commonMain/kotlin/ProfileService.kt (@Fake)\n    \u2514\u2500\u2500 commonTest/kotlin/  (fakes used only here)\n\n# No collector module created\n# Fakes stay local\n</code></pre>"},{"location":"multi-module/migration.html#rollback-procedure","title":"Rollback Procedure","text":"<p>If migration causes issues:</p>"},{"location":"multi-module/migration.html#1-revert-consumer-dependencies","title":"1. Revert Consumer Dependencies","text":"<pre><code>// Remove collector dependency\nkotlin {\n    sourceSets.commonTest.dependencies {\n        // implementation(projects.core.analyticsFakes)  // \u2190 Comment out\n    }\n}\n</code></pre>"},{"location":"multi-module/migration.html#2-re-enable-local-fake-generation","title":"2. Re-enable Local Fake Generation","text":"<p>Producer module already generates fakes locally. Just use them:</p> <pre><code>// core/analytics/build.gradle.kts\n// Plugin already present - fakes still generated locally\n</code></pre>"},{"location":"multi-module/migration.html#3-rebuild","title":"3. Rebuild","text":"<pre><code>./gradlew clean build\n</code></pre>"},{"location":"multi-module/migration.html#4-remove-collector-modules-optional","title":"4. Remove Collector Modules (Optional)","text":"<pre><code>rm -rf core/analytics-fakes/\n</code></pre> <pre><code>// settings.gradle.kts\n// include(\":core:analytics-fakes\")  // \u2190 Comment out\n</code></pre>"},{"location":"multi-module/migration.html#gradual-migration-timeline","title":"Gradual Migration Timeline","text":""},{"location":"multi-module/migration.html#4-week-plan-large-project","title":"4-Week Plan (Large Project)","text":"<p>Week 1: Core Infrastructure - [ ] Create collectors for: logger, analytics, network, storage - [ ] Update 3-5 high-priority consumers - [ ] Test integration - [ ] Document patterns</p> <p>Week 2: Foundation Features - [ ] Create collectors for: auth, config, database - [ ] Update remaining core consumers - [ ] Test cross-module dependencies</p> <p>Week 3: Business Features - [ ] Create collectors for: login, checkout, profile - [ ] Update all feature module tests - [ ] Remove local fake duplicates</p> <p>Week 4: Polish &amp; Optimize - [ ] Tune build cache - [ ] Optimize task dependencies - [ ] Update CI/CD pipelines - [ ] Team training &amp; documentation</p>"},{"location":"multi-module/migration.html#common-migration-patterns","title":"Common Migration Patterns","text":""},{"location":"multi-module/migration.html#pattern-1-version-catalog-updates","title":"Pattern 1: Version Catalog Updates","text":"<pre><code># gradle/libs.versions.toml\n\n# Before\n[libraries]\ncore-analytics = { module = \"com.example:core-analytics\", version = \"1.0.0\" }\n\n# After (add fake modules)\n[libraries]\ncore-analytics = { module = \"com.example:core-analytics\", version = \"1.0.0\" }\ncore-analytics-fakes = { module = \"com.example:core-analytics-fakes\", version = \"1.0.0\" }\n</code></pre>"},{"location":"multi-module/migration.html#pattern-2-convention-plugin","title":"Pattern 2: Convention Plugin","text":"<p>Create plugin for collector boilerplate:</p> <pre><code>// buildSrc/src/main/kotlin/fakt-collector.gradle.kts\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.rsicarelli.fakt\")\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n}\n\n// Apply to collectors\n// core/analytics-fakes/build.gradle.kts\nplugins {\n    id(\"fakt-collector\")\n}\n\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"multi-module/migration.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Multi-module setup guide</li> <li>Troubleshooting - Common migration issues</li> <li>Advanced Topics - Performance optimization</li> </ul>"},{"location":"multi-module/reference.html","title":"Technical Reference","text":"<p>Deep technical documentation for FakeCollectorTask and multi-module internals.</p>"},{"location":"multi-module/reference.html#fakecollectortask","title":"FakeCollectorTask","text":"<p>The core component responsible for collecting generated fakes from producer modules.</p>"},{"location":"multi-module/reference.html#overview","title":"Overview","text":"<pre><code>package com.rsicarelli.fakt.gradle\n\nabstract class FakeCollectorTask : DefaultTask() {\n    @Input abstract val sourceProjectPath: Property&lt;String&gt;\n    @Internal abstract val sourceGeneratedDir: DirectoryProperty\n    @OutputDirectory abstract val destinationDir: DirectoryProperty\n    @Input abstract val availableSourceSets: SetProperty&lt;String&gt;\n    @Input abstract val logLevel: Property&lt;LogLevel&gt;\n\n    @TaskAction\n    fun collectFakes() { /* ... */ }\n}\n</code></pre>"},{"location":"multi-module/reference.html#task-properties","title":"Task Properties","text":""},{"location":"multi-module/reference.html#sourceprojectpath","title":"sourceProjectPath","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Description: Gradle path to producer module</p> <p>Example: <code>\":core:analytics\"</code></p> <p>Configuration: <pre><code>// Via collectFakesFrom()\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre></p>"},{"location":"multi-module/reference.html#sourcegenerateddir","title":"sourceGeneratedDir","text":"<p>Type: <code>DirectoryProperty</code></p> <p>Description: Root directory of generated fakes in producer</p> <p>Example: <code>core/analytics/build/generated/fakt/</code></p> <p>Auto-detected from source project\u2019s build directory.</p>"},{"location":"multi-module/reference.html#destinationdir","title":"destinationDir","text":"<p>Type: <code>DirectoryProperty</code></p> <p>Description: Root directory for collected fakes in collector</p> <p>Example: <code>core/analytics-fakes/build/generated/collected-fakes/</code></p> <p>Auto-configured based on collector\u2019s build directory.</p>"},{"location":"multi-module/reference.html#availablesourcesets","title":"availableSourceSets","text":"<p>Type: <code>SetProperty&lt;String&gt;</code></p> <p>Description: All KMP source sets available in collector module</p> <p>Example: <code>[\"commonMain\", \"jvmMain\", \"iosMain\", \"iosArm64Main\"]</code></p> <p>Auto-detected from collector\u2019s Kotlin multiplatform configuration.</p>"},{"location":"multi-module/reference.html#loglevel","title":"logLevel","text":"<p>Type: <code>Property&lt;LogLevel&gt;</code></p> <p>Description: Logging verbosity</p> <p>Values: - <code>LogLevel.QUIET</code> - No output - <code>LogLevel.INFO</code> - Summary (default) - <code>LogLevel.DEBUG</code> - Detailed - <code>LogLevel.TRACE</code> - Everything</p>"},{"location":"multi-module/reference.html#platform-detection-algorithm","title":"Platform Detection Algorithm","text":""},{"location":"multi-module/reference.html#implementation","title":"Implementation","text":"<pre><code>fun determinePlatformSourceSet(\n    fileContent: String,\n    availableSourceSets: Set&lt;String&gt;\n): String {\n    // 1. Extract package declaration (first 10 lines)\n    val packageDeclaration = fileContent\n        .lines()\n        .take(10)\n        .firstOrNull { it.trim().startsWith(\"package \") }\n        ?.removePrefix(\"package \")\n        ?.trim()\n        ?: return \"commonMain\"\n\n    // 2. Split into segments\n    val segments = packageDeclaration.split(\".\")\n\n    // 3. Find matching source sets\n    val matches = segments.flatMap { segment -&gt;\n        availableSourceSets\n            .filter { sourceSet -&gt;\n                sourceSet.startsWith(segment, ignoreCase = true) &amp;&amp; \n                sourceSet.endsWith(\"Main\")\n            }\n            .map { it to segment }\n    }.distinct()\n\n    // 4. Return shortest match (most general)\n    return matches.minByOrNull { (sourceSet, _) -&gt; sourceSet.length }?.first\n        ?: \"commonMain\"\n}\n</code></pre>"},{"location":"multi-module/reference.html#examples","title":"Examples","text":""},{"location":"multi-module/reference.html#example-1-jvm-specific-package","title":"Example 1: JVM-Specific Package","text":"<pre><code>// Input\npackage com.example.jvm.database\n\n// Process\nsegments = [\"com\", \"example\", \"jvm\", \"database\"]\navailableSourceSets = [\"commonMain\", \"jvmMain\", \"iosMain\"]\n\n// Matching\n\"jvm\" matches \"jvmMain\" (starts with \"jvm\", ends with \"Main\")\n\n// Output\n\"jvmMain\"\n</code></pre>"},{"location":"multi-module/reference.html#example-2-ios-with-multiple-variants","title":"Example 2: iOS with Multiple Variants","text":"<pre><code>// Input\npackage com.example.ios.camera\n\n// Process\nsegments = [\"com\", \"example\", \"ios\", \"camera\"]\navailableSourceSets = [\"commonMain\", \"iosMain\", \"iosArm64Main\", \"iosX64Main\", \"iosSimulatorArm64Main\"]\n\n// Matching\n\"ios\" matches:\n- \"iosMain\" (length: 7)\n- \"iosArm64Main\" (length: 13)\n- \"iosX64Main\" (length: 10)\n- \"iosSimulatorArm64Main\" (length: 22)\n\n// Output (shortest)\n\"iosMain\"\n</code></pre>"},{"location":"multi-module/reference.html#example-3-no-match-fallback","title":"Example 3: No Match (Fallback)","text":"<pre><code>// Input\npackage com.example.business.logic\n\n// Process\nsegments = [\"com\", \"example\", \"business\", \"logic\"]\navailableSourceSets = [\"commonMain\", \"jvmMain\", \"jsMain\"]\n\n// Matching\nNo segment matches any source set\n\n// Output (fallback)\n\"commonMain\"\n</code></pre>"},{"location":"multi-module/reference.html#task-registration","title":"Task Registration","text":""},{"location":"multi-module/reference.html#kmp-projects","title":"KMP Projects","text":"<pre><code>companion object {\n    fun registerForKmpProject(\n        project: Project,\n        extension: FaktPluginExtension\n    ) {\n        val kotlin = project.extensions.getByType&lt;KotlinMultiplatformExtension&gt;()\n\n        kotlin.targets.all { target -&gt;\n            target.compilations.all { compilation -&gt;\n                val taskName = \"collectFakes${target.name.capitalize()}${compilation.name.capitalize()}\"\n\n                val task = project.tasks.register&lt;FakeCollectorTask&gt;(taskName) {\n                    group = \"fakt\"\n                    description = \"Collect fakes from ${extension.collectFrom.get()}\"\n\n                    sourceProjectPath.set(extension.collectFrom)\n                    logLevel.set(extension.logLevel)\n\n                    // Auto-detect source sets\n                    availableSourceSets.set(\n                        kotlin.sourceSets.names.filter { it.endsWith(\"Main\") }.toSet()\n                    }\n\n                    // Wire dependencies\n                    dependsOn(sourceProject.tasks.matching { /* compile tasks */ })\n                }\n\n                // Register collected sources\n                compilation.defaultSourceSet.kotlin.srcDir(\n                    task.flatMap { it.destinationDir }\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"multi-module/reference.html#task-dependencies","title":"Task Dependencies","text":""},{"location":"multi-module/reference.html#automatic-wiring","title":"Automatic Wiring","text":"<p>FakeCollectorTask automatically depends on producer\u2019s compilation tasks:</p> <pre><code>// Pseudo-code\nsourceProject.tasks.matching { task -&gt;\n    task.name.contains(\"compile\", ignoreCase = true) &amp;&amp;\n    !task.name.contains(\"test\", ignoreCase = true)  // Skip test compilations\n}.forEach { compileTask -&gt;\n    collectTask.dependsOn(compileTask)\n}\n</code></pre> <p>Why skip test compilations? - Test compilations may depend on collector modules (circular) - Main compilations generate fakes (contain <code>@Fake</code> annotations) - Test compilations use fakes (contain test code)</p>"},{"location":"multi-module/reference.html#configuration-cache-compatibility","title":"Configuration Cache Compatibility","text":"<p>Fakt is fully compatible with Gradle configuration cache:</p> <pre><code>./gradlew build --configuration-cache\n</code></pre>"},{"location":"multi-module/reference.html#implementation_1","title":"Implementation","text":"<pre><code>abstract class FakeCollectorTask : DefaultTask() {\n    // \u2705 Use Property&lt;T&gt; (serializable)\n    @Input abstract val sourceProjectPath: Property&lt;String&gt;\n\n    // \u2705 Use DirectoryProperty (serializable)\n    @OutputDirectory abstract val destinationDir: DirectoryProperty\n\n    // \u274c Don't use Project references (not serializable)\n    // private lateinit var project: Project  // Would break config cache\n}\n</code></pre>"},{"location":"multi-module/reference.html#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"multi-module/reference.html#time-complexity","title":"Time Complexity","text":"<ul> <li>File discovery: O(n) where n = number of generated files</li> <li>Package extraction: O(1) per file (only reads first 10 lines)</li> <li>Platform detection: O(m * k) where m = package segments, k = source sets</li> <li>File copy: O(n) where n = number of files</li> </ul>"},{"location":"multi-module/reference.html#space-complexity","title":"Space Complexity","text":"<ul> <li>Memory: O(n) for file list</li> <li>Disk: 2x (original + collected)</li> </ul>"},{"location":"multi-module/reference.html#optimization","title":"Optimization","text":"<p>Incremental: Only reprocesses changed files</p> <pre><code># First build\ncollectFakes: 40ms (100 files)\n\n# No changes\ncollectFakes: UP-TO-DATE (0ms)\n\n# 1 file changed\ncollectFakes: 5ms (1 file reprocessed)\n</code></pre>"},{"location":"multi-module/reference.html#api-reference","title":"API Reference","text":""},{"location":"multi-module/reference.html#collectfakesfrom","title":"collectFakesFrom()","text":"<pre><code>// Extension method on FaktPluginExtension\n\n// Option 1: Type-safe project accessor\n@ExperimentalFaktMultiModule\nfun collectFakesFrom(project: ProjectDependency)\n\n// Option 2: Traditional project reference\n@ExperimentalFaktMultiModule\nfun collectFakesFrom(project: Project)\n</code></pre> <p>Both approaches are equally valid - choose based on preference: - Type-safe accessors: Better IDE support, requires <code>TYPESAFE_PROJECT_ACCESSORS</code> - Traditional: Works everywhere, no feature preview needed</p> <p>Example (type-safe): <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre></p> <p>Example (traditional): <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(project(\":core:analytics\"))\n}\n</code></pre></p>"},{"location":"multi-module/reference.html#gradle-integration","title":"Gradle Integration","text":""},{"location":"multi-module/reference.html#plugin-lifecycle","title":"Plugin Lifecycle","text":"<pre><code>1. Plugin applied: FaktGradleSubplugin.apply(project)\n   \u2193\n2. Extension created: project.extensions.create&lt;FaktPluginExtension&gt;(\"fakt\")\n   \u2193\n3. Configuration phase: User configures collectFakesFrom()\n   \u2193\n4. afterEvaluate: Mode detection (collector vs generator)\n   \u2193\n5. Task registration: FakeCollectorTask.registerForKmpProject()\n   \u2193\n6. Execution phase: collectFakes task runs\n   \u2193\n7. Compilation: Collector compiles collected fakes\n</code></pre>"},{"location":"multi-module/reference.html#source-set-registration","title":"Source Set Registration","text":"<p>Collected fakes are registered as source roots:</p> <pre><code>compilation.defaultSourceSet.kotlin.srcDir(\n    task.flatMap { it.destinationDir }\n)\n</code></pre> <p>Result: IDE and compiler recognize collected fakes as first-class sources.</p>"},{"location":"multi-module/reference.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Setup guide</li> <li>Advanced Topics - Platform detection deep dive</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"multi-module/troubleshooting.html","title":"Troubleshooting","text":"<p>Common issues and solutions for multi-module setups.</p>"},{"location":"multi-module/troubleshooting.html#diagnosis-tools","title":"Diagnosis Tools","text":""},{"location":"multi-module/troubleshooting.html#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.DEBUG)\n}\n</code></pre> <p>Rebuild to see detailed output:</p> <pre><code>./gradlew :core:analytics-fakes:clean :core:analytics-fakes:build --info\n</code></pre>"},{"location":"multi-module/troubleshooting.html#check-task-execution","title":"Check Task Execution","text":"<p>View task dependency graph:</p> <pre><code>./gradlew :core:analytics-fakes:build --dry-run\n</code></pre>"},{"location":"multi-module/troubleshooting.html#use-build-scans","title":"Use Build Scans","text":"<pre><code>./gradlew build --scan\n</code></pre>"},{"location":"multi-module/troubleshooting.html#common-issues","title":"Common Issues","text":""},{"location":"multi-module/troubleshooting.html#issue-1-no-fakes-found-in-source-module","title":"Issue 1: \u201cNo fakes found in source module\u201d","text":"<p>Error: <pre><code>No fakes found in source module 'analytics'.\nVerify that source module has @Fake annotated interfaces.\n</code></pre></p> <p>Causes: 1. Source module has no <code>@Fake</code> interfaces 2. Fakes not generated (compilation failed) 3. Wrong module path in <code>collectFakesFrom()</code></p> <p>Diagnosis:</p> <pre><code># Check for @Fake annotations\ngrep -r \"@Fake\" core/analytics/src/\n\n# Verify fakes were generated  \nls core/analytics/build/generated/fakt/\n\n# Check for compilation errors\n./gradlew :core:analytics:build\n</code></pre> <p>Solutions:</p> <pre><code>// \u2705 CORRECT: Collect from producer (has @Fake interfaces)\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)  \n}\n\n// \u274c WRONG: Collecting from collector (no @Fake interfaces)\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analyticsFakes)  // Wrong!\n}\n</code></pre>"},{"location":"multi-module/troubleshooting.html#issue-2-unresolved-reference-fakexxx","title":"Issue 2: \u201cUnresolved reference: fakeXxx\u201d","text":"<p>Error: <pre><code>// In test file\nval fake = fakeAnalytics { }  // \u2190 Unresolved reference\n</code></pre></p> <p>Causes: 1. Consumer doesn\u2019t depend on collector module 2. Collector module not built 3. IDE not synced 4. Wrong import</p> <p>Diagnosis:</p> <pre><code># Check dependency in consumer\ngrep \"analyticsFakes\" app/build.gradle.kts\n\n# Verify collector was built\nls core/analytics-fakes/build/generated/collected-fakes/\n\n# Check for factory function\ngrep -r \"fun fakeAnalytics\" core/analytics-fakes/build/\n</code></pre> <p>Solutions:</p> <pre><code>// 1. Add dependency to consumer\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n\n// 2. Sync Gradle and rebuild\n./gradlew --refresh-dependencies build\n\n// 3. Invalidate IDE caches\n// File \u2192 Invalidate Caches \u2192 Invalidate and Restart\n</code></pre>"},{"location":"multi-module/troubleshooting.html#issue-3-targets-mismatch","title":"Issue 3: Targets Mismatch","text":"<p>Error: <pre><code>Cannot find source set 'iosMain' for target 'iosX64'\n</code></pre></p> <p>Cause: Collector has different targets than producer</p> <p>Diagnosis:</p> <pre><code>// Check producer targets\n// core/analytics/build.gradle.kts\nkotlin {\n    jvm()\n    iosArm64()  // \u2190 Producer has this\n}\n\n// Check collector targets\n// core/analytics-fakes/build.gradle.kts\nkotlin {\n    jvm()\n    // Missing: iosArm64()  \u2190 Collector doesn't!\n}\n</code></pre> <p>Solution: Collector MUST have ALL producer\u2019s targets</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nkotlin {\n    jvm()\n    iosArm64()  // \u2705 Added\n    iosX64()\n    iosSimulatorArm64()\n}\n</code></pre>"},{"location":"multi-module/troubleshooting.html#issue-4-wrong-platform-placement","title":"Issue 4: Wrong Platform Placement","text":"<p>Symptom: Fake ends up in wrong source set (e.g., <code>commonMain</code> instead of <code>jvmMain</code>)</p> <p>Cause: Package doesn\u2019t contain platform identifier</p> <p>Diagnosis:</p> <pre><code>// Check generated fake's package\n// core/analytics/build/generated/fakt/jvmTest/kotlin/DatabaseFake.kt\npackage com.example.database  // \u2190 No \"jvm\" segment!\n</code></pre> <p>Solution: Use platform identifier in package name</p> <pre><code>// \u2705 CORRECT: Platform in package\npackage com.example.jvm.database  // \u2192 jvmMain/\npackage com.example.ios.camera    // \u2192 iosMain/\n\n// \u274c WRONG: No platform identifier\npackage com.example.database  // \u2192 commonMain/ (fallback)\n</code></pre>"},{"location":"multi-module/troubleshooting.html#issue-5-circular-dependencies","title":"Issue 5: Circular Dependencies","text":"<p>Error: <pre><code>Circular dependency between:\n:features:payment\n:features:user\n</code></pre></p> <p>Cause: Feature A fakes need Feature B, Feature B fakes need Feature A</p> <p>Solution: Extract shared interfaces to core modules</p> <pre><code>Before (circular):\nfeatures/payment \u2192 features/user\nfeatures/user \u2192 features/payment\n\nAfter (fixed):\ncore/payment-api @Fake interface PaymentProvider\ncore/user-api @Fake interface UserProvider\n\nfeatures/payment \u2192 core/payment-api, core/user-api\nfeatures/user \u2192 core/user-api, core/payment-api\n</code></pre>"},{"location":"multi-module/troubleshooting.html#issue-6-missing-transitive-dependencies","title":"Issue 6: Missing Transitive Dependencies","text":"<p>Error: <pre><code>// In test\nval fake = fakeAnalytics { }  // Compiles\n\n// But runtime error:\nNoClassDefFoundError: kotlinx/coroutines/CoroutineScope\n</code></pre></p> <p>Cause: Collector didn\u2019t declare coroutines dependency</p> <p>Solution:</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nkotlin {\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)\n        implementation(libs.coroutines)  // \u2705 Add this\n    }\n}\n</code></pre> <p>How to identify needed dependencies:</p> <pre><code># Inspect generated code\ncat core/analytics-fakes/build/generated/collected-fakes/commonMain/kotlin/FakeAnalyticsImpl.kt\n\n# Look for imports:\nimport kotlinx.coroutines.*  # \u2192 Need coroutines\nimport kotlinx.serialization.*  # \u2192 Need serialization\n</code></pre>"},{"location":"multi-module/troubleshooting.html#issue-7-ide-not-finding-fakes","title":"Issue 7: IDE Not Finding Fakes","text":"<p>Symptom: Autocomplete doesn\u2019t suggest <code>fakeXxx()</code>, but code compiles</p> <p>Causes: 1. IDE not synced with Gradle 2. Generated sources not indexed 3. Stale IDE caches</p> <p>Solutions:</p> <pre><code># 1. Reload Gradle projects\n# File \u2192 Reload All Gradle Projects\n\n# 2. Invalidate caches\n# File \u2192 Invalidate Caches \u2192 Invalidate and Restart\n\n# 3. Rebuild project\n./gradlew clean build\n\n# 4. Check generated sources are registered\nls core/analytics-fakes/build/generated/collected-fakes/\n</code></pre>"},{"location":"multi-module/troubleshooting.html#issue-8-configuration-cache-failures","title":"Issue 8: Configuration Cache Failures","text":"<p>Error: <pre><code>Configuration cache problems found:\n- field 'project' from type 'FaktGradleSubplugin'\n</code></pre></p> <p>Cause: Using configuration cache with older Fakt version</p> <p>Solution: Update to Fakt 1.0.0-SNAPSHOT+ (configuration cache compatible)</p> <pre><code>// gradle.properties\norg.gradle.configuration-cache=true\n</code></pre>"},{"location":"multi-module/troubleshooting.html#error-messages-reference","title":"Error Messages Reference","text":""},{"location":"multi-module/troubleshooting.html#source-project-not-found","title":"\u201cSource project not found\u201d","text":"<pre><code>Source project ':core:analytics' not found.\nVerify module exists and is included in settings.gradle.kts.\n</code></pre> <p>Fix: Add module to <code>settings.gradle.kts</code></p> <pre><code>include(\":core:analytics\")\n</code></pre>"},{"location":"multi-module/troubleshooting.html#collector-and-producer-targets-mismatch","title":"\u201cCollector and producer targets mismatch\u201d","text":"<pre><code>Collector has targets [jvm, js] but producer has [jvm, ios].\nAll producer targets must be present in collector.\n</code></pre> <p>Fix: Add missing targets to collector</p> <pre><code>kotlin {\n    jvm()\n    js()\n    iosArm64()  // \u2705 Add this\n}\n</code></pre>"},{"location":"multi-module/troubleshooting.html#optin-annotation-missing","title":"\u201c@OptIn annotation missing\u201d","text":"<pre><code>Multi-module APIs require opt-in with @OptIn(ExperimentalFaktMultiModule::class)\n</code></pre> <p>Fix: Add opt-in annotation</p> <pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"multi-module/troubleshooting.html#advanced-debugging","title":"Advanced Debugging","text":""},{"location":"multi-module/troubleshooting.html#enable-trace-logging","title":"Enable TRACE Logging","text":"<pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.TRACE)\n}\n</code></pre> <p>Shows: - File-by-file collection - Platform detection reasoning - IR generation details - Task execution timing</p>"},{"location":"multi-module/troubleshooting.html#task-dependency-visualization","title":"Task Dependency Visualization","text":"<pre><code># Show task graph\n./gradlew :app:test --dry-run\n\n# Execution timeline\n./gradlew :app:test --scan\n# \u2192 View timeline in build scan\n</code></pre>"},{"location":"multi-module/troubleshooting.html#inspect-generated-code","title":"Inspect Generated Code","text":"<pre><code># View collected fake\ncat core/analytics-fakes/build/generated/collected-fakes/commonMain/kotlin/com/example/FakeAnalyticsImpl.kt\n\n# Compare with original\ncat core/analytics/build/generated/fakt/commonTest/kotlin/com/example/FakeAnalyticsImpl.kt\n</code></pre>"},{"location":"multi-module/troubleshooting.html#verification-checklist","title":"Verification Checklist","text":"<p>Before reporting issues, verify:</p> <ul> <li>[ ] Producer module has <code>@Fake</code> annotated interfaces</li> <li>[ ] Producer builds successfully (<code>./gradlew :core:analytics:build</code>)</li> <li>[ ] Fakes generated in producer (<code>ls core/analytics/build/generated/fakt/</code>)</li> <li>[ ] Collector depends on producer with correct path</li> <li>[ ] Collector has ALL producer\u2019s KMP targets</li> <li>[ ] Collector declares transitive dependencies</li> <li>[ ] Consumer depends on collector module</li> <li>[ ] Gradle synced in IDE</li> <li>[ ] Using Fakt 1.0.0-SNAPSHOT+</li> <li>[ ] Kotlin 2.2.20+</li> </ul>"},{"location":"multi-module/troubleshooting.html#getting-help","title":"Getting Help","text":"<p>If issues persist:</p> <ol> <li>Enable DEBUG logging and capture output</li> <li>Create minimal reproduction (single producer + collector + consumer)</li> <li>Report on GitHub: github.com/rsicarelli/fakt/issues</li> </ol> <p>Include in report: - Fakt version - Kotlin version - Gradle version - KMP targets - Full error message - DEBUG/TRACE log output - Minimal reproduction repository</p>"},{"location":"multi-module/troubleshooting.html#next-steps","title":"Next Steps","text":"<ul> <li>Migration Guide - Migrate from single-module</li> <li>Technical Reference - FakeCollectorTask internals</li> <li>Getting Started - Setup guide</li> </ul>"},{"location":"reference/api.html","title":"API Reference","text":"<p>Generated code API and patterns.</p>"},{"location":"reference/api.html#generated-classes","title":"Generated Classes","text":"<p>For each <code>@Fake</code> annotated interface, Fakt generates three components:</p>"},{"location":"reference/api.html#implementation-class","title":"Implementation Class","text":"<pre><code>class Fake{Interface}Impl : {Interface} {\n    // StateFlow call counters\n    val {method}CallCount: StateFlow&lt;Int&gt;\n\n    // Override interface members\n    override fun {method}({params}): {return} = {method}Behavior({params})\n\n    // Internal configuration methods\n    internal fun configure{Method}(behavior: ({params}) -&gt; {return})\n}\n</code></pre>"},{"location":"reference/api.html#factory-function","title":"Factory Function","text":"<pre><code>fun fake{Interface}(\n    configure: Fake{Interface}Config.() -&gt; Unit = {}\n): Fake{Interface}Impl\n</code></pre>"},{"location":"reference/api.html#configuration-dsl","title":"Configuration DSL","text":"<pre><code>class Fake{Interface}Config(private val fake: Fake{Interface}Impl) {\n    fun {method}(behavior: ({params}) -&gt; {return})\n}\n</code></pre>"},{"location":"reference/api.html#naming-conventions","title":"Naming Conventions","text":"Element Pattern Example Implementation class <code>Fake{Interface}Impl</code> <code>FakeAnalyticsImpl</code> Factory function <code>fake{Interface}</code> <code>fakeAnalytics</code> Configuration DSL <code>Fake{Interface}Config</code> <code>FakeAnalyticsConfig</code> Call counter <code>{method}CallCount</code> <code>trackCallCount</code> Configuration method <code>{method}</code> <code>track { }</code>"},{"location":"reference/api.html#package-structure","title":"Package Structure","text":"<p>Generated fakes are in the same package as the annotated interface:</p> <pre><code>com.example.services.Analytics (@Fake)\n\u2192 com.example.services.FakeAnalyticsImpl\n\u2192 com.example.services.fakeAnalytics()\n\u2192 com.example.services.FakeAnalyticsConfig\n</code></pre>"},{"location":"reference/api.html#generated-code-location","title":"Generated Code Location","text":"Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code>"},{"location":"reference/api.html#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Plugin options</li> <li>Compatibility - Kotlin versions</li> <li>Limitations - Known issues</li> </ul>"},{"location":"reference/codegen-strategy.html","title":"Code Generation Strategy","text":"<p>Understanding Fakt\u2019s architectural approach to generating test fakes.</p>"},{"location":"reference/codegen-strategy.html#overview","title":"Overview","text":"<p>Fakt generates test fakes at compile-time using a custom type-safe DSL that produces readable Kotlin source files (<code>.kt</code>). This page explains why Fakt chose this approach over alternatives like IR-native generation or third-party libraries like KotlinPoet.</p> <p>TL;DR: Fakt prioritizes developer transparency and debuggability over marginal performance gains. Generated fakes are readable <code>.kt</code> files you can inspect, debug, and understand\u2014not compiler IR nodes or bytecode.</p>"},{"location":"reference/codegen-strategy.html#the-approach-type-safe-dsl","title":"The Approach: Type-Safe DSL","text":"<p>Fakt\u2019s code generation follows a three-phase architecture:</p> <pre><code>Phase 1: Build (Type-Safe DSL)\n  \u2193 codeFile { klass { function { } } }\nPhase 2: Render (Model \u2192 String)\n  \u2193 Immutable data structures \u2192 Kotlin source code\nPhase 3: Write (File I/O)\n  \u2193 Output: build/generated/fakt/.../FakeXxxImpl.kt\n</code></pre>"},{"location":"reference/codegen-strategy.html#how-it-works","title":"How It Works","text":"<p>Instead of manipulating strings directly or generating IR nodes, Fakt uses a builder DSL to construct code:</p> <pre><code>// Simplified example of Fakt's DSL\nval fakeClass = codeFile(\"com.example\") {\n    klass(\"FakeUserServiceImpl\") {\n        implements(\"UserService\")\n\n        property(\"getUserBehavior\") {\n            type(\"(String) -&gt; User\")\n            mutable = true\n            initializer = \"{ id -&gt; User(id, \\\"Default\\\") }\"\n        }\n\n        function(\"getUser\") {\n            override = true\n            parameter(\"id\", \"String\")\n            returns(\"User\")\n            body = \"return getUserBehavior(id)\"\n        }\n    }\n}\n\n// Render to string\nval code = fakeClass.render()\n\n// Write to disk\noutputFile.writeText(code)\n</code></pre> <p>This DSL approach combines the benefits of type safety (compile-time validation) with the transparency of string-based output (readable <code>.kt</code> files).</p>"},{"location":"reference/codegen-strategy.html#why-not-ir-native-generation","title":"Why Not IR-Native Generation?","text":"<p>Some compiler plugins (like Metro) generate code directly as IR (Intermediate Representation) nodes, bypassing the need to write <code>.kt</code> files. This approach has performance benefits but different trade-offs.</p>"},{"location":"reference/codegen-strategy.html#why-fakt-chose-differently","title":"Why Fakt Chose Differently","text":"<p>Metro\u2019s Use Case (Dependency Injection): - Generated code: Internal framework infrastructure - Developer interaction: Rarely read generated code - Performance priority: High (DI graph resolution at runtime)</p> <p>Fakt\u2019s Use Case (Test Fakes): - Generated code: Test implementations - Developer interaction: Frequently read and debug generated fakes - Performance priority: Lower (test code generation at compile-time)</p>"},{"location":"reference/codegen-strategy.html#ir-native-trade-offs-for-fakt","title":"IR-Native Trade-offs for Fakt","text":"<p>If Fakt used IR-native generation:</p> <p>Drawbacks: - \u274c No readable <code>.kt</code> files - Developers see decompiled bytecode in IDEs - \u274c Harder debugging - Can\u2019t set breakpoints in generated code easily - \u274c API instability - Kotlin IR APIs marked <code>@UnsafeApi</code> can change between versions - \u274c Higher complexity - Requires deep FIR + IR expertise (~2-3x codebase size)</p> <p>Benefits: - \u2705 Performance gain: ~10-50ms per fake (skips source \u2192 IR compilation)</p> <p>Decision: For test fake generation, transparency and debuggability outweigh marginal performance gains.</p> <p>When IR-Native Makes Sense</p> <p>IR-native generation is excellent for frameworks generating internal infrastructure code that developers don\u2019t need to read. For Fakt\u2019s use case (test fakes developers debug constantly), readable source files provide better developer experience.</p>"},{"location":"reference/codegen-strategy.html#why-not-kotlinpoet","title":"Why Not KotlinPoet?","text":"<p>KotlinPoet is a popular library for generating Kotlin code using a fluent API. It\u2019s used by many annotation processors and code generators.</p>"},{"location":"reference/codegen-strategy.html#why-fakt-built-a-custom-solution","title":"Why Fakt Built a Custom Solution","text":"<p>KotlinPoet Trade-offs: - \u274c Extra dependency - Adds ~500KB to compiler plugin distribution - \u274c Learning curve - Team must learn external API - \u274c Indirection - KotlinPoet generates strings internally anyway - \u274c Generic API - Designed for general use, not optimized for fake patterns</p> <p>Fakt\u2019s Custom DSL Benefits: - \u2705 Zero dependencies - Leaner compiler plugin - \u2705 Tailored patterns - Built specifically for fake generation patterns - \u2705 Direct control - Full control over output format and structure - \u2705 Simpler mental model - One tool, one purpose</p> <p>Not a General-Purpose Tool</p> <p>Fakt\u2019s DSL is not a general-purpose code generator. It\u2019s optimized specifically for generating test fakes with call tracking, behavior configuration, and StateFlow counters. This specialization allows for cleaner APIs and better defaults.</p>"},{"location":"reference/codegen-strategy.html#benefits-of-this-approach","title":"Benefits of This Approach","text":"<p>Fakt\u2019s type-safe DSL + string-based output provides:</p>"},{"location":"reference/codegen-strategy.html#1-transparency","title":"1. Transparency","text":"<p>Generated fakes are readable Kotlin source files:</p> <pre><code>// build/generated/fakt/.../FakeUserServiceImpl.kt\nclass FakeUserServiceImpl : UserService {\n    private var getUserBehavior: (String) -&gt; User = { id -&gt;\n        User(id, \"Default\")\n    }\n\n    override fun getUser(id: String): User {\n        return getUserBehavior(id)\n    }\n}\n</code></pre> <p>Developers can: - Read generated code directly in their IDE - Understand implementation without digging through IR dumps - Verify correctness by inspection</p>"},{"location":"reference/codegen-strategy.html#2-debuggability","title":"2. Debuggability","text":"<p>Since generated code is real <code>.kt</code> files: - \u2705 Set breakpoints in generated fakes - \u2705 Step through execution line-by-line - \u2705 Inspect variables and behavior during tests - \u2705 Verify generated code matches expectations</p> <p>This is critical for test code where developers need to understand why a test passes or fails.</p>"},{"location":"reference/codegen-strategy.html#3-stability","title":"3. Stability","text":"<p>Kotlin syntax is stable. Once Fakt generates valid Kotlin code, it continues working across Kotlin versions.</p> <p>IR APIs are unstable. Marked <code>@UnsafeApi</code>, these APIs can change between Kotlin releases, requiring updates to Fakt\u2019s implementation.</p>"},{"location":"reference/codegen-strategy.html#4-simplicity","title":"4. Simplicity","text":"<p>Type-safe DSL is: - \u2705 Easier to maintain - Changes to fake patterns update DSL, not low-level IR manipulation - \u2705 Easier to test - Validate generated code as strings, not IR node structures - \u2705 Easier to contribute - Contributors need Kotlin knowledge, not IR expertise</p>"},{"location":"reference/codegen-strategy.html#5-zero-runtime-dependencies","title":"5. Zero Runtime Dependencies","text":"<p>Generated fakes have no runtime dependencies: - No reflection libraries - No code generation utilities - Just plain Kotlin code that compiles to native binaries</p> <p>This is essential for Kotlin Multiplatform where runtime dependencies may not be available on all targets (Native, WASM).</p>"},{"location":"reference/codegen-strategy.html#deep-dive-architecture-details","title":"Deep Dive: Architecture Details","text":"<p>This section is for contributors and maintainers working on Fakt\u2019s internals.</p>"},{"location":"reference/codegen-strategy.html#dsl-layer-architecture","title":"DSL Layer Architecture","text":"<p>Fakt\u2019s code generation is structured in five layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Extension Functions                            \u2502\n\u2502  High-level patterns: stateFlowProperty(),      \u2502\n\u2502  behaviorProperty(), generateCompleteFake()     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Builders (Mutable DSL API)                     \u2502\n\u2502  ClassBuilder, FunctionBuilder, PropertyBuilder \u2502\n\u2502  Kotlin DSL syntax for code construction        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Model Layer (Immutable Data Structures)        \u2502\n\u2502  CodeFile, CodeClass, CodeFunction, CodeProperty\u2502\n\u2502  Pure data models representing Kotlin code      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Strategy Layer                                 \u2502\n\u2502  Default value resolution: primitives,          \u2502\n\u2502  collections, Result&lt;T&gt;, generic types          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Renderer (String Generation)                   \u2502\n\u2502  renderTo(builder) - Convert models to strings  \u2502\n\u2502  CodeBuilder - String accumulation + formatting \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/codegen-strategy.html#key-components","title":"Key Components","text":"<p>1. Model Layer (<code>codegen/model/CodeFile.kt</code>) - Immutable data classes: <code>CodeFile</code>, <code>CodeClass</code>, <code>CodeFunction</code>, <code>CodeProperty</code> - Type-safe representation of Kotlin code structures - No string manipulation at this level</p> <p>2. Builder Layer (<code>codegen/builder/</code>) - <code>ClassBuilder</code>, <code>FunctionBuilder</code>, <code>PropertyBuilder</code> - Mutable builders for DSL construction - Convert to immutable models via <code>build()</code> method</p> <p>3. Extension Functions (<code>codegen/extensions/FakeGenerator.kt</code>) - High-level patterns: <code>generateCompleteFake()</code>, <code>stateFlowProperty()</code> - Reusable fake generation patterns - Compose lower-level builders into complete fake classes</p> <p>4. Renderer (<code>codegen/renderer/Rendering.kt</code>) - <code>renderTo(builder: CodeBuilder)</code> - Convert immutable models to strings - <code>CodeBuilder</code> - String accumulation with indentation support - Handles formatting, modifiers, annotations</p> <p>5. IR Bridge (<code>compiler/ir/generation/ImplementationGenerator.kt</code>) - Connects IR analysis phase to code generation DSL - Converts <code>InterfaceAnalysis</code> (IR metadata) into DSL calls - Entry point: <code>generateImplementation(analysis, packageName, imports)</code></p>"},{"location":"reference/codegen-strategy.html#file-references","title":"File References","text":"<p>For contributors working on code generation:</p> Component File Path Lines Models <code>compiler/src/.../codegen/model/CodeFile.kt</code> 273 Builders <code>compiler/src/.../codegen/builder/ClassBuilder.kt</code> ~200 Extensions <code>compiler/src/.../codegen/extensions/FakeGenerator.kt</code> 1159 Renderer <code>compiler/src/.../codegen/renderer/Rendering.kt</code> ~150 IR Bridge <code>compiler/src/.../ir/generation/ImplementationGenerator.kt</code> ~70 File Writer <code>compiler/src/.../ir/generation/CodeGenerator.kt</code> ~120"},{"location":"reference/codegen-strategy.html#trade-offs-when-to-reconsider","title":"Trade-offs &amp; When to Reconsider","text":""},{"location":"reference/codegen-strategy.html#accepted-trade-off-two-pass-compilation","title":"Accepted Trade-off: Two-Pass Compilation","text":"<p>Generated <code>.kt</code> files are parsed again by the Kotlin compiler:</p> <pre><code>Source code \u2192 IR \u2192 Generated .kt files \u2192 IR \u2192 Bytecode\n              \u2191                           \u2191\n          Fakt plugin             Kotlin compiler\n</code></pre> <p>IR-native generation would skip the second IR pass:</p> <pre><code>Source code \u2192 IR \u2192 Generated IR nodes \u2192 Bytecode\n              \u2191\n          Fakt plugin\n</code></pre> <p>For test code generation, this overhead is negligible compared to the benefits of readable source files.</p>"},{"location":"reference/codegen-strategy.html#when-to-reconsider-this-decision","title":"When to Reconsider This Decision","text":"<p>Fakt would reconsider string-based generation if:</p> <ol> <li>Scale increases - Projects generate 1000+ fakes where compilation time becomes critical</li> <li>Complexity grows - Generated code patterns become difficult to maintain with string-based approach</li> <li>Runtime generation - Need to generate fakes dynamically at runtime (not current use case)</li> <li>Advanced transformations - Generic type manipulation beyond current capabilities</li> </ol> <p>For now, transparency and debuggability remain higher priorities than marginal performance gains.</p>"},{"location":"reference/codegen-strategy.html#next-steps","title":"Next Steps","text":""},{"location":"reference/codegen-strategy.html#for-users","title":"For Users","text":"<p>Understanding code generation strategy helps when: - Debugging generated fakes - Understanding performance characteristics - Evaluating Fakt for your project</p> <p>Related documentation: - API Reference - Generated fake APIs - Limitations - Current generation limitations - Performance Guide - Compilation benchmarks</p>"},{"location":"reference/codegen-strategy.html#for-contributors","title":"For Contributors","text":"<p>Working on code generation: 1. Read ADR: <code>.claude/docs/codegen-v2/ADR.md</code> - Complete architecture decision record 2. Study DSL: <code>.claude/docs/codegen-v2/README.md</code> - Codegen V2 overview 3. Check approach doc: <code>.claude/docs/architecture/code-generation-approach.md</code> - Authoritative decision document 4. Explore code: Start with <code>ImplementationGenerator.kt</code> \u2192 <code>FakeGenerator.kt</code> \u2192 <code>CodeFile.kt</code></p>"},{"location":"reference/codegen-strategy.html#summary","title":"Summary","text":"<p>Fakt\u2019s code generation strategy reflects its core philosophy:</p> <p>Test code should be readable, debuggable, and transparent.</p> <p>By choosing type-safe DSL + string-based generation, Fakt delivers: - \u2705 Readable <code>.kt</code> files developers can inspect and understand - \u2705 Full debuggability with breakpoints and variable inspection - \u2705 Stability across Kotlin versions (syntax vs IR APIs) - \u2705 Zero runtime dependencies for cross-platform support</p> <p>This approach may not be the fastest possible solution, but it\u2019s the right solution for test fake generation.</p>"},{"location":"reference/compatibility.html","title":"Compatibility","text":"<p>Platform and version requirements.</p>"},{"location":"reference/compatibility.html#kotlin-version-support","title":"Kotlin Version Support","text":"Fakt Version Kotlin Version Support 1.0.0-SNAPSHOT 2.2.20 - 2.2.30 <p>Fakt follows forward compatibility on a best-effort basis (usually N+.2 minor versions).</p>"},{"location":"reference/compatibility.html#gradle-version","title":"Gradle Version","text":"<ul> <li>Minimum: Gradle 8.0</li> <li>Recommended: Gradle 8.10+</li> </ul>"},{"location":"reference/compatibility.html#jvm-version","title":"JVM Version","text":"<ul> <li>Minimum: JVM 11</li> <li>Recommended: JVM 21+</li> </ul>"},{"location":"reference/compatibility.html#platform-support","title":"Platform Support","text":"<p>Works on all Kotlin Multiplatform targets:</p> <ul> <li>\u2705 JVM, Android</li> <li>\u2705 iOS (arm64, x64, simulator)</li> <li>\u2705 macOS, Linux, Windows</li> <li>\u2705 JavaScript (IR), WebAssembly</li> <li>\u2705 watchOS, tvOS</li> </ul> <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p>"},{"location":"reference/compatibility.html#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Setup guide</li> <li>Limitations - Known issues</li> </ul>"},{"location":"reference/configuration.html","title":"Configuration","text":"<p>Gradle plugin configuration options.</p>"},{"location":"reference/configuration.html#log-level","title":"Log Level","text":"<p>Control compilation output verbosity:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.LogLevel\n\nfakt {\n    logLevel.set(LogLevel.INFO)  // Default\n}\n</code></pre> <p>Available levels:</p> <ul> <li><code>LogLevel.QUIET</code> - Zero output (CI/CD)</li> <li><code>LogLevel.INFO</code> - Concise summary (default)</li> <li><code>LogLevel.DEBUG</code> - Detailed breakdown with FIR + IR details</li> </ul>"},{"location":"reference/configuration.html#multi-module-support-experimental","title":"Multi-Module Support (Experimental)","text":"<p>Collect fakes from other modules:</p> <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"reference/configuration.html#next-steps","title":"Next Steps","text":"<ul> <li>Performance - Telemetry details</li> <li>Multi-Module - Cross-module fakes</li> </ul>"},{"location":"reference/fakes-over-mocks.html","title":"Fakes Over Mocks","text":"<p>Why Fakt generates fakes instead of using traditional mocking frameworks.</p>"},{"location":"reference/fakes-over-mocks.html#the-problem-with-mocks","title":"The Problem with Mocks","text":"<p>Traditional mocking frameworks like MockK and Mockito have several limitations:</p>"},{"location":"reference/fakes-over-mocks.html#runtime-reflection","title":"Runtime Reflection","text":"<ul> <li>Heavy runtime overhead</li> <li>Not available on all KMP targets (Native, WASM)</li> <li>Complex setup for multiplatform projects</li> </ul>"},{"location":"reference/fakes-over-mocks.html#no-compile-time-safety","title":"No Compile-Time Safety","text":"<ul> <li>Mock setup doesn\u2019t break when interfaces change</li> <li>Refactoring can silently break tests</li> <li>Type safety is lost with <code>any()</code> matchers</li> </ul>"},{"location":"reference/fakes-over-mocks.html#complex-apis","title":"Complex APIs","text":"<ul> <li>Steep learning curve</li> <li>Verbose setup for simple scenarios</li> <li>Magic strings and complex DSL</li> </ul>"},{"location":"reference/fakes-over-mocks.html#how-fakes-are-better","title":"How Fakes Are Better","text":"<p>Fakt generates fakes (not mocks) that solve these problems:</p>"},{"location":"reference/fakes-over-mocks.html#compile-time-generation","title":"\u2705 Compile-Time Generation","text":"<pre><code>@Fake\ninterface UserService {\n    fun getUser(id: String): User\n}\n\n// Generated at compile-time:\nclass FakeUserServiceImpl : UserService {\n    private var getUserBehavior: (String) -&gt; User = { id -&gt;\n        User(id, \"Default Name\")\n    }\n\n    fun configureGetUser(behavior: (String) -&gt; User) {\n        getUserBehavior = behavior\n    }\n\n    override fun getUser(id: String): User = getUserBehavior(id)\n}\n</code></pre>"},{"location":"reference/fakes-over-mocks.html#type-safety","title":"\u2705 Type Safety","text":"<pre><code>// This breaks at COMPILE TIME if interface changes\nval fake = fakeUserService {\n    getUser { id -&gt; User(id, \"Test User\") }  // Typed parameters\n}\n</code></pre>"},{"location":"reference/fakes-over-mocks.html#universal-kmp-support","title":"\u2705 Universal KMP Support","text":"<p>Works on all Kotlin targets without reflection: - JVM, Android, iOS, Native, JS, WASM - No runtime dependencies - Zero overhead in production</p>"},{"location":"reference/fakes-over-mocks.html#thread-safe-call-tracking","title":"\u2705 Thread-Safe Call Tracking","text":"<pre><code>val fake = fakeUserService()\n\nfake.getUser(\"123\")\nfake.getUser(\"456\")\n\n// Built-in StateFlow tracking\nassertEquals(2, fake.getUserCallCount.value)\n</code></pre>"},{"location":"reference/fakes-over-mocks.html#comparison","title":"Comparison","text":"Feature MockK/Mockito Fakt KMP Support Limited Universal Compile-time Safety \u274c \u2705 Runtime Overhead Heavy Zero Type Safety Partial Complete Learning Curve Steep Gentle Call Tracking Manual Built-in"},{"location":"reference/fakes-over-mocks.html#migration-example","title":"Migration Example","text":""},{"location":"reference/fakes-over-mocks.html#before-mockk","title":"Before (MockK):","text":"<pre><code>@Test\nfun `test user service`() = runTest {\n    val mockService = mockk&lt;UserService&gt;()\n\n    every { mockService.getUser(any()) } returns User(\"123\", \"Mock User\")\n\n    val result = mockService.getUser(\"123\")\n\n    verify { mockService.getUser(\"123\") }\n    assertEquals(\"Mock User\", result.name)\n}\n</code></pre>"},{"location":"reference/fakes-over-mocks.html#after-fakt","title":"After (Fakt):","text":"<pre><code>@Test\nfun `GIVEN fake service WHEN getting user THEN returns configured user`() = runTest {\n    val fake = fakeUserService {\n        getUser { id -&gt; User(id, \"Test User\") }\n    }\n\n    val result = fake.getUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n    assertEquals(\"Test User\", result.name)\n}\n</code></pre>"},{"location":"reference/fakes-over-mocks.html#key-benefits","title":"Key Benefits","text":"<ol> <li>No Magic: Everything is generated as readable Kotlin code</li> <li>Predictable: Behavior is explicit and typed</li> <li>Fast: Zero runtime reflection or complex frameworks</li> <li>Safe: Compiler catches interface changes immediately</li> <li>Simple: Clean DSL that matches your domain</li> </ol>"},{"location":"reference/fakes-over-mocks.html#learn-more","title":"Learn More","text":"<ul> <li>Basic Usage - Getting started with fakes</li> <li>Testing Patterns - Best practices</li> <li>Migration Guide - Moving from MockK/Mockito</li> </ul>"},{"location":"reference/limitations.html","title":"Limitations","text":"<p>Known limitations and workarounds.</p>"},{"location":"reference/limitations.html#current-limitations","title":"Current Limitations","text":""},{"location":"reference/limitations.html#data-classes-as-fake-targets","title":"\u274c Data Classes as @Fake Targets","text":"<p>Data classes have compiler-generated implementations and can\u2019t be faked.</p> <p>Workaround: Use builders or <code>copy()</code> for test data.</p> <p>Works as parameter/return types:</p> <pre><code>data class User(val id: String, val name: String)\n\n@Fake  // \u2705 This works\ninterface UserRepository {\n    fun getUser(id: String): User  // \u2705 Data class as return type\n}\n</code></pre>"},{"location":"reference/limitations.html#sealed-classes-as-fake-targets","title":"\u274c Sealed Classes as @Fake Targets","text":"<p>Sealed hierarchies can\u2019t be faked directly.</p> <p>Workaround: Use exhaustive when-expressions or visitor patterns.</p>"},{"location":"reference/limitations.html#default-parameters-in-interface-methods","title":"\u274c Default Parameters in Interface Methods","text":"<p>Interfaces with default parameters are not yet supported.</p> <p>Workaround: Use overloaded methods or remove defaults.</p>"},{"location":"reference/limitations.html#reporting-issues","title":"Reporting Issues","text":"<p>Found a limitation not listed here? Report it on GitHub.</p>"},{"location":"reference/limitations.html#next-steps","title":"Next Steps","text":"<ul> <li>FAQ - Common questions</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"samples/index.html","title":"Sample Projects","text":"<p>Fakt includes working sample projects demonstrating different use cases.</p>"},{"location":"samples/index.html#kmp-single-module","title":"kmp-single-module","text":"<p>Location: <code>samples/kmp-single-module/</code></p> <p>Demonstrates: Basic KMP usage with single module</p> <p>Targets: JVM, iOS, Android, JS, Native</p> <p>Key Examples:</p> <ul> <li>Simple interfaces with suspend functions</li> <li>Property fakes (val/var)</li> <li>Generic interfaces</li> <li>Call tracking with StateFlow</li> </ul> <p>Best for: Learning Fakt basics and KMP setup</p>"},{"location":"samples/index.html#kmp-multi-module","title":"kmp-multi-module","text":"<p>Location: <code>samples/kmp-multi-module/</code></p> <p>Demonstrates: Advanced multi-module architecture with dedicated fake modules</p> <p>Structure:</p> <ul> <li>11 producer modules with <code>@Fake</code> interfaces</li> <li>11 dedicated <code>-fakes</code> collector modules</li> <li>1 consumer app module using all fakes</li> </ul> <p>Key Examples:</p> <ul> <li>Cross-module fake consumption (experimental)</li> <li>Gradle project references with version catalogs</li> <li>Large-scale KMP project patterns</li> <li>Fake module organization</li> </ul> <p>Best for: Understanding multi-module setups and scaling Fakt</p>"},{"location":"samples/index.html#running-samples","title":"Running Samples","text":"<p>Clone the repository and build:</p> <pre><code>git clone https://github.com/rsicarelli/fakt.git\ncd fakt/samples/kmp-single-module\n./gradlew build\n</code></pre>"},{"location":"samples/index.html#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Module Usage - Cross-module fakes</li> <li>Contributing - Add your own samples</li> </ul>"},{"location":"usage/basic-usage.html","title":"Basic Usage","text":"<p>Learn the fundamentals of using Fakt-generated fakes in your tests.</p>"},{"location":"usage/basic-usage.html#simple-interface","title":"Simple Interface","text":"<p>The most common use case\u2014a simple interface with methods:</p> <pre><code>// src/commonMain/kotlin/com/example/Analytics.kt\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    fun identify(userId: String)\n}\n</code></pre> <p>Using in tests:</p> <pre><code>// src/commonTest/kotlin/com/example/AnalyticsTest.kt\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AnalyticsTest {\n    @Test\n    fun `GIVEN fake analytics WHEN tracking events THEN captures calls`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val fake = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n            identify { userId -&gt; println(\"User: $userId\") }\n        }\n\n        fake.track(\"user_signup\")\n        fake.track(\"user_login\")\n        fake.identify(\"user-123\")\n\n        assertEquals(listOf(\"user_signup\", \"user_login\"), events)\n        assertEquals(2, fake.trackCallCount.value)\n        assertEquals(1, fake.identifyCallCount.value)\n    }\n}\n</code></pre>"},{"location":"usage/basic-usage.html#return-values","title":"Return Values","text":"<p>Configure return values for methods:</p> <pre><code>@Fake\ninterface UserRepository {\n    fun getUser(id: String): User?\n    fun getAllUsers(): List&lt;User&gt;\n    fun count(): Int\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN configured repository WHEN fetching users THEN returns configured values`() {\n    val testUser = User(\"123\", \"Alice\")\n\n    val fake = fakeUserRepository {\n        getUser { id -&gt;\n            if (id == \"123\") testUser else null\n        }\n        getAllUsers { listOf(testUser) }\n        count { 1 }\n    }\n\n    assertEquals(testUser, fake.getUser(\"123\"))\n    assertNull(fake.getUser(\"456\"))\n    assertEquals(1, fake.getAllUsers().size)\n    assertEquals(1, fake.count())\n}\n</code></pre>"},{"location":"usage/basic-usage.html#default-behaviors","title":"Default Behaviors","text":"<p>Fakt generates smart defaults. You only configure what you need:</p> <pre><code>@Fake\ninterface Settings {\n    fun getTheme(): String\n    fun getFontSize(): Int\n    fun isEnabled(): Boolean\n}\n</code></pre> <p>Using defaults:</p> <pre><code>@Test\nfun `GIVEN unconfigured fake WHEN calling methods THEN uses defaults`() {\n    val fake = fakeSettings()  // No configuration\n\n    assertEquals(\"\", fake.getTheme())      // String default: \"\"\n    assertEquals(0, fake.getFontSize())    // Int default: 0\n    assertEquals(false, fake.isEnabled())  // Boolean default: false\n}\n</code></pre> <p>Override defaults:</p> <pre><code>@Test\nfun `GIVEN configured fake WHEN calling methods THEN uses custom behavior`() {\n    val fake = fakeSettings {\n        getTheme { \"dark\" }\n        isEnabled { true }\n        // getFontSize not configured, uses default: 0\n    }\n\n    assertEquals(\"dark\", fake.getTheme())\n    assertEquals(true, fake.isEnabled())\n    assertEquals(0, fake.getFontSize())  // Default\n}\n</code></pre>"},{"location":"usage/basic-usage.html#call-tracking","title":"Call Tracking","text":"<p>Every method automatically tracks calls via StateFlow:</p> <pre><code>@Fake\ninterface Logger {\n    fun log(message: String)\n    fun error(message: String)\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN fake logger WHEN logging messages THEN tracks call counts`() {\n    val fake = fakeLogger {\n        log { message -&gt; println(message) }\n        error { message -&gt; System.err.println(message) }\n    }\n\n    fake.log(\"Info message\")\n    fake.log(\"Another info\")\n    fake.error(\"Error occurred\")\n\n    assertEquals(2, fake.logCallCount.value)\n    assertEquals(1, fake.errorCallCount.value)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#multiple-parameters","title":"Multiple Parameters","text":"<p>Methods with multiple parameters work as expected:</p> <pre><code>@Fake\ninterface Calculator {\n    fun add(a: Int, b: Int): Int\n    fun divide(numerator: Double, denominator: Double): Double\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN calculator fake WHEN calling methods THEN uses provided parameters`() {\n    val fake = fakeCalculator {\n        add { a, b -&gt; a + b }\n        divide { numerator, denominator -&gt;\n            if (denominator == 0.0) Double.NaN\n            else numerator / denominator\n        }\n    }\n\n    assertEquals(5, fake.add(2, 3))\n    assertEquals(2.5, fake.divide(5.0, 2.0))\n    assertTrue(fake.divide(10.0, 0.0).isNaN())\n}\n</code></pre>"},{"location":"usage/basic-usage.html#nullable-return-types","title":"Nullable Return Types","text":"<p>Handle nullable types naturally:</p> <pre><code>@Fake\ninterface UserService {\n    fun findUser(id: String): User?\n    fun findByEmail(email: String): User?\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN user service fake WHEN finding users THEN handles nulls correctly`() {\n    val testUser = User(\"123\", \"Alice\")\n\n    val fake = fakeUserService {\n        findUser { id -&gt;\n            if (id == \"123\") testUser else null\n        }\n        // findByEmail not configured, default: null\n    }\n\n    assertNotNull(fake.findUser(\"123\"))\n    assertNull(fake.findUser(\"456\"))\n    assertNull(fake.findByEmail(\"alice@example.com\"))  // Default: null\n}\n</code></pre>"},{"location":"usage/basic-usage.html#result-types","title":"Result Types","text":"<p>Fakt handles <code>Result&lt;T&gt;</code> with sensible defaults:</p> <pre><code>@Fake\ninterface ApiClient {\n    fun fetchData(id: String): Result&lt;Data&gt;\n    fun upload(data: Data): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN API client fake WHEN fetching data THEN returns configured Result`() {\n    val testData = Data(\"123\", \"content\")\n\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            if (id == \"123\") Result.success(testData)\n            else Result.failure(NotFoundException())\n        }\n        upload { data -&gt;\n            Result.success(Unit)\n        }\n    }\n\n    val result1 = fake.fetchData(\"123\")\n    assertTrue(result1.isSuccess)\n    assertEquals(testData, result1.getOrNull())\n\n    val result2 = fake.fetchData(\"456\")\n    assertTrue(result2.isFailure)\n\n    val result3 = fake.upload(testData)\n    assertTrue(result3.isSuccess)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#collection-return-types","title":"Collection Return Types","text":"<p>Smart defaults for collections:</p> <pre><code>@Fake\ninterface Repository {\n    fun getAll(): List&lt;Item&gt;\n    fun getTags(): Set&lt;String&gt;\n    fun getMetadata(): Map&lt;String, String&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN repository fake WHEN fetching collections THEN uses defaults or configured values`() {\n    val fake = fakeRepository {\n        getAll { listOf(Item(\"1\"), Item(\"2\")) }\n        // getTags not configured, default: emptySet()\n        // getMetadata not configured, default: emptyMap()\n    }\n\n    assertEquals(2, fake.getAll().size)\n    assertTrue(fake.getTags().isEmpty())      // Default\n    assertTrue(fake.getMetadata().isEmpty())  // Default\n}\n</code></pre>"},{"location":"usage/basic-usage.html#unit-return-type","title":"Unit Return Type","text":"<p>Methods returning <code>Unit</code> get no-op defaults:</p> <pre><code>@Fake\ninterface EventBus {\n    fun publish(event: Event)\n    fun subscribe(handler: EventHandler)\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN event bus fake WHEN publishing events THEN executes configured behavior`() {\n    val receivedEvents = mutableListOf&lt;Event&gt;()\n\n    val fake = fakeEventBus {\n        publish { event -&gt; receivedEvents.add(event) }\n        // subscribe not configured, default: { } (no-op)\n    }\n\n    fake.publish(Event(\"test-event\"))\n    fake.subscribe(mockHandler)  // No-op default\n\n    assertEquals(1, receivedEvents.size)\n    assertEquals(1, fake.publishCallCount.value)\n    assertEquals(1, fake.subscribeCallCount.value)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#inheritance","title":"Inheritance","text":"<p>Fakt handles inherited methods correctly:</p> <pre><code>interface BaseService {\n    fun start(): Boolean\n    fun stop(): Boolean\n}\n\n@Fake\ninterface UserService : BaseService {\n    fun getUser(id: String): User\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN service fake WHEN calling inherited methods THEN works correctly`() {\n    val fake = fakeUserService {\n        start { true }\n        stop { true }\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    assertTrue(fake.start())\n    assertEquals(\"Alice\", fake.getUser(\"123\").name)\n    assertTrue(fake.stop())\n\n    assertEquals(1, fake.startCallCount.value)\n    assertEquals(1, fake.getUserCallCount.value)\n    assertEquals(1, fake.stopCallCount.value)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#reconfiguring-fakes","title":"Reconfiguring Fakes","text":"<p>You can reconfigure behavior mid-test if needed:</p> <pre><code>@Test\nfun `GIVEN fake WHEN reconfiguring behavior THEN uses new behavior`() {\n    val fake = fakeUserRepository()\n\n    // Initial configuration\n    fake.configureGetUser { id -&gt; User(id, \"Alice\") }\n    assertEquals(\"Alice\", fake.getUser(\"123\").name)\n\n    // Reconfigure\n    fake.configureGetUser { id -&gt; User(id, \"Bob\") }\n    assertEquals(\"Bob\", fake.getUser(\"123\").name)\n}\n</code></pre> <p>Advanced Usage</p> <p>Reconfiguring via <code>configureXxx()</code> methods is an advanced pattern. Prefer creating new fakes for different test scenarios.</p>"},{"location":"usage/basic-usage.html#best-practices","title":"Best Practices","text":""},{"location":"usage/basic-usage.html#one-fake-per-test","title":"\u2705 One Fake Per Test","text":"<p>Create a new fake for each test to avoid shared state:</p> <pre><code>@Test\nfun `test case 1`() {\n    val fake = fakeRepository {  // Fresh fake\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n    // Test with Alice\n}\n\n@Test\nfun `test case 2`() {\n    val fake = fakeRepository {  // Fresh fake\n        getUser { id -&gt; User(id, \"Bob\") }\n    }\n    // Test with Bob\n}\n</code></pre>"},{"location":"usage/basic-usage.html#configure-only-what-you-need","title":"\u2705 Configure Only What You Need","text":"<p>Don\u2019t configure methods you don\u2019t use in the test:</p> <pre><code>@Test\nfun `GIVEN repository WHEN getting user THEN returns user`() {\n    val fake = fakeRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n        // Don't configure saveUser, deleteUser, etc. if not used\n    }\n\n    val user = fake.getUser(\"123\")\n    assertEquals(\"Alice\", user.name)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#use-call-counters-for-verification","title":"\u2705 Use Call Counters for Verification","text":"<p>Verify method calls using built-in counters:</p> <pre><code>@Test\nfun `GIVEN service WHEN processing THEN calls dependencies correctly`() {\n    val fakeRepo = fakeRepository()\n    val service = UserService(fakeRepo)\n\n    service.processUser(\"123\")\n\n    assertEquals(1, fakeRepo.getUserCallCount.value)\n    assertEquals(1, fakeRepo.saveUserCallCount.value)\n}\n</code></pre>"},{"location":"usage/basic-usage.html#next-steps","title":"Next Steps","text":"<ul> <li>Suspend Functions - Async/coroutine support</li> <li>Generics - Generic type handling</li> <li>Properties - val/var faking</li> <li>Call Tracking - Advanced StateFlow patterns</li> </ul>"},{"location":"usage/call-tracking.html","title":"Call Tracking","text":"<p>Every Fakt-generated fake includes automatic, thread-safe call tracking via Kotlin StateFlow.</p>"},{"location":"usage/call-tracking.html#basic-call-tracking","title":"Basic Call Tracking","text":"<pre><code>@Fake\ninterface Analytics {\n    fun track(event: String)\n}\n\nval fake = fakeAnalytics {\n    track { event -&gt; println(event) }\n}\n\nfake.track(\"event1\")\nfake.track(\"event2\")\n\nassertEquals(2, fake.trackCallCount.value)\n</code></pre>"},{"location":"usage/call-tracking.html#stateflow-integration","title":"StateFlow Integration","text":"<p>Call counters are <code>StateFlow&lt;Int&gt;</code>, enabling reactive testing:</p> <pre><code>import app.cash.turbine.test\n\n@Test\nfun `GIVEN fake WHEN calling methods THEN counter updates reactively`() = runTest {\n    val fake = fakeRepository()\n\n    fake.getUserCallCount.test {\n        assertEquals(0, awaitItem())\n\n        fake.getUser(\"123\")\n        assertEquals(1, awaitItem())\n\n        fake.getUser(\"456\")\n        assertEquals(2, awaitItem())\n    }\n}\n</code></pre>"},{"location":"usage/call-tracking.html#property-call-tracking","title":"Property Call Tracking","text":"<p>Properties track both getter and setter calls:</p> <pre><code>@Fake\ninterface Settings {\n    var theme: String\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n}\n\nval _ = fake.theme  // Getter\nassertEquals(1, fake.getThemeCallCount.value)\n\nfake.theme = \"light\"  // Setter\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"usage/call-tracking.html#thread-safety","title":"Thread Safety","text":"<p>All call counters are thread-safe via <code>MutableStateFlow.update</code>:</p> <pre><code>@Test\nfun `GIVEN fake WHEN calling from multiple threads THEN counts correctly`() = runTest {\n    val fake = fakeAnalytics()\n\n    withContext(Dispatchers.Default) {\n        repeat(1000) {\n            launch {\n                fake.track(\"event\")\n            }\n        }\n    }\n\n    assertEquals(1000, fake.trackCallCount.value)\n}\n</code></pre>"},{"location":"usage/call-tracking.html#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Module - Cross-module fakes</li> <li>Testing Patterns - Best practices</li> </ul>"},{"location":"usage/generics.html","title":"Generics","text":"<p>Fakt fully supports generic type parameters at both class and method levels.</p>"},{"location":"usage/generics.html#class-level-generics","title":"Class-Level Generics","text":"<pre><code>@Fake\ninterface Repository&lt;T&gt; {\n    fun save(item: T): Result&lt;Unit&gt;\n    fun getAll(): List&lt;T&gt;\n}\n\nval fake = fakeRepository&lt;User&gt; {\n    save { item -&gt; Result.success(Unit) }\n    getAll { emptyList() }\n}\n</code></pre>"},{"location":"usage/generics.html#method-level-generics","title":"Method-Level Generics","text":"<pre><code>@Fake\ninterface Transformer {\n    fun &lt;T, R&gt; transform(input: T, mapper: (T) -&gt; R): R\n}\n\nval fake = fakeTransformer {\n    transform { input, mapper -&gt; mapper(input) }\n}\n</code></pre>"},{"location":"usage/generics.html#generic-constraints","title":"Generic Constraints","text":"<pre><code>@Fake\ninterface ComparableRepository&lt;T : Comparable&lt;T&gt;&gt; {\n    fun findMax(items: List&lt;T&gt;): T?\n}\n\nval fake = fakeComparableRepository&lt;Int&gt; {\n    findMax { items -&gt; items.maxOrNull() }\n}\n</code></pre>"},{"location":"usage/generics.html#variance","title":"Variance","text":"<p>Fakt supports variance modifiers (<code>out</code>, <code>in</code>):</p> <pre><code>@Fake\ninterface Producer&lt;out T&gt; {\n    fun produce(): T\n}\n\n@Fake\ninterface Consumer&lt;in T&gt; {\n    fun consume(item: T)\n}\n</code></pre>"},{"location":"usage/generics.html#next-steps","title":"Next Steps","text":"<ul> <li>Properties - val/var faking</li> <li>Call Tracking - StateFlow patterns</li> </ul>"},{"location":"usage/properties.html","title":"Properties","text":"<p>Fakt generates fakes for both read-only (<code>val</code>) and mutable (<code>var</code>) properties with automatic call tracking.</p>"},{"location":"usage/properties.html#read-only-properties-val","title":"Read-Only Properties (val)","text":"<pre><code>@Fake\ninterface Config {\n    val apiUrl: String\n    val timeout: Int\n}\n\nval fake = fakeConfig {\n    apiUrl { \"https://api.example.com\" }\n    timeout { 30 }\n}\n\nassertEquals(\"https://api.example.com\", fake.apiUrl)\nassertEquals(1, fake.apiUrlCallCount.value)\n</code></pre>"},{"location":"usage/properties.html#mutable-properties-var","title":"Mutable Properties (var)","text":"<pre><code>@Fake\ninterface Settings {\n    var theme: String\n    var fontSize: Int\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n    fontSize { 14 }\n}\n\n// Getter tracking\nassertEquals(\"dark\", fake.theme)\nassertEquals(1, fake.getThemeCallCount.value)\n\n// Setter tracking\nfake.theme = \"light\"\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"usage/properties.html#next-steps","title":"Next Steps","text":"<ul> <li>Call Tracking - Advanced StateFlow patterns</li> <li>Multi-Module - Cross-module fakes</li> </ul>"},{"location":"usage/suspend-functions.html","title":"Suspend Functions","text":"<p>Fakt fully supports Kotlin coroutines and suspend functions without any special configuration.</p>"},{"location":"usage/suspend-functions.html#basic-suspend-functions","title":"Basic Suspend Functions","text":"<p>Suspend functions work naturally in generated fakes:</p> <pre><code>@Fake\ninterface ApiClient {\n    suspend fun fetchData(id: String): Result&lt;Data&gt;\n    suspend fun upload(data: Data): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage in tests:</p> <pre><code>import kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertTrue\n\nclass ApiClientTest {\n    @Test\n    fun `GIVEN API client fake WHEN fetching data THEN suspends correctly`() = runTest {\n        val testData = Data(\"123\", \"content\")\n\n        val fake = fakeApiClient {\n            fetchData { id -&gt;\n                delay(100)  // Suspends correctly\n                Result.success(testData)\n            }\n            upload { data -&gt;\n                delay(50)\n                Result.success(Unit)\n            }\n        }\n\n        val result = fake.fetchData(\"123\")\n\n        assertTrue(result.isSuccess)\n        assertEquals(testData, result.getOrNull())\n        assertEquals(1, fake.fetchDataCallCount.value)\n    }\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#suspend-non-suspend-mix","title":"Suspend + Non-Suspend Mix","text":"<p>Interfaces can mix suspend and regular functions:</p> <pre><code>@Fake\ninterface UserRepository {\n    fun getLocalUser(id: String): User?\n    suspend fun fetchRemoteUser(id: String): Result&lt;User&gt;\n    suspend fun syncUsers(): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN repository WHEN calling mixed functions THEN works correctly`() = runTest {\n    val fake = fakeUserRepository {\n        getLocalUser { id -&gt; User(id, \"Local\") }\n        fetchRemoteUser { id -&gt;\n            delay(100)\n            Result.success(User(id, \"Remote\"))\n        }\n        syncUsers {\n            delay(200)\n            Result.success(Unit)\n        }\n    }\n\n    // Regular function (no suspend)\n    val local = fake.getLocalUser(\"123\")\n    assertEquals(\"Local\", local?.name)\n\n    // Suspend functions\n    val remote = fake.fetchRemoteUser(\"456\")\n    val syncResult = fake.syncUsers()\n\n    assertTrue(remote.isSuccess)\n    assertTrue(syncResult.isSuccess)\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#suspend-properties","title":"Suspend Properties","text":"<p>Properties with suspend getters are supported:</p> <pre><code>@Fake\ninterface AsyncConfig {\n    suspend fun loadConfig(): Map&lt;String, String&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN async config WHEN loading THEN suspends correctly`() = runTest {\n    val fake = fakeAsyncConfig {\n        loadConfig {\n            delay(50)\n            mapOf(\"key\" to \"value\")\n        }\n    }\n\n    val config = fake.loadConfig()\n\n    assertEquals(\"value\", config[\"key\"])\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#exception-handling","title":"Exception Handling","text":"<p>Suspend functions can throw exceptions naturally:</p> <pre><code>@Test\nfun `GIVEN API client WHEN fetch fails THEN throws exception`() = runTest {\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            delay(100)\n            throw NetworkException(\"Connection failed\")\n        }\n    }\n\n    assertFailsWith&lt;NetworkException&gt; {\n        fake.fetchData(\"123\")\n    }\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#coroutine-context","title":"Coroutine Context","text":"<p>Fakt-generated fakes work with all coroutine contexts:</p> <pre><code>@Test\nfun `GIVEN repository WHEN using different dispatchers THEN works correctly`() = runTest {\n    val fake = fakeRepository {\n        fetchData { id -&gt;\n            withContext(Dispatchers.Default) {\n                // Computation\n                Data(id)\n            }\n        }\n    }\n\n    val data = fake.fetchData(\"123\")\n    assertEquals(\"123\", data.id)\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#best-practices","title":"Best Practices","text":""},{"location":"usage/suspend-functions.html#use-runtest-for-suspend-tests","title":"\u2705 Use runTest for Suspend Tests","text":"<p>Always wrap suspend function tests in <code>runTest</code>:</p> <pre><code>@Test\nfun `test suspend function`() = runTest {  // \u2705 Required\n    val fake = fakeApiClient()\n    fake.fetchData(\"123\")\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#use-delay-for-testing-timing","title":"\u2705 Use delay() for Testing Timing","text":"<p>Test timing-sensitive code with <code>delay()</code>:</p> <pre><code>@Test\nfun `GIVEN slow API WHEN fetching THEN handles timeout`() = runTest {\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            delay(5000)  // Simulate slow response\n            Result.success(Data(id))\n        }\n    }\n\n    withTimeout(1000) {\n        assertFailsWith&lt;TimeoutCancellationException&gt; {\n            fake.fetchData(\"123\")\n        }\n    }\n}\n</code></pre>"},{"location":"usage/suspend-functions.html#next-steps","title":"Next Steps","text":"<ul> <li>Generics - Generic type handling</li> <li>Properties - val/var faking</li> <li>Call Tracking - StateFlow patterns</li> </ul>"}]}