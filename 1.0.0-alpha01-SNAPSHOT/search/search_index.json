{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Fakt","text":"<p>Compile-time type-safe test fakes for Kotlin Multiplatform</p> <p> </p> <p>Fakt generates type-safe test fakes at compile-time. No reflection. No production dependencies. Just clean fakes that break when your interfaces change.</p> <pre><code>@Fake\ninterface Analytics {\n    fun track(event: String)\n}\n\nval fake = fakeAnalytics {\n    track { event -&gt; println(\"Tracked: $event\") }\n}\n</code></pre>"},{"location":"index.html#why-fakt","title":"Why Fakt?","text":"<p>Writing test fakes manually is tedious and error-prone. You write 50+ lines of boilerplate for every interface, manage non-thread-safe call counters, and refactoring interfaces won\u2019t break tests at compile-time. Runtime mocking frameworks like MockK and Mockito avoid the boilerplate but introduce severe performance penalties and don\u2019t work on Native/WASM targets.</p> <p>Fakt solves both problems with compile-time code generation that works everywhere Kotlin compiles.</p> <p>Read the full story \u2192</p>"},{"location":"index.html#features","title":"\u2728 Features","text":"<ul> <li>\u2705 Universal KMP support - Works on all Kotlin targets without reflection</li> <li>\u2705 Zero production overhead - Test-only code generation, no runtime dependencies</li> <li>\u2705 Thread-safe call tracking - Built-in StateFlow-based reactive counters</li> <li>\u2705 Full language support - Suspend functions, generics, properties, inheritance</li> <li>\u2705 Smart defaults - Identity functions for generics, Result.success for Results</li> <li>\u2705 IR-level generation - Direct compiler plugin for performance and compatibility</li> </ul> <p>Complete feature reference \u2192</p>"},{"location":"index.html#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Quick Start:</p> <ol> <li>Getting Started - Install Fakt and create your first fake in 5 minutes</li> <li>Usage Guide - Core patterns and techniques</li> <li>Testing Patterns - Best practices for using fakes in tests</li> </ol> <p>Usage Topics:</p> <ul> <li>Suspend Functions - Working with coroutines and async code</li> <li>Generics - Generic interfaces and type parameters</li> <li>Properties - Faking val and var properties</li> <li>Call Tracking - StateFlow-based reactive counters</li> </ul> <p>Advanced Topics:</p> <ul> <li>Multi-Module Setup - Cross-module fakes with collector modules</li> <li>Configuration - Plugin configuration and log levels</li> <li>Performance - Build times, caching, and optimization</li> <li>Migration from Mocks - Migrating from MockK or Mockito</li> </ul> <p>Reference:</p> <ul> <li>API Reference - Complete generated API documentation</li> <li>Limitations - Known limitations and workarounds</li> <li>Compatibility - Platform and version requirements</li> <li>FAQ - Frequently asked questions</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"index.html#platform-support","title":"\ud83c\udf10 Platform Support","text":"<p>Fakt works on all Kotlin Multiplatform targets without reflection: JVM, Android, iOS, macOS, Linux, Windows, JavaScript, WebAssembly, watchOS, tvOS.</p> <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p> <p>Full compatibility matrix \u2192</p>"},{"location":"index.html#requirements","title":"Requirements","text":"<ul> <li>Kotlin: 2.2.21+</li> <li>Gradle: 8.0+</li> <li>JVM: 11+</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>Fakt is licensed under the Apache License 2.0.</p> <pre><code>Copyright (C) 2025 Rodrigo Sicarelli\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"examples/index.html","title":"Sample Projects","text":"<p>Fakt includes working sample projects demonstrating different use cases.</p>"},{"location":"examples/index.html#kmp-single-module","title":"kmp-single-module","text":"<p>Location: <code>samples/kmp-single-module/</code></p> <p>Demonstrates: Basic KMP usage with single module</p> <p>Targets: JVM, iOS, Android, JS, Native</p> <p>Key Examples:</p> <ul> <li>Simple interfaces with suspend functions</li> <li>Property fakes (val/var)</li> <li>Generic interfaces</li> <li>Call tracking with StateFlow</li> </ul> <p>Best for: Learning Fakt basics and KMP setup</p>"},{"location":"examples/index.html#kmp-multi-module","title":"kmp-multi-module","text":"<p>Location: <code>samples/kmp-multi-module/</code></p> <p>Demonstrates: Advanced multi-module architecture with dedicated fake modules</p> <p>Structure:</p> <ul> <li>11 producer modules with <code>@Fake</code> interfaces</li> <li>11 dedicated <code>-fakes</code> collector modules</li> <li>1 consumer app module using all fakes</li> </ul> <p>Key Examples:</p> <ul> <li>Cross-module fake consumption (experimental)</li> <li>Gradle project references with version catalogs</li> <li>Large-scale KMP project patterns</li> <li>Fake module organization</li> </ul> <p>Best for: Understanding multi-module setups and scaling Fakt</p>"},{"location":"examples/index.html#running-samples","title":"Running Samples","text":"<p>Clone the repository and build:</p> <pre><code>git clone https://github.com/rsicarelli/fakt.git\ncd fakt/samples/kmp-single-module\n./gradlew build\n</code></pre>"},{"location":"examples/index.html#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Module Usage - Cross-module fakes</li> </ul>"},{"location":"get-started/index.html","title":"Getting Started","text":"<p>Get Fakt up and running in your project and create your first fake in 5 minutes.</p>"},{"location":"get-started/index.html#prerequisites","title":"Prerequisites","text":"Requirement Version Kotlin 2.2.21+ Gradle 8.0+ JVM 11+"},{"location":"get-started/index.html#installation","title":"Installation","text":""},{"location":"get-started/index.html#multiplatform-projects","title":"Multiplatform Projects","text":"<p>Version Catalog (<code>gradle/libs.versions.toml</code>):</p> <pre><code>[versions]\nfakt = \"1.0.0-alpha01\"\nkotlin = \"2.2.21\"\n\n[plugins]\nkotlin-multiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nfakt = { id = \"com.rsicarelli.fakt\", version.ref = \"fakt\" }\n\n[libraries]\nfakt-runtime = { module = \"com.rsicarelli.fakt:runtime\", version.ref = \"fakt\" }\n</code></pre> <p>Root <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform) apply false\n    alias(libs.plugins.fakt) apply false\n}\n</code></pre> <p>Module <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\nkotlin {\n    // Your KMP targets\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain.dependencies {\n            implementation(libs.fakt.runtime)\n        }\n    }\n}\n</code></pre> <p>\u2026and that\u2019s it!</p>"},{"location":"get-started/index.html#single-platform-projects","title":"Single-Platform Projects","text":"<p>Fakt works with single-platform Kotlin projects too:</p> <p>JVM-Only:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\ndependencies {\n    implementation(libs.fakt.runtime)\n}\n</code></pre> <p>Android-Only:</p> <pre><code>plugins {\n    id(\"com.android.library\")\n    alias(libs.plugins.kotlin.multiplatform)\n    alias(libs.plugins.fakt)\n}\n\ndependencies {\n    implementation(libs.fakt.runtime)\n}\n</code></pre>"},{"location":"get-started/index.html#your-first-fake-5-minutes","title":"Your First Fake (5 Minutes)","text":""},{"location":"get-started/index.html#step-1-annotate-an-interface","title":"Step 1: Annotate an Interface","text":"<p>Create an interface and mark it with <code>@Fake</code>:</p> <pre><code>// src/commonMain/kotlin/com/example/Analytics.kt\npackage com.example\n\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n}\n</code></pre>"},{"location":"get-started/index.html#step-2-build-your-project","title":"Step 2: Build Your Project","text":"<p>Run Gradle build to generate the fake:</p> <pre><code>./gradlew build\n</code></pre> <p>Fakt generates <code>FakeAnalyticsImpl</code> in <code>build/generated/fakt/commonTest/kotlin/com/example/</code>.</p>"},{"location":"get-started/index.html#step-3-use-in-tests","title":"Step 3: Use in Tests","text":"<p>The generated fake includes a factory function and DSL:</p> <pre><code>// src/commonTest/kotlin/com/example/AnalyticsTest.kt\npackage com.example\n\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AnalyticsTest {\n    @Test\n    fun `GIVEN configured fake WHEN tracking event THEN captures call`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val fake = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n        }\n\n        fake.track(\"user_signup\")\n\n        assertEquals(listOf(\"user_signup\"), events)\n        assertEquals(1, fake.trackCallCount.value)\n    }\n}\n</code></pre>"},{"location":"get-started/index.html#understanding-generated-code","title":"Understanding Generated Code","text":"<p>Fakt generates three components for each <code>@Fake</code> interface:</p>"},{"location":"get-started/index.html#1-implementation-class","title":"1. Implementation Class","text":"<pre><code>class FakeAnalyticsImpl : Analytics {\n    private var trackBehavior: (String) -&gt; Unit = { }\n    private val _trackCallCount = MutableStateFlow(0)\n    val trackCallCount: StateFlow&lt;Int&gt; get() = _trackCallCount\n\n    override fun track(event: String) {\n        _trackCallCount.update { it + 1 }\n        trackBehavior(event)\n    }\n\n    internal fun configureTrack(behavior: (String) -&gt; Unit) {\n        trackBehavior = behavior\n    }\n}\n</code></pre>"},{"location":"get-started/index.html#2-factory-function","title":"2. Factory Function","text":"<pre><code>fun fakeAnalytics(\n    configure: FakeAnalyticsConfig.() -&gt; Unit = {}\n): FakeAnalyticsImpl = FakeAnalyticsImpl().apply {\n    FakeAnalyticsConfig(this).configure()\n}\n</code></pre>"},{"location":"get-started/index.html#3-configuration-dsl","title":"3. Configuration DSL","text":"<pre><code>class FakeAnalyticsConfig(private val fake: FakeAnalyticsImpl) {\n    fun track(behavior: (String) -&gt; Unit) {\n        fake.configureTrack(behavior)\n    }\n}\n</code></pre>"},{"location":"get-started/index.html#generated-code-location","title":"Generated Code Location","text":"<p>Fakt generates code in test source sets only:</p> Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code> <code>androidUnitTest/</code> <code>build/generated/fakt/androidUnitTest/kotlin/</code> <p>Note</p> <p>Generated code never appears in production builds. Fakt is test-only.</p>"},{"location":"get-started/index.html#more-complex-example","title":"More Complex Example","text":"<p>Here\u2019s a realistic interface with suspend functions and generics:</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n    suspend fun saveUser(user: User): Result&lt;Unit&gt;\n    val currentUser: User?\n}\n</code></pre> <p>Using it in tests:</p> <pre><code>import kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertTrue\n\nclass UserRepositoryTest {\n    @Test\n    fun `GIVEN fake repository WHEN saving user THEN returns success`() = runTest {\n        val savedUsers = mutableListOf&lt;User&gt;()\n\n        val fake = fakeUserRepository {\n            saveUser { user -&gt;\n                savedUsers.add(user)\n                Result.success(Unit)\n            }\n            getUser { id -&gt;\n                Result.success(User(id, \"Alice\"))\n            }\n            currentUser { User(\"123\", \"Bob\") }\n        }\n\n        val result = fake.saveUser(User(\"456\", \"Charlie\"))\n\n        assertTrue(result.isSuccess)\n        assertEquals(1, savedUsers.size)\n        assertEquals(\"Charlie\", savedUsers.first().name)\n        assertEquals(1, fake.saveUserCallCount.value)\n    }\n}\n</code></pre>"},{"location":"get-started/index.html#ide-support","title":"IDE Support","text":"<p>Fakt-generated code appears in <code>build/generated/fakt/</code> and is automatically indexed by IntelliJ IDEA and Android Studio.</p> <p>K2 IDE Mode</p> <p>Enable K2 mode for better autocomplete of generated factories:</p> <p>Settings \u2192 Languages &amp; Frameworks \u2192 Kotlin \u2192 Enable K2 mode</p>"},{"location":"get-started/index.html#kotlin-version-compatibility","title":"Kotlin Version Compatibility","text":"Fakt Version Kotlin Version Support 1.0.0-alpha01 2.2.21 - 2.2.30 <p>Fakt follows forward compatibility on a best-effort basis (usually N+.2 minor versions).</p>"},{"location":"get-started/index.html#next-steps","title":"Next Steps","text":"<ul> <li>Features - Complete feature reference</li> <li>Usage Guide - Common patterns and examples</li> <li>Testing Patterns - Best practices</li> <li>Configuration - Plugin options (coming soon)</li> </ul>"},{"location":"get-started/features.html","title":"Features","text":"<p>Quick reference of all Fakt capabilities.</p>"},{"location":"get-started/features.html#supported-class-types","title":"Supported Class Types","text":"CaseExample Interfaces <pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): User\n}\n</code></pre> Abstract Classes <pre><code>@Fake\nabstract class BaseService {\n    abstract fun start(): Boolean\n}\n</code></pre> Open Classes <pre><code>@Fake\nopen class NetworkClient {\n    open suspend fun fetch(url: String): Result&lt;String&gt;\n}\n</code></pre> Data Classes   \u274c Can't be faked \u2705 Works as parameter/return types Sealed Classes   \u274c Can't be faked \u2705 Works as parameter/return types"},{"location":"get-started/features.html#type-system","title":"Type System","text":"CaseExample Class-Level Generics <pre><code>val fake = fakeRepository&lt;User&gt; {\n    save { item -&gt; Result.success(Unit) }\n}\n</code></pre> Method-Level Generics <pre><code>fun &lt;T, R&gt; transform(input: T, mapper: (T) -&gt; R): R\n</code></pre> Generic Constraints <pre><code>interface ComparableRepository&lt;T : Comparable&lt;T&gt;&gt; {\n    fun findMax(items: List&lt;T&gt;): T?\n}\n</code></pre> Variance <pre><code>interface Producer&lt;out T&gt;\ninterface Consumer&lt;in T&gt;\n</code></pre> Nullable Types <pre><code>fun findUser(id: String): User? // Default: null\n</code></pre> Result Types <pre><code>fun save(): Result&lt;Unit&gt; // Default: Result.failure(...)\n</code></pre> Collections <pre><code>fun getAll(): List&lt;User&gt; // Default: emptyList()\n</code></pre>"},{"location":"get-started/features.html#language-features","title":"Language Features","text":"CaseExample Suspend Functions <pre><code>suspend fun fetch(): User // Works in runTest { }\n</code></pre> Properties (val) <pre><code>val apiUrl: String // fake.apiUrl + fake.apiUrlCallCount\n</code></pre> Properties (var) <pre><code>var theme: String // getThemeCallCount + setThemeCallCount\n</code></pre> Inheritance <pre><code>interface UserRepo : BaseRepo { ... } // Inherits parent methods\n</code></pre> Default Parameters <pre><code>fun log(msg: String, level: LogLevel = INFO)\n</code></pre>"},{"location":"get-started/features.html#call-tracking","title":"Call Tracking","text":"CaseExample StateFlow Counters <pre><code>fake.trackCallCount.value // Thread-safe Int counter\n</code></pre> Reactive Testing <pre><code>fake.trackCallCount.test { awaitItem() shouldBe 1 } // Turbine\n</code></pre> Property Tracking <pre><code>fake.getThemeCallCount\nfake.setThemeCallCount\n</code></pre> Thread Safety   All counters use `MutableStateFlow.update` for thread-safe operations."},{"location":"get-started/features.html#code-generation","title":"Code Generation","text":"CaseExample Factory Functions <pre><code>fakeUserRepository { getUser { id -&gt; User(id, \"Alice\") } }\n</code></pre> Type-Safe DSL   Compiler catches type errors at build time.   Smart Defaults <ul> <li>String \u2192 <code>\"\"</code></li> <li>Int \u2192 <code>0</code></li> <li>Boolean \u2192 <code>false</code></li> <li>List \u2192 <code>emptyList()</code></li> </ul>"},{"location":"get-started/features.html#multi-module-experimental","title":"Multi-Module (Experimental)","text":"CaseExample Collector Module <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> Consumer Module <pre><code>dependencies {\n    commonTest {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre>"},{"location":"get-started/features.html#platform-support","title":"Platform Support","text":"CaseExample All KMP Targets   \u2705 JVM, Android, iOS, macOS, Linux, Windows, JS, WASM, watchOS, tvOS   Single Platform   \u2705 JVM-only, Android-only projects fully supported"},{"location":"get-started/features.html#next-steps","title":"Next Steps","text":"<ul> <li>Usage Guide - Comprehensive usage reference with detailed examples</li> <li>Why Fakt? - Design philosophy and advantages</li> <li>Multi-Module - Cross-module fakes</li> </ul>"},{"location":"get-started/why-fakt.html","title":"Why Fakt?","text":"<p>The story behind building a compile-time fake generator for Kotlin testing.</p>"},{"location":"get-started/why-fakt.html#introduction","title":"Introduction","text":"<p>Fakt is a Kotlin compiler plugin that eliminates the boilerplate of writing test fakes by generating them at compile-time.</p> <p>Add <code>@Fake</code> annotation. Fakt generates everything automatically:</p> <pre><code>@Fake\ninterface AnalyticsService {\n    fun track(event: String)\n}\n\n// Generated factory + DSL (zero boilerplate)\nval fake = fakeAnalyticsService {\n    track { event -&gt; println(\"Tracked: $event\") }\n}\n\nfake.track(\"user_signup\")\nassertEquals(1, fake.trackCallCount.value)\n</code></pre> <p>What Fakt generates:</p> <ol> <li>Implementation class with thread-safe StateFlow call tracking</li> <li>Factory function with clean DSL (<code>fakeXxx {}</code>)</li> <li>Configuration DSL for behavior setup</li> </ol>"},{"location":"get-started/why-fakt.html#the-problem-manual-fakes-are-tedious-mocks-are-costly","title":"The Problem: Manual Fakes Are Tedious, Mocks Are Costly","text":"<p>Modern Kotlin development faces a testing dilemma. Writing test doubles (fakes, mocks, stubs) manually is time-consuming and error-prone. Runtime mocking frameworks solve the boilerplate problem but introduce severe performance penalties and architectural limitations. Fakt was created to address both challenges.</p>"},{"location":"get-started/why-fakt.html#the-manual-fake-burden","title":"The Manual Fake Burden","text":"<p>Consider a simple interface requiring a test double:</p> <pre><code>interface AnalyticsService {\n    fun track(event: String)\n    suspend fun flush(): Result&lt;Unit&gt;\n}\n</code></pre> <p>A proper, production-quality fake requires ~60-80 lines of boilerplate:</p> <pre><code>class FakeAnalyticsService : AnalyticsService {\n    // Behavior configuration\n    private var trackBehavior: ((String) -&gt; Unit)? = null\n    private var flushBehavior: (suspend () -&gt; Result&lt;Unit&gt;)? = null\n\n    // Call tracking (non-thread-safe!)\n    private var _trackCallCount = 0\n    val trackCallCount: Int get() = _trackCallCount\n\n    private var _flushCallCount = 0\n    val flushCallCount: Int get() = _flushCallCount\n\n    // Interface implementation\n    override fun track(event: String) {\n        _trackCallCount++\n        trackBehavior?.invoke(event) ?: Unit\n    }\n\n    override suspend fun flush(): Result&lt;Unit&gt; {\n        _flushCallCount++\n        return flushBehavior?.invoke() ?: Result.success(Unit)\n    }\n\n    // Configuration methods\n    fun configureTrack(behavior: (String) -&gt; Unit) {\n        trackBehavior = behavior\n    }\n\n    fun configureFlush(behavior: suspend () -&gt; Result&lt;Unit&gt;) {\n        flushBehavior = behavior\n    }\n}\n</code></pre> <p>Critical issues: - Non-thread-safe call tracking (<code>var count = 0</code>) breaks under concurrent tests - Maintenance burden scales with interface complexity (N methods = ~30N lines) - Silent refactoring failures (interface signature changes don\u2019t break unused fakes) - Copy-paste errors accumulate across dozens of fakes</p> <p>For a codebase with 50+ interfaces requiring fakes, this represents thousands of lines of brittle, repetitive boilerplate.</p>"},{"location":"get-started/why-fakt.html#the-runtime-mocking-crisis-two-independent-failures","title":"The Runtime Mocking Crisis: Two Independent Failures","text":"<p>Runtime mocking frameworks (MockK, Mockito) solve the boilerplate problem through reflection and bytecode instrumentation. However, this \u201cmagic\u201d approach faces two critical, independent failures that make it unsustainable for modern Kotlin development.</p>"},{"location":"get-started/why-fakt.html#failure-1-the-jvm-mock-tax-performance-crisis","title":"Failure 1: The JVM \u201cMock Tax\u201d (Performance Crisis)","text":"<p>Kotlin\u2019s design\u2014final classes by default\u2014creates a fundamental conflict with Java-based mocking tools. Mockito was built for a world where Java classes are <code>open</code> by default, allowing runtime subclassing. Kotlin\u2019s <code>final</code> classes block this mechanism.</p>"},{"location":"get-started/why-fakt.html#the-four-bad-workarounds","title":"The Four Bad Workarounds","text":"<p>Kotlin developers are forced to choose between four sub-optimal solutions:</p> <ol> <li>Manual <code>open</code> keyword - Pollutes production code with test-only concerns</li> <li><code>all-open</code> compiler plugin - Compromises Kotlin\u2019s safety guarantees</li> <li>Mockito\u2019s <code>mock-maker-inline</code> - Uses bytecode instrumentation (slow)</li> <li>MockK\u2019s default behavior - Bundles instrumentation by default (hidden cost)</li> </ol>"},{"location":"get-started/why-fakt.html#verified-performance-penalties","title":"Verified Performance Penalties","text":"<p>Independent benchmarks<sup>1</sup> quantify the \u201cMock Tax\u201d\u2014severe performance degradation when mocking idiomatic Kotlin patterns:</p> Mocking Pattern Framework Comparison Verified Penalty <code>mockkObject</code> (Singletons) MockK vs. Dependency Injection 1,391x slower <code>mockkStatic</code> (Top-level functions) MockK vs. Interface-based DI 146x slower <code>verify { ... }</code> (Interaction verification) MockK vs. State-based testing 47x slower <code>relaxed</code> mocks (Unstubbed calls) MockK vs. Strict mocks 3.7x slower <code>mock-maker-inline</code> Mockito vs. <code>all-open</code> plugin 2.7-3x slower<sup>26</sup><sup>2</sup> <p>Real-world impact: A production test suite with 2,668 tests experienced a 2.7x slowdown (7.3s \u2192 20.0s) when using <code>mock-maker-inline</code> instead of the <code>all-open</code> plugin<sup>2</sup>. For large projects, this \u201cMock Tax\u201d accumulates to 40% slower test suites<sup>1</sup>.</p> <p>The testing framework actively punishes developers for using Kotlin\u2019s most idiomatic features (objects, top-level functions, extension functions).</p>"},{"location":"get-started/why-fakt.html#failure-2-the-kmp-dead-end-architectural-impossibility","title":"Failure 2: The KMP Dead End (Architectural Impossibility)","text":"<p>Kotlin Multiplatform (KMP) has exploded in adoption\u2014Google, Netflix, Cash App, and JetBrains all use it in production. But runtime mocking is fundamentally incompatible with non-JVM targets.</p>"},{"location":"get-started/why-fakt.html#why-runtime-mocking-cannot-work-in-kmp","title":"Why Runtime Mocking Cannot Work in KMP","text":"<p>Runtime mocking relies on JVM-specific features:</p> <ul> <li>Reflection - Inspect and modify code at runtime</li> <li>Bytecode instrumentation - Change class definitions after loading</li> <li>Dynamic proxies - Generate \u201cmagic\u201d classes on the fly</li> </ul> <p>Kotlin/Native (iOS, Desktop) and Kotlin/Wasm compile to native machine code. They have no JVM. Reflection is severely limited<sup>3</sup><sup>4</sup>, bytecode doesn\u2019t exist, and dynamic proxies are impossible.</p> <p>Conclusion: MockK and Mockito cannot run in <code>commonTest</code> source sets targeting Native or Wasm<sup>5</sup><sup>6</sup>. Runtime mocking is a dead end for the entire KMP ecosystem.</p>"},{"location":"get-started/why-fakt.html#the-ksp-workaround-crisis","title":"The KSP \u201cWorkaround\u201d Crisis","text":"<p>The KMP community attempted compile-time code generation via KSP (Kotlin Symbol Processing), creating tools like Mockative, MocKMP, and Mokkery. This ecosystem is in crisis:</p> <p>Kotlin 2.0 Breakage (Verified): - The K2 compiler \u201cfails to handle common metadata tasks properly\u201d in <code>commonTest</code> source sets<sup>7</sup> - Real-world example: StreetComplete app (10,000+ tests) forced to migrate from Mockative to Mokkery due to K2 incompatibility<sup>7</sup> - Mockative maintainer not providing clear K2 migration path<sup>7</sup></p> <p>Feature Limitations: - Mokkery cannot mock: <code>object</code>, <code>sealed</code>, top-level functions, final classes (without <code>all-open</code>)<sup>7</sup> - MocKMP can only mock interfaces, no relaxed mocks<sup>8</sup></p> <p>Strategic failure: The KSP \u201csolutions\u201d cannot even solve the original Kotlin problems (objects, top-level functions) that create JVM performance penalties.</p>"},{"location":"get-started/why-fakt.html#the-philosophical-foundation-why-fakes-reduce-brittleness","title":"The Philosophical Foundation: Why Fakes Reduce Brittleness","text":"<p>Beyond performance, the \u201cfakes over mocks\u201d movement represents a fundamental shift in testing philosophy, rooted in decades of TDD (Test-Driven Development) debate.</p>"},{"location":"get-started/why-fakt.html#state-based-vs-interaction-based-testing","title":"State-Based vs. Interaction-Based Testing","text":"<p>Martin Fowler\u2019s seminal \u201cMocks Aren\u2019t Stubs\u201d<sup>9</sup> describes two testing schools:</p> <p>State-Based Testing (Classic/Detroit School): - Uses fakes and stubs to provide inputs - Verifies the resulting state of the system - Test assertion: \u201cAfter calling <code>saveUser</code>, is the user in the fake repository?\u201d</p> <p>Interaction-Based Testing (London School): - Uses mocks to verify method calls - Verifies how a unit communicates with collaborators - Test assertion: \u201cWas <code>repository.saveUser()</code> called exactly once with the correct user?\u201d</p>"},{"location":"get-started/why-fakt.html#the-refactoring-problem","title":"The Refactoring Problem","text":"<p>Mock-based tests couple to implementation details, not outcomes<sup>10</sup>. Consider this refactoring:</p> <p>Before: <pre><code>// SUT implementation\nfun checkout() {\n    repository.saveOrder(order)\n}\n\n// Mock-based test\nverify { repository.saveOrder(order) }\n</code></pre></p> <p>After (valid refactoring): <pre><code>// SUT implementation\nfun checkout() {\n    repository.saveOrderWithAudit(order, auditLog = true) // New overload\n}\n\n// Mock-based test BREAKS (false negative)\nverify { repository.saveOrder(order) } // \u274c Fails!\n</code></pre></p> <p>The outcome is identical (order is saved), but the process changed. The mock-based test reports a failure even though no bug was introduced. This creates a vicious cycle: brittle tests discourage refactoring, leading to code rot.</p> <p>Google\u2019s \u201cTesting on the Toilet\u201d papers define resilience as a critical test quality: \u201cA test shouldn\u2019t fail if the code under test isn\u2019t defective\u201d<sup>11</sup>. Mock-based tests violate this principle.</p>"},{"location":"get-started/why-fakt.html#the-virtuous-cycle-of-fakes","title":"The Virtuous Cycle of Fakes","text":"<p>Fake-based testing with state verification creates resilient tests:</p> <pre><code>// Fake-based test (survives refactoring)\nval fake = fakeRepository()\nviewModel.checkout()\n\n// Assert the OUTCOME, not the process\nassertEquals(1, fake.orders.size)\nassertTrue(fake.orders.contains(order))\n</code></pre> <p>This test continues passing after the refactoring because it verifies what happened (order was saved), not how it happened (which method was called). Kent Beck observed that mocks \u201cslow down refactoring\u2026 because of the higher coupling between your tests and the actual implementation\u201d<sup>12</sup>.</p>"},{"location":"get-started/why-fakt.html#industry-validation-googles-now-in-android-playbook","title":"Industry Validation: Google\u2019s \u201cNow in Android\u201d Playbook","text":"<p>The \u201cfakes over mocks\u201d philosophy isn\u2019t theoretical\u2014it\u2019s the explicit, documented strategy of Google\u2019s flagship Android reference app.</p>"},{"location":"get-started/why-fakt.html#the-official-directive","title":"The Official Directive","text":"<p>Google\u2019s \u201cNow in Android\u201d (NiA) testing strategy wiki states unambiguously:</p> <p>\u201cDon\u2019t use mocking frameworks. Instead, use fakes.\u201d<sup>14</sup></p> <p>This decision is deliberate. The documentation explains the goal is to create \u201cless brittle tests that may exercise more production code, instead of just verifying specific calls against mocks\u201c<sup>13</sup>.</p>"},{"location":"get-started/why-fakt.html#pattern-1-test-only-hooks","title":"Pattern 1: Test-Only Hooks","text":"<p>NiA uses \u201ctest-only hooks\u201d to control fake behavior<sup>14</sup>:</p> <pre><code>// Production interface\ninterface NewsRepository {\n    fun getNews(): Flow&lt;List&lt;Article&gt;&gt;\n}\n\n// Test repository with hooks\nclass TestNewsRepository : NewsRepository {\n    private val newsFlow = MutableStateFlow&lt;List&lt;Article&gt;&gt;(emptyList())\n\n    // Production method\n    override fun getNews(): Flow&lt;List&lt;Article&gt;&gt; = newsFlow\n\n    // Test-only hook (not in interface)\n    fun sendNews(articles: List&lt;Article&gt;) {\n        newsFlow.value = articles\n    }\n}\n\n// Test usage\n@Test\nfun `GIVEN breaking news WHEN loading THEN displays alert`() = runTest {\n    val fake = TestNewsRepository()\n    val viewModel = NewsViewModel(fake)\n\n    // Use test-only hook to control fake\n    fake.sendNews(listOf(Article(breaking = true)))\n\n    // Assert resulting state\n    assertTrue(viewModel.uiState.value.showAlert)\n}\n</code></pre> <p>This pattern transforms testing from passive \u201csetup-then-verify\u201d (mocks) to active \u201cact-and-assert\u201d (fakes).</p>"},{"location":"get-started/why-fakt.html#pattern-2-high-fidelity-testing","title":"Pattern 2: High-Fidelity Testing","text":"<p>NiA doesn\u2019t fake everything\u2014it uses real implementations when controllable<sup>13</sup>:</p> <ul> <li>DataStore: Uses real <code>DataStore</code> writing to temporary folders wiped after each test</li> <li>Benefit: Tests exercise serialization, error handling, and migration logic</li> </ul> <p>This reveals a mature testing hierarchy: 1. First choice: Real implementation in controlled environment 2. Second choice: Fake for uncontrollable dependencies (network) 3. Last resort (banned): Mocks from frameworks</p>"},{"location":"get-started/why-fakt.html#the-asynchronous-testing-synergy","title":"The Asynchronous Testing Synergy","text":"<p>Kotlin\u2019s modern async stack\u2014<code>runTest</code>, <code>TestDispatcher</code>, and Turbine\u2014is inherently state-based, creating natural synergy with fakes.</p>"},{"location":"get-started/why-fakt.html#official-jetbrains-tooling","title":"Official JetBrains Tooling","text":"<p><code>runTest</code> + <code>TestDispatcher</code><sup>15</sup>: - Official <code>kotlinx-coroutines-test</code> library - Provides <code>TestScope</code> with virtual time control - Best practice: Inject <code>CoroutineDispatcher</code> into ViewModels/Repositories</p> <pre><code>@Test\nfun `GIVEN delay WHEN loading THEN skips virtual time`() = runTest {\n    val fake = fakeRepository()\n    val viewModel = ViewModel(fake, testScheduler) // Inject TestDispatcher\n\n    viewModel.loadData() // Internally: delay(5000)\n\n    // Test completes instantly (virtual time)\n    assertEquals(LoadingState.Success, viewModel.state.value)\n}\n</code></pre>"},{"location":"get-started/why-fakt.html#cash-apps-turbine-de-facto-standard","title":"Cash App\u2019s Turbine (De Facto Standard)","text":"<p>Turbine<sup>16</sup> is the universally adopted library for testing <code>Flow</code>:</p> <pre><code>@Test\nfun `GIVEN repository updates WHEN observing THEN emits new state`() = runTest {\n    val fake = fakeRepository {\n        getUser { User(id = \"123\", name = \"Alice\") }\n    }\n\n    viewModel.userFlow.test {\n        fake.sendUser(User(id = \"123\", name = \"Bob\")) // Test-only hook\n        assertEquals(\"Bob\", awaitItem().name) // State-based assertion\n    }\n}\n</code></pre> <p>Key insight: Turbine\u2019s API (<code>awaitItem()</code>) is designed for state verification, not interaction verification. The most natural way to produce data for Turbine is a fake with <code>MutableStateFlow</code> backing.</p>"},{"location":"get-started/why-fakt.html#the-golden-path","title":"The Golden Path","text":"<p>The modern Kotlin testing stack is: - <code>runTest</code> (virtual time) - Turbine (Flow testing) - Fakes (state-based data sources)</p> <p>This entire ecosystem is state-based by design. Compile-time fake generation completes this stack by automating the \u201chandwritten fake\u201d pattern.</p>"},{"location":"get-started/why-fakt.html#the-solution-compile-time-fake-generation","title":"The Solution: Compile-Time Fake Generation","text":"<p>Fakt solves both the JVM performance crisis and the KMP dead end through deep compiler integration\u2014a FIR \u2192 IR two-phase architecture that succeeds where KSP-based solutions fundamentally fail.</p>"},{"location":"get-started/why-fakt.html#why-ksp-based-solutions-failed","title":"Why KSP-Based Solutions Failed","text":"<p>The KMP testing ecosystem attempted to solve the mocking crisis through KSP (Kotlin Symbol Processing)\u2014a code generation tool that operates at the symbol level. This approach has proven architecturally inadequate.</p> <p>The K2 Compiler Breakage (Verified):</p> <p>Kotlin 2.0\u2019s release broke KSP-based mocking libraries. The K2 compiler \u201cfails to handle common metadata tasks properly\u201d in <code>commonTest</code> source sets<sup>7</sup>, creating a real-world migration crisis:</p> <ul> <li>StreetComplete app (10,000+ tests) forced to migrate from Mockative to Mokkery</li> <li>Mockative maintainer provided no clear K2 migration path</li> <li>Mokkery itself was forced to abandon KSP and build a full compiler plugin just to survive<sup>7</sup></li> </ul> <p>Architectural Limitations:</p> Issue KSP (Symbol-Level) Compiler Plugin (IR-Level) Access Level After type resolution During compilation (FIR/IR) Type System Read-only symbol view Full type manipulation Generic Support Limited (no type substitution) Complete (IrTypeSubstitutor) K2 Stability BROKEN (forced migrations) Stable (official extension points) Cross-Module Fragile (metadata issues) Robust (IR graph traversal) <p>The Verdict: KSP is the wrong tool for production-quality fake generation. A compiler-level solution is the only viable path.</p>"},{"location":"get-started/why-fakt.html#the-mokkery-exception-compiler-plugins-as-the-survivor-architecture","title":"The Mokkery Exception: Compiler Plugins as the Survivor Architecture","text":"<p>While the KSP ecosystem collapsed, one library thrived: Mokkery<sup>17</sup>.</p> <p>Mokkery is a Kotlin/IR compiler plugin\u2014not a KSP processor. This architectural choice proved decisive during the K2 migration. While Mockative and MocKMP struggled with broken <code>commonTest</code> generation, Mokkery\u2019s developer was proactively testing K2 betas in February 2024 and shipped stable K2 support by May 2024<sup>18</sup>.</p> <p>The Real-World Impact:</p> <p>The K2 migration created a forced ecosystem migration. StreetComplete, a popular open-source Android app with 10,000+ tests, had to abandon Mockative for Mokkery when K2 broke their test suite<sup>19</sup>. The Mockative maintainer himself publicly suggested users investigate Mokkery as a viable alternative<sup>7</sup>.</p> <p>This ecosystem schism validated a critical insight: compiler plugins, not KSP, are the only stable architecture for KMP test tooling.</p> <p>Why Mokkery Succeeded:</p> <p>Mokkery operates inside the Kotlin compiler as an IR transformer. When you write <code>mock&lt;UserRepository&gt;()</code>, Mokkery\u2019s plugin replaces that call with a fully-generated implementation class at the IR level<sup>20</sup>. This eliminates KSP\u2019s fundamental problem: fragile source-set code generation.</p> <p>Mokkery\u2019s API is intentionally designed as a MockK analogue<sup>21</sup>, providing zero-friction migration for KMP developers:</p> <pre><code>// Mokkery: Familiar MockK-like DSL\nval repository = mock&lt;BookRepository&gt;()\nevery { repository.findAll() } returns flowOf(Book(\"...\"))\nverify(exhaustiveOrder) { repository.findById(\"1\") }\n</code></pre> <p>Mokkery is production-ready (v2.10.2), actively maintained, and the current incumbent for KMP mocking<sup>22</sup>. For teams committed to interaction-based testing, Mokkery is a credible, stable solution.</p> <p>The Compiler Plugin Validation:</p> <p>Mokkery\u2019s success proves the architectural validity of compiler plugins for KMP testing. Both Mokkery and Fakt share this fundamental design decision. This isn\u2019t coincidental\u2014it\u2019s the only path that survives K2\u2019s stricter compilation model.</p> <p>Where Mokkery and Fakt Diverge:</p> <p>The critical difference isn\u2019t architecture\u2014it\u2019s testing paradigm coverage.</p> <p>Mokkery is a mocking library designed exclusively for interaction-based testing (verifying that methods were called). Fakt is a fake generator that supports both paradigms: state-based testing (primary) with built-in interaction tracking through StateFlow call counting.</p> <p>This distinction reveals itself in Mokkery\u2019s documented limitations<sup>23</sup>. As a mocking library, Mokkery is architecturally unable to mock:</p> <ul> <li><code>object</code> singletons</li> <li><code>sealed class</code> and <code>sealed interface</code> hierarchies</li> <li>Top-level functions and extension functions</li> <li>Final classes from third-party dependencies</li> </ul> <p>These aren\u2019t bugs\u2014they\u2019re the glass ceiling of the mocking paradigm. Mocking requires \u201cfully overridable\u201d types (interfaces, abstract classes). Sealed types, objects, and final classes cannot be \u201cmocked\u201d at runtime.</p> <p>Fakt\u2019s Dual Paradigm Advantage:</p> <p>Fakt doesn\u2019t mock\u2014it generates real implementations with support for both testing approaches. Every generated fake includes:</p> <ul> <li>Behavior configuration (state-based testing)</li> <li>StateFlow call tracking (interaction-based testing)</li> <li>Thread-safety (no <code>var count = 0</code> footguns)</li> </ul> <p>As documented earlier in \u201cSupporting Both Testing Paradigms,\u201d the same Fakt fake can verify state and interactions:</p> <pre><code>val fake = fakeUserRepository {\n    save { user -&gt; user.copy(id = \"generated-id\") }\n}\n\n// State-based verification\nval result = fake.save(User(\"test\"))\nassertEquals(\"generated-id\", result.id) // What happened?\n\n// Interaction-based verification (same fake)\nassertEquals(1, fake.saveCallCount.value) // How many times?\n</code></pre> <p>This dual paradigm support means you\u2019re not forced to choose philosophies\u2014Fakt adapts to your testing needs.</p> <p>The Brittleness Trade-off:</p> <p>Consider this refactoring scenario that highlights the paradigm difference:</p> <pre><code>// Original implementation\nfun checkout() {\n    repository.saveOrder(order)\n}\n\n// Mokkery test (interaction-based ONLY)\nverify(exactly = 1) { repository.saveOrder(order) }\n\n// Refactored implementation (same outcome, different method signature)\nfun checkout() {\n    repository.saveOrderWithAudit(order, auditLog = true)\n}\n\n// Result: Mokkery test BREAKS (false negative)\n// The outcome is identical, but the process changed\n</code></pre> <p>The outcome is identical (order saved), but the process changed. The mock-based test fails even though no bug exists. This is the brittleness Martin Fowler warned about\u2014tests coupled to how code works, not what it achieves<sup>9</sup>.</p> <p>The same refactoring with Fakt:</p> <pre><code>// Fakt test (state-based verification)\nval fake = fakeRepository()\nviewModel.checkout()\nassertEquals(1, fake.orders.size) // Assert OUTCOME, not process\n// Test survives refactoring\n</code></pre> <p>This test survives because it verifies state (was the order saved?), not interactions (which method was called?). And when you do need interaction verification, Fakt provides it through StateFlow: <code>assertEquals(1, fake.saveOrderCallCount.value)</code>.</p> <p>Complementary Solutions:</p> <p>Mokkery and Fakt serve different philosophical commitments:</p> Choose Mokkery When: Choose Fakt When: Interaction-based testing is your standard State-based testing is your primary approach MockK muscle memory drives your team Need both paradigms in one tool Side-effect verification without observable state Building test fixtures with controllable behavior Committed to London School exclusively Following Google\u2019s NiA pattern (state-based) <p>For teams with MockK expertise, Mokkery is the natural KMP migration path. For teams adopting state-based testing or needing flexibility between both paradigms, Fakt completes the Kotlin async testing stack (<code>runTest</code> + Turbine + Fakes).</p> <p>The Architectural Depth Difference:</p> <p>Mokkery and Fakt differ even at the compiler level:</p> <ul> <li>Mokkery: IR-only plugin (single-phase, anonymous IR classes, invisible output)</li> <li>Fakt: FIR \u2192 IR plugin (two-phase, readable <code>.kt</code> files, full debuggability)</li> </ul> <p>Fakt\u2019s two-phase architecture provides richer semantic information (full type resolution at FIR) and debuggable output (step through generated fakes with breakpoints). Mokkery\u2019s IR-only approach is invisible (no physical files), which works well for mocking but limits debuggability.</p> <p>Conclusion:</p> <p>Mokkery validates the compiler plugin architecture as the survivor of the K2 schism. It\u2019s an excellent solution for teams committed to interaction-based testing. Fakt extends this foundation by supporting both testing paradigms\u2014state-based verification with optional interaction tracking\u2014while generating real implementations that handle sealed types, objects, and other idiomatic Kotlin patterns that mocking fundamentally cannot support.</p> <p>The choice isn\u2019t \u201cwhich is better\u201d\u2014it\u2019s about paradigm needs. Mokkery excels at interaction-based testing. Fakt provides dual paradigm support with architectural advantages for Kotlin\u2019s full type system.</p>"},{"location":"get-started/why-fakt.html#fakts-fir-ir-two-phase-architecture","title":"Fakt\u2019s FIR \u2192 IR Two-Phase Architecture","text":"<p>Fakt uses a Metro-inspired production compiler plugin architecture with deep integration into Kotlin\u2019s compilation pipeline:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 1: FIR (Frontend IR)                         \u2502\n\u2502  \u2022 FaktFirExtensionRegistrar                         \u2502\n\u2502  \u2022 Detects @Fake annotations on interfaces          \u2502\n\u2502  \u2022 Validates structure, thread-safety requirements   \u2502\n\u2502  \u2022 Full access to type system during resolution      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PHASE 2: IR (Intermediate Representation)          \u2502\n\u2502  \u2022 UnifiedFaktIrGenerationExtension                  \u2502\n\u2502  \u2022 InterfaceAnalyzer: Dynamic interface discovery    \u2502\n\u2502  \u2022 IrCodeGenerator: Type-safe code generation        \u2502\n\u2502  \u2022 Generates readable .kt files (not IR nodes)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  OUTPUT: Generated Kotlin Source Code               \u2502\n\u2502  \u2022 FakeXxxImpl.kt (implementation class)             \u2502\n\u2502  \u2022 fakeXxx() factory (type-safe DSL)                 \u2502\n\u2502  \u2022 Thread-safe StateFlow call tracking               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Metro Alignment: Fakt follows the production-validated pattern from Metro, Zac Sweers\u2019 dependency injection compiler plugin used by Google, Netflix, and Cash App. Metro\u2019s two-phase FIR \u2192 IR architecture has proven stable across Kotlin 1.9, 2.0, and 2.1.</p> <p>Why Not IR-Native Generation?</p> <p>Fakt generates readable <code>.kt</code> source files, not IR nodes directly. For test fakes\u2014code developers constantly debug\u2014transparency outweighs marginal performance gains. Generated fakes are real Kotlin files you can step through with breakpoints, not decompiled bytecode.</p>"},{"location":"get-started/why-fakt.html#supporting-both-testing-paradigms","title":"Supporting Both Testing Paradigms","text":"<p>Fakt doesn\u2019t force you to choose between state-based or interaction-based testing. Every generated fake supports both philosophies simultaneously.</p> <p>State-Based Testing (Classic/Detroit School):</p> <pre><code>@Fake\ninterface UserRepository {\n    suspend fun save(user: User): User\n}\n\n// Generated: Behavior configuration DSL\nval fake = fakeUserRepository {\n    save { user -&gt; user.copy(id = \"generated-id\") }\n}\n\n// Test: Verify STATE\n@Test\nfun `GIVEN user WHEN saving THEN returns persisted user`() = runTest {\n    val result = fake.save(User(\"test\"))\n    assertEquals(\"generated-id\", result.id) // State verification\n}\n</code></pre> <p>Interaction-Based Testing (London School):</p> <pre><code>// Same generated fake includes automatic call tracking\n@Test\nfun `GIVEN multiple saves WHEN called THEN tracks interaction count`() = runTest {\n    fake.save(User(\"user1\"))\n    fake.save(User(\"user2\"))\n\n    // Verify INTERACTIONS (thread-safe StateFlow)\n    assertEquals(2, fake.saveCallCount.value)\n}\n</code></pre> <p>The Technical Achievement:</p> <p>Every generated method/property includes: - Behavior configuration (state-based testing) - StateFlow call tracking (interaction-based testing) - Thread-safety (no <code>var count = 0</code> footguns) - Zero runtime overhead (compile-time generation)</p> <p>One tool. Both paradigms. Zero dogma.</p>"},{"location":"get-started/why-fakt.html#how-fakt-works","title":"How Fakt Works","text":"<pre><code>@Fake\ninterface UserRepository {\n    suspend fun getUser(id: String): Result&lt;User&gt;\n}\n\n// Generated at compile-time (zero runtime overhead)\nval fake = fakeUserRepository {\n    getUser { id -&gt; Result.success(User(id, \"Alice\")) }\n}\n\n// State-based: Configure behavior\nfake.getUser(\"123\") // Returns User(\"123\", \"Alice\")\n\n// Interaction-based: Verify calls\nassertEquals(1, fake.getUserCallCount.value) // Thread-safe StateFlow\n</code></pre>"},{"location":"get-started/why-fakt.html#technical-advantages","title":"Technical Advantages","text":"<p>Universal Platform Support: - JVM, Android, Native (iOS/Desktop), JavaScript, WebAssembly - No reflection required (works on Native/Wasm) - Zero runtime dependencies</p> <p>Zero Performance Overhead: - Eliminates 1,391x MockK penalty<sup>1</sup> - No bytecode instrumentation - Generated code as fast as handwritten fakes</p> <p>100% Debuggable: - Readable <code>.kt</code> files in <code>build/generated/fakt/</code> - Set breakpoints, inspect variables - Step through generated implementations line-by-line</p> <p>Compiler-Level Stability: - Uses official Kotlin compiler extension points - Survives K2 compiler updates (unlike KSP tools) - Aligned with Metro\u2019s production-tested patterns</p> <p>Built-In Thread Safety: - StateFlow call tracking (not <code>var count = 0</code>) - No concurrent test flakiness - Reactive (works with Turbine for Flow testing)</p> <p>Smart Defaults:</p> <p>Fakt generates sensible default behaviors for unconfigured methods:</p> Type Default Behavior <code>Unit</code> <code>{ }</code> <code>Boolean</code> <code>{ false }</code> <code>Int</code>, <code>Long</code>, etc. <code>{ 0 }</code> <code>String</code> <code>{ \"\" }</code> <code>List&lt;T&gt;</code> <code>{ emptyList() }</code> <code>Result&lt;T&gt;</code> <code>{ Result.failure(NotImplementedError)}</code> Generic <code>T -&gt; T</code> <code>{ it }</code> (identity function) Nullable <code>T?</code> <code>{ null }</code>"},{"location":"get-started/why-fakt.html#fakes-vs-mocks-quick-comparison","title":"Fakes vs. Mocks: Quick Comparison","text":"Feature MockK/Mockito Fakt KMP Support Limited (JVM only) Universal (all targets) Compile-time Safety \u274c \u2705 Runtime Overhead Heavy (reflection) Zero Type Safety Partial (<code>any()</code> matchers) Complete Learning Curve Steep (complex DSL) Gentle (typed functions) Call Tracking Manual (<code>verify { }</code>) Built-in (StateFlow) Thread Safety Not guaranteed StateFlow-based Debuggability Reflection (opaque) Generated <code>.kt</code> files"},{"location":"get-started/why-fakt.html#migration-example","title":"Migration Example","text":"<p>Before (MockK): <pre><code>@Test\nfun `test user service`() = runTest {\n    val mockService = mockk&lt;UserService&gt;()\n\n    every { mockService.getUser(any()) } returns User(\"123\", \"Mock User\")\n\n    val result = mockService.getUser(\"123\")\n\n    verify { mockService.getUser(\"123\") }\n    assertEquals(\"Mock User\", result.name)\n}\n</code></pre></p> <p>After (Fakt): <pre><code>@Test\nfun `GIVEN fake service WHEN getting user THEN returns configured user`() = runTest {\n    val fake = fakeUserService {\n        getUser { id -&gt; User(id, \"Test User\") }\n    }\n\n    val result = fake.getUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n    assertEquals(\"Test User\", result.name)\n}\n</code></pre></p> <p>Key improvements: 1. No magic strings - <code>any()</code> replaced with typed lambda 2. Explicit behavior - Clear what\u2019s returned for which input 3. Type-safe verification - Compiler catches <code>getUserCallCount</code> typos 4. Readable intent - GIVEN-WHEN-THEN structure</p>"},{"location":"get-started/why-fakt.html#when-not-to-use-fakes","title":"When NOT to Use Fakes","text":"<p>Fakt isn\u2019t a silver bullet. Some scenarios favor other tools:</p> <p>Third-Party APIs \u2192 Use WireMock<sup>24</sup> or Pact<sup>25</sup> - Hand-written fakes for external APIs are \u201cdangerous illusions of fidelity\u201d - WireMock tests full HTTP client stack - Pact validates contracts with provider teams</p> <p>Legacy Code Without Interfaces \u2192 Use Pragmatic Mocks - Mocking frameworks can mock concrete classes via reflection - Allows testing before major refactoring - \u201cFakes-only\u201d demands all-or-nothing interface refactoring</p> <p>Side Effects Without Observable State \u2192 Use Mocks - Fire-and-forget analytics, logging - Interaction timing/ordering matters - Fakes provide no value without state to assert</p>"},{"location":"get-started/why-fakt.html#what-fakt-supports","title":"What Fakt Supports","text":"<p>Class Types: - \u2705 Interfaces - \u2705 Abstract classes - \u2705 Open classes (overridable members only)</p> <p>Type System: - \u2705 Full generics (class-level, method-level, constraints, variance) - \u2705 Nullable types - \u2705 Complex stdlib types (<code>Result&lt;T&gt;</code>, <code>List&lt;T&gt;</code>, etc.)</p> <p>Kotlin Features: - \u2705 Suspend functions - \u2705 Properties (<code>val</code>, <code>var</code>) - \u2705 Methods with parameters - \u2705 Inheritance</p>"},{"location":"get-started/why-fakt.html#current-limitations","title":"Current Limitations","text":"<p>Fakt is honest about what it doesn\u2019t support (yet):</p> <ul> <li>\u274c Data classes as <code>@Fake</code> targets (work fine as parameter/return types)</li> <li>\u274c Sealed hierarchies as <code>@Fake</code> targets</li> <li>\u274c Default parameters in interface methods</li> </ul>"},{"location":"get-started/why-fakt.html#the-path-forward","title":"The Path Forward","text":"<p>Fakt represents the convergence of: - Industry best practices (Google\u2019s NiA pattern) - Verified performance data (1,391x MockK penalty eliminated) - Architectural necessity (KMP requires compile-time solutions) - Dual paradigm support (state-based AND interaction-based testing) - Compiler-level stability (FIR \u2192 IR architecture survives K2 updates)</p> <p>For JVM-only teams, Fakt delivers 40% faster test suites<sup>1</sup> and more resilient tests. For KMP teams, Fakt is the only stable fake generator for <code>commonTest</code>, complementing Mokkery\u2019s mocking capabilities with dual paradigm support and full Kotlin type system coverage.</p>"},{"location":"get-started/why-fakt.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Install Fakt and create your first fake in 5 minutes</li> <li>Features - Complete feature reference</li> <li>Usage Guide - Common patterns and examples</li> <li>Testing Patterns - Best practices and strategies</li> <li>Migration from Mocks - Moving from MockK/Mockito to Fakt</li> </ul>"},{"location":"get-started/why-fakt.html#works-cited","title":"Works Cited","text":"<ol> <li> <p>Benchmarking Mockk \u2014 Avoid these patterns for fast unit tests. Kevin Block. https://medium.com/@_kevinb/benchmarking-mockk-avoid-these-patterns-for-fast-unit-tests-220fc225da55 \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Mocking Kotlin classes with Mockito \u2014 the fast way. Brais Gab\u00edn Moreira. https://medium.com/21buttons-tech/mocking-kotlin-classes-with-mockito-the-fast-way-631824edd5ba \u21a9\u21a9</p> </li> <li> <p>Reflection | Kotlin Documentation. https://kotlinlang.org/docs/reflection.html \u21a9</p> </li> <li> <p>Reflection? - Native - Kotlin Discussions. https://discuss.kotlinlang.org/t/reflection/4054 \u21a9</p> </li> <li> <p>Did someone try to use Mockk on KMM project. Kotlin Slack. https://slack-chats.kotlinlang.org/t/10131532/did-someone-try-to-use-mockk-on-kmm-project \u21a9</p> </li> <li> <p>Mock common tests in kotlin using multiplatform. Stack Overflow. https://stackoverflow.com/questions/65491916/mock-common-tests-in-kotlin-using-multiplatform \u21a9</p> </li> <li> <p>Mocking in Kotlin Multiplatform: KSP vs Compiler Plugins. Martin Hristev. https://medium.com/@mhristev/mocking-in-kotlin-multiplatform-ksp-vs-compiler-plugins-4424751b83d7 \u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>MocKMP: a Mocking processor for Kotlin/Multiplatform. Salomon BRYS. https://medium.com/kodein-koders/mockmp-a-mocking-processor-for-kotlin-multiplatform-51957c484fe5 \u21a9</p> </li> <li> <p>Mocks Aren\u2019t Stubs. Martin Fowler. https://martinfowler.com/articles/mocksArentStubs.html \u21a9\u21a9</p> </li> <li> <p>Unit Testing \u2014 Why must you mock me? Craig Walker. https://medium.com/@walkercp/unit-testing-why-must-you-mock-me-69293508dd13 \u21a9</p> </li> <li> <p>Testing on the Toilet: Effective Testing. Google Testing Blog. https://testing.googleblog.com/2014/05/testing-on-toilet-effective-testing.html \u21a9</p> </li> <li> <p>Trade-offs to consider when choosing to use Mocks vs Fakes. HackMD. https://hackmd.io/@pierodibello/Trade-offs-to-consider-when-choosing-to-use-Mocks-vs-Fakes \u21a9</p> </li> <li> <p>android/nowinandroid: A fully functional Android app built entirely with Kotlin and Jetpack Compose. GitHub. https://github.com/android/nowinandroid \u21a9\u21a9</p> </li> <li> <p>Testing strategy and how to test. Now in Android Wiki. https://github.com/android/nowinandroid/wiki/Testing-strategy-and-how-to-test \u21a9\u21a9</p> </li> <li> <p>Testing Kotlin coroutines on Android. Android Developers. https://developer.android.com/kotlin/coroutines/test \u21a9</p> </li> <li> <p>Flow testing with Turbine. Cash App Code Blog. https://code.cash.app/flow-testing-with-turbine \u21a9</p> </li> <li> <p>lupuuss/Mokkery: The mocking library for Kotlin Multiplatform. GitHub. https://github.com/lupuuss/Mokkery \u21a9</p> </li> <li> <p>Kotlin 2.0.0 support \u00b7 Issue #1 \u00b7 lupuuss/Mokkery. GitHub. https://github.com/lupuuss/Mokkery/issues/1 \u21a9</p> </li> <li> <p>Use multiplatform mocking library for tests \u00b7 Issue #5420 \u00b7 streetcomplete/StreetComplete. GitHub. https://github.com/streetcomplete/StreetComplete/issues/5420 \u21a9</p> </li> <li> <p>Kotlin 2.2.0 support \u00b7 Issue #83 \u00b7 lupuuss/Mokkery. GitHub. https://github.com/lupuuss/Mokkery/issues/83 \u21a9</p> </li> <li> <p>Mocking | Mokkery. https://mokkery.dev/docs/Guides/Mocking/ \u21a9</p> </li> <li> <p>A to Z of Testing in Kotlin Multiplatform. Kinto Technologies. https://blog.kinto-technologies.com/posts/2024-12-24-tests-in-kmp/ \u21a9</p> </li> <li> <p>Limitations | Mokkery. https://mokkery.dev/docs/Limitations/ \u21a9</p> </li> <li> <p>Why we should use wiremock instead of Mockito. Stack Overflow. https://stackoverflow.com/questions/50726017/why-we-should-use-wiremock-instead-of-mockito \u21a9</p> </li> <li> <p>Stop Breaking My API: A Practical Guide to Contract Testing with Pact. Medium. https://medium.com/@mohsenny/stop-breaking-my-api-a-practical-guide-to-contract-testing-with-pact-33858d113386 \u21a9</p> </li> <li> <p>Effective migration to Kotlin on Android. Aris Papadopoulos. https://medium.com/android-news/effective-migration-to-kotlin-on-android-cfb92bfaa49b \u21a9</p> </li> </ol>"},{"location":"help/faq.html","title":"Frequently Asked Questions","text":"<p>Common questions about Fakt, answered with honesty and technical context.</p>"},{"location":"help/faq.html#stability-safety","title":"Stability &amp; Safety","text":""},{"location":"help/faq.html#is-fakt-safe-to-use-in-production-testing","title":"Is Fakt safe to use in production testing?","text":"<p>Short answer: Yes. Fakt is functionally stable and ready for production use in test suites.</p> <p>Longer answer: Fakt follows a two-phase FIR \u2192 IR compilation architecture inspired by production compiler plugins like Metro. While the Kotlin compiler plugin API is not a stable API (marked <code>@UnsafeApi</code>), Fakt:</p> <ul> <li>Generates code at compile-time with zero runtime dependencies</li> <li>Has been tested across Kotlin 2.2.21+ and all KMP targets</li> <li>Uses forward compatibility patterns (N+.2 version support)</li> <li>Is versioned as 1.0.0-alpha01 to signal pre-1.0 status</li> </ul> <p>Generated fakes are production-quality code that compiles to native binaries without reflection.</p> <p>Compiler Plugin API Stability</p> <p>The Kotlin compiler plugin API can change between Kotlin versions. Fakt is tested against each Kotlin release and updated as needed. Pin your Kotlin version in production CI/CD.</p>"},{"location":"help/faq.html#why-100-alpha01-instead-of-100","title":"Why \u201c1.0.0-alpha01\u201d instead of \u201c1.0.0\u201d?","text":"<p>SNAPSHOT signals real-world validation in progress, not \u201cbroken.\u201d The API is functionally complete and production-ready. We prioritize honesty over marketing\u20141.0.0 will follow community feedback and battle-testing.</p>"},{"location":"help/faq.html#comparison-with-other-tools","title":"Comparison with Other Tools","text":""},{"location":"help/faq.html#why-not-use-mockk-or-mockito","title":"Why not use MockK or Mockito?","text":"<p>MockK and Mockito are runtime mocking frameworks using reflection (JVM/Android only). Fakt generates fakes at compile-time using Kotlin IR:</p> <ul> <li>\u2705 Works on ALL KMP targets (iOS, Native, JS, WASM) without reflection</li> <li>\u2705 Zero runtime cost, compile-time type safety</li> <li>\u2705 Generated code you can read and debug</li> </ul> <p>Use MockK/Mockito when: You need dynamic mocking or are on JVM-only projects.</p> <p>Use Fakt when: Building Kotlin Multiplatform projects or want zero-runtime-cost test doubles.</p> <p>See Why Fakt for detailed comparison.</p>"},{"location":"help/faq.html#how-does-fakt-compare-to-hand-written-fakes","title":"How does Fakt compare to hand-written fakes?","text":"<p>Fakt generates the same code you\u2019d write manually, but faster and without mistakes:</p> Aspect Hand-Written Fakes Fakt Fakes Boilerplate ~50 lines per interface Auto-generated Call tracking Manual (<code>var count = 0</code>) StateFlow (thread-safe) Refactoring safety Breaks silently Breaks at compile-time Maintenance Scales with codebase Zero maintenance Customization Full control DSL configuration <p>Fakt doesn\u2019t replace hand-written fakes for complex scenarios (stateful mocks, partial implementations). It eliminates boilerplate for the 80% case.</p>"},{"location":"help/faq.html#feature-support","title":"Feature Support","text":""},{"location":"help/faq.html#does-fakt-support-generics","title":"Does Fakt support generics?","text":"<p>Yes. Class-level, method-level, generic constraints, and variance are all supported. See Usage Guide: Generics for detailed examples.</p>"},{"location":"help/faq.html#does-fakt-support-suspend-functions","title":"Does Fakt support suspend functions?","text":"<p>Yes. Suspend functions preserve coroutine semantics. See Usage Guide: Suspend Functions for details.</p>"},{"location":"help/faq.html#does-fakt-support-properties-valvar","title":"Does Fakt support properties (val/var)?","text":"<p>Yes. Both read-only (<code>val</code>) and mutable (<code>var</code>) properties with call tracking. See Usage Guide: Properties for examples.</p>"},{"location":"help/faq.html#can-i-fake-data-classes-or-sealed-classes","title":"Can I fake data classes or sealed classes?","text":"<p>No. Fakt only generates fakes for interfaces, abstract classes, and open classes. Data/sealed classes work fine as parameter/return types.</p>"},{"location":"help/faq.html#performance","title":"Performance","text":""},{"location":"help/faq.html#what-about-performance-impact-on-build-times","title":"What about performance impact on build times?","text":"<p>Fakt uses intelligent caching across KMP targets. First target compilation typically adds ~40ms for 100+ interfaces. Subsequent targets (JVM, iOS, Android) hit cache and add ~1ms each.</p> <p>For large projects (1000+ interfaces), expect:</p> <ul> <li>First compilation: ~200-400ms</li> <li>Cached targets: near-zero overhead (~1-2ms each)</li> </ul> <p>Example from a real KMP project:</p> <pre><code>DISCOVERY: 1ms (100 interfaces, 21 classes)\nGENERATION: 39ms (121 new fakes, avg 333\u00b5s/fake)\nTOTAL: 40ms (iosArm64 first compilation)\n\ncompileKotlinJvm:     1ms (121 from cache)\ncompileKotlinAndroid: 1ms (121 from cache)\n</code></pre> <p>See Performance Guide for detailed benchmarks and telemetry configuration.</p>"},{"location":"help/faq.html#multi-module-projects","title":"Multi-Module Projects","text":""},{"location":"help/faq.html#does-fakt-work-with-multi-module-projects","title":"Does Fakt work with multi-module projects?","text":"<p>Yes, with experimental multi-module support:</p> <pre><code>// Producer module: :core:analytics/build.gradle.kts\n@Fake\ninterface Analytics\n\n// Collector module: :core:analytics-fakes/build.gradle.kts\nplugins {\n    id(\"com.rsicarelli.fakt\")\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\n// Consumer module: :app/build.gradle.kts\ndependencies {\n    commonTest {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n</code></pre> <p>For comprehensive documentation, see: - Multi-Module - Architecture, setup, and implementation details - kmp-multi-module sample - Working example</p> <p>Experimental Feature</p> <p>Multi-module support is marked <code>@ExperimentalFaktMultiModule</code>. It works but the API may change before 1.0.</p>"},{"location":"help/faq.html#troubleshooting","title":"Troubleshooting","text":"<p>For common issues and solutions, see the Troubleshooting Guide:</p> <ul> <li>Generated fakes not appearing in IDE</li> <li>Unresolved reference: fakeXxx</li> <li>Compilation errors</li> <li>Multi-module issues</li> </ul>"},{"location":"help/faq.html#contributing-reporting-issues","title":"Contributing &amp; Reporting Issues","text":""},{"location":"help/faq.html#how-can-i-contribute-to-fakt","title":"How can I contribute to Fakt?","text":"<p>Contributions are welcome! Please:</p> <ol> <li>Follow GIVEN-WHEN-THEN testing standard</li> <li>Ensure all generated code compiles without errors</li> <li>Test both single-platform and KMP scenarios</li> <li>Run <code>make format</code> before committing</li> </ol>"},{"location":"help/faq.html#where-do-i-report-bugs","title":"Where do I report bugs?","text":"<p>Report issues on GitHub Issues. Please include:</p> <ul> <li>Kotlin version</li> <li>Fakt version</li> <li>KMP targets (if applicable)</li> <li>Minimal reproduction (interface + error message)</li> <li>Full compilation logs (<code>./gradlew build --info</code>)</li> </ul>"},{"location":"help/faq.html#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Troubleshooting - Common issues and solutions</li> <li>GitHub Discussions - Ask the community</li> <li>GitHub Issues - Report bugs</li> </ul>"},{"location":"help/troubleshooting.html","title":"Troubleshooting","text":"<p>Common issues and solutions for single-module and multi-module setups.</p>"},{"location":"help/troubleshooting.html#general-issues","title":"General Issues","text":""},{"location":"help/troubleshooting.html#generated-fakes-not-appearing","title":"Generated Fakes Not Appearing","text":"<p>Symptoms: IDE doesn\u2019t recognize <code>fakeXxx()</code> factory functions</p> <p>Solutions:</p> <ol> <li>Rebuild the project: <code>./gradlew clean build</code></li> <li>Invalidate IDE caches: File \u2192 Invalidate Caches \u2192 Invalidate and Restart</li> <li>Check build directory: Fakes are in <code>build/generated/fakt/commonTest/kotlin/</code></li> <li>Verify Gradle sync: Ensure Gradle sync completed successfully</li> </ol>"},{"location":"help/troubleshooting.html#unresolved-reference-fakexxx","title":"Unresolved Reference: fakeXxx","text":"<p>Common causes:</p> <ol> <li>Missing build step: Run <code>./gradlew build</code> first</li> <li>Wrong source set: Import from test code (<code>src/commonTest/</code>), not main</li> <li>Package mismatch: Generated fakes are in the same package as the interface</li> <li>Gradle sync issue: Re-sync Gradle in your IDE</li> </ol>"},{"location":"help/troubleshooting.html#compilation-fails-with-irtypealiassymbol-not-found","title":"Compilation Fails with \u201cIrTypeAliasSymbol not found\u201d","text":"<p>Causes:</p> <ol> <li>Kotlin version mismatch: Ensure you\u2019re on Kotlin 2.2.21+</li> <li>Fakt version incompatibility: Update Fakt to match your Kotlin version</li> </ol> <p>Solution:</p> <pre><code>// gradle/libs.versions.toml\n[versions]\nkotlin = \"2.2.21\"\nfakt = \"1.0.0-alpha01\"\n</code></pre>"},{"location":"help/troubleshooting.html#build-is-slow","title":"Build is Slow","text":"<p>Solutions:</p> <ol> <li> <p>Use LogLevel.QUIET in CI/CD: <pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)\n}\n</code></pre></p> </li> <li> <p>Check cache hit rate with <code>LogLevel.INFO</code></p> </li> <li> <p>Verify incremental compilation is enabled</p> </li> </ol>"},{"location":"help/troubleshooting.html#multi-module-issues","title":"Multi-Module Issues","text":""},{"location":"help/troubleshooting.html#diagnosis-tools","title":"Diagnosis Tools","text":"<p>Enable Debug Logging:</p> <pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.DEBUG)\n}\n</code></pre> <p>Rebuild to see detailed output:</p> <pre><code>./gradlew :core:analytics-fakes:clean :core:analytics-fakes:build --info\n</code></pre> <p>Check Task Execution:</p> <pre><code># View task dependency graph\n./gradlew :core:analytics-fakes:build --dry-run\n\n# Use build scans\n./gradlew build --scan\n</code></pre>"},{"location":"help/troubleshooting.html#issue-1-no-fakes-found-in-source-module","title":"Issue 1: \u201cNo fakes found in source module\u201d","text":"<p>Error: <pre><code>No fakes found in source module 'analytics'.\nVerify that source module has @Fake annotated interfaces.\n</code></pre></p> <p>Causes: 1. Source module has no <code>@Fake</code> interfaces 2. Fakes not generated (compilation failed) 3. Wrong module path in <code>collectFakesFrom()</code></p> <p>Diagnosis:</p> <pre><code># Check for @Fake annotations\ngrep -r \"@Fake\" core/analytics/src/\n\n# Verify fakes were generated\nls core/analytics/build/generated/fakt/\n\n# Check for compilation errors\n./gradlew :core:analytics:build\n</code></pre> <p>Solutions:</p> <pre><code>// \u2705 CORRECT: Collect from producer (has @Fake interfaces)\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n\n// \u274c WRONG: Collecting from collector (no @Fake interfaces)\nfakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analyticsFakes)  // Wrong!\n}\n</code></pre>"},{"location":"help/troubleshooting.html#issue-2-unresolved-reference-fakexxx-multi-module","title":"Issue 2: \u201cUnresolved reference: fakeXxx\u201d (Multi-Module)","text":"<p>Error: <pre><code>// In test file\nval fake = fakeAnalytics { }  // \u2190 Unresolved reference\n</code></pre></p> <p>Causes: 1. Consumer doesn\u2019t depend on collector module 2. Collector module not built 3. IDE not synced 4. Wrong import</p> <p>Diagnosis:</p> <pre><code># Check dependency in consumer\ngrep \"analyticsFakes\" app/build.gradle.kts\n\n# Verify collector was built\nls core/analytics-fakes/build/generated/collected-fakes/\n\n# Check for factory function\ngrep -r \"fun fakeAnalytics\" core/analytics-fakes/build/\n</code></pre> <p>Solutions:</p> <pre><code>// 1. Add dependency to consumer\nkotlin {\n    sourceSets.commonTest.dependencies {\n        implementation(projects.core.analyticsFakes)\n    }\n}\n\n// 2. Sync Gradle and rebuild\n./gradlew --refresh-dependencies build\n\n// 3. Invalidate IDE caches\n// File \u2192 Invalidate Caches \u2192 Invalidate and Restart\n</code></pre>"},{"location":"help/troubleshooting.html#issue-3-targets-mismatch","title":"Issue 3: Targets Mismatch","text":"<p>Error: <pre><code>Cannot find source set 'iosMain' for target 'iosX64'\n</code></pre></p> <p>Cause: Collector has different targets than producer</p> <p>Diagnosis:</p> <pre><code>// Check producer targets\n// core/analytics/build.gradle.kts\nkotlin {\n    jvm()\n    iosArm64()  // \u2190 Producer has this\n}\n\n// Check collector targets\n// core/analytics-fakes/build.gradle.kts\nkotlin {\n    jvm()\n    // Missing: iosArm64()  \u2190 Collector doesn't!\n}\n</code></pre> <p>Solution: Collector MUST have ALL producer\u2019s targets</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nkotlin {\n    jvm()\n    iosArm64()  // \u2705 Added\n    iosX64()\n    iosSimulatorArm64()\n}\n</code></pre>"},{"location":"help/troubleshooting.html#issue-4-wrong-platform-placement","title":"Issue 4: Wrong Platform Placement","text":"<p>Symptom: Fake ends up in wrong source set (e.g., <code>commonMain</code> instead of <code>jvmMain</code>)</p> <p>Cause: Package doesn\u2019t contain platform identifier</p> <p>Diagnosis:</p> <pre><code>// Check generated fake's package\n// core/analytics/build/generated/fakt/jvmTest/kotlin/DatabaseFake.kt\npackage com.example.database  // \u2190 No \"jvm\" segment!\n</code></pre> <p>Solution: Use platform identifier in package name</p> <pre><code>// \u2705 CORRECT: Platform in package\npackage com.example.jvm.database  // \u2192 jvmMain/\npackage com.example.ios.camera    // \u2192 iosMain/\n\n// \u274c WRONG: No platform identifier\npackage com.example.database  // \u2192 commonMain/ (fallback)\n</code></pre>"},{"location":"help/troubleshooting.html#issue-5-circular-dependencies","title":"Issue 5: Circular Dependencies","text":"<p>Error: <pre><code>Circular dependency between:\n:features:payment\n:features:user\n</code></pre></p> <p>Cause: Feature A fakes need Feature B, Feature B fakes need Feature A</p> <p>Solution: Extract shared interfaces to core modules</p> <pre><code>Before (circular):\nfeatures/payment \u2192 features/user\nfeatures/user \u2192 features/payment\n\nAfter (fixed):\ncore/payment-api @Fake interface PaymentProvider\ncore/user-api @Fake interface UserProvider\n\nfeatures/payment \u2192 core/payment-api, core/user-api\nfeatures/user \u2192 core/user-api, core/payment-api\n</code></pre>"},{"location":"help/troubleshooting.html#issue-6-missing-transitive-dependencies","title":"Issue 6: Missing Transitive Dependencies","text":"<p>Error: <pre><code>// In test\nval fake = fakeAnalytics { }  // Compiles\n\n// But runtime error:\nNoClassDefFoundError: kotlinx/coroutines/CoroutineScope\n</code></pre></p> <p>Cause: Collector didn\u2019t declare coroutines dependency</p> <p>Solution:</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nkotlin {\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)\n        implementation(libs.coroutines)  // \u2705 Add this\n    }\n}\n</code></pre> <p>How to identify needed dependencies:</p> <pre><code># Inspect generated code\ncat core/analytics-fakes/build/generated/collected-fakes/commonMain/kotlin/FakeAnalyticsImpl.kt\n\n# Look for imports:\nimport kotlinx.coroutines.*  # \u2192 Need coroutines\nimport kotlinx.serialization.*  # \u2192 Need serialization\n</code></pre>"},{"location":"help/troubleshooting.html#issue-7-ide-not-finding-fakes","title":"Issue 7: IDE Not Finding Fakes","text":"<p>Symptom: Autocomplete doesn\u2019t suggest <code>fakeXxx()</code>, but code compiles</p> <p>Causes: 1. IDE not synced with Gradle 2. Generated sources not indexed 3. Stale IDE caches</p> <p>Solutions:</p> <pre><code># 1. Reload Gradle projects\n# File \u2192 Reload All Gradle Projects\n\n# 2. Invalidate caches\n# File \u2192 Invalidate Caches \u2192 Invalidate and Restart\n\n# 3. Rebuild project\n./gradlew clean build\n\n# 4. Check generated sources are registered\nls core/analytics-fakes/build/generated/collected-fakes/\n</code></pre>"},{"location":"help/troubleshooting.html#issue-8-configuration-cache-failures","title":"Issue 8: Configuration Cache Failures","text":"<p>Error: <pre><code>Configuration cache problems found:\n- field 'project' from type 'FaktGradleSubplugin'\n</code></pre></p> <p>Cause: Using configuration cache with older Fakt version</p> <p>Solution: Update to Fakt 1.0.0-alpha01+ (configuration cache compatible)</p> <pre><code>// gradle.properties\norg.gradle.configuration-cache=true\n</code></pre>"},{"location":"help/troubleshooting.html#error-messages-reference","title":"Error Messages Reference","text":""},{"location":"help/troubleshooting.html#source-project-not-found","title":"\u201cSource project not found\u201d","text":"<pre><code>Source project ':core:analytics' not found.\nVerify module exists and is included in settings.gradle.kts.\n</code></pre> <p>Fix: Add module to <code>settings.gradle.kts</code></p> <pre><code>include(\":core:analytics\")\n</code></pre>"},{"location":"help/troubleshooting.html#collector-and-producer-targets-mismatch","title":"\u201cCollector and producer targets mismatch\u201d","text":"<pre><code>Collector has targets [jvm, js] but producer has [jvm, ios].\nAll producer targets must be present in collector.\n</code></pre> <p>Fix: Add missing targets to collector</p> <pre><code>kotlin {\n    jvm()\n    js()\n    iosArm64()  // \u2705 Add this\n}\n</code></pre>"},{"location":"help/troubleshooting.html#optin-annotation-missing","title":"\u201c@OptIn annotation missing\u201d","text":"<pre><code>Multi-module APIs require opt-in with @OptIn(ExperimentalFaktMultiModule::class)\n</code></pre> <p>Fix: Add opt-in annotation</p> <pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"help/troubleshooting.html#advanced-debugging","title":"Advanced Debugging","text":""},{"location":"help/troubleshooting.html#enable-trace-logging","title":"Enable TRACE Logging","text":"<pre><code>fakt {\n    logLevel.set(com.rsicarelli.fakt.compiler.api.LogLevel.TRACE)\n}\n</code></pre> <p>Shows: - File-by-file collection - Platform detection reasoning - IR generation details - Task execution timing</p>"},{"location":"help/troubleshooting.html#task-dependency-visualization","title":"Task Dependency Visualization","text":"<pre><code># Show task graph\n./gradlew :app:test --dry-run\n\n# Execution timeline\n./gradlew :app:test --scan\n# \u2192 View timeline in build scan\n</code></pre>"},{"location":"help/troubleshooting.html#inspect-generated-code","title":"Inspect Generated Code","text":"<pre><code># View collected fake\ncat core/analytics-fakes/build/generated/collected-fakes/commonMain/kotlin/com/example/FakeAnalyticsImpl.kt\n\n# Compare with original\ncat core/analytics/build/generated/fakt/commonTest/kotlin/com/example/FakeAnalyticsImpl.kt\n</code></pre>"},{"location":"help/troubleshooting.html#verification-checklist","title":"Verification Checklist","text":"<p>Before reporting issues, verify:</p> <p>Single-Module: - [ ] Interface has <code>@Fake</code> annotation - [ ] Project builds successfully (<code>./gradlew build</code>) - [ ] Fakes generated (<code>ls build/generated/fakt/</code>) - [ ] Gradle synced in IDE - [ ] Using Kotlin 2.2.21+</p> <p>Multi-Module: - [ ] Producer module has <code>@Fake</code> annotated interfaces - [ ] Producer builds successfully (<code>./gradlew :core:analytics:build</code>) - [ ] Fakes generated in producer (<code>ls core/analytics/build/generated/fakt/</code>) - [ ] Collector depends on producer with correct path - [ ] Collector has ALL producer\u2019s KMP targets - [ ] Collector declares transitive dependencies - [ ] Consumer depends on collector module - [ ] Gradle synced in IDE - [ ] Using Fakt 1.0.0-alpha01+ - [ ] Kotlin 2.2.21+</p>"},{"location":"help/troubleshooting.html#getting-help","title":"Getting Help","text":"<p>If issues persist:</p> <ol> <li>Enable DEBUG logging and capture output</li> <li>Create minimal reproduction (single module or producer + collector + consumer)</li> <li>Report on GitHub: github.com/rsicarelli/fakt/issues</li> </ol> <p>Include in report: - Fakt version - Kotlin version - Gradle version - KMP targets (if applicable) - Full error message - DEBUG/TRACE log output - Minimal reproduction repository</p>"},{"location":"help/troubleshooting.html#see-also","title":"See Also","text":"<ul> <li>FAQ - Frequently asked questions</li> <li>Multi-Module - Multi-module architecture and setup guide</li> <li>Configuration - Plugin options (coming soon)</li> </ul>"},{"location":"user-guide/generated-code-reference.html","title":"API Reference","text":"<p>Generated code API and patterns.</p>"},{"location":"user-guide/generated-code-reference.html#generated-classes","title":"Generated Classes","text":"<p>For each <code>@Fake</code> annotated interface, Fakt generates three components:</p>"},{"location":"user-guide/generated-code-reference.html#implementation-class","title":"Implementation Class","text":"<pre><code>class Fake{Interface}Impl : {Interface} {\n    // StateFlow call counters\n    val {method}CallCount: StateFlow&lt;Int&gt;\n\n    // Override interface members\n    override fun {method}({params}): {return} = {method}Behavior({params})\n\n    // Internal configuration methods\n    internal fun configure{Method}(behavior: ({params}) -&gt; {return})\n}\n</code></pre>"},{"location":"user-guide/generated-code-reference.html#factory-function","title":"Factory Function","text":"<pre><code>fun fake{Interface}(\n    configure: Fake{Interface}Config.() -&gt; Unit = {}\n): Fake{Interface}Impl\n</code></pre>"},{"location":"user-guide/generated-code-reference.html#configuration-dsl","title":"Configuration DSL","text":"<pre><code>class Fake{Interface}Config(private val fake: Fake{Interface}Impl) {\n    fun {method}(behavior: ({params}) -&gt; {return})\n}\n</code></pre>"},{"location":"user-guide/generated-code-reference.html#naming-conventions","title":"Naming Conventions","text":"Element Pattern Example Implementation class <code>Fake{Interface}Impl</code> <code>FakeAnalyticsImpl</code> Factory function <code>fake{Interface}</code> <code>fakeAnalytics</code> Configuration DSL <code>Fake{Interface}Config</code> <code>FakeAnalyticsConfig</code> Call counter <code>{method}CallCount</code> <code>trackCallCount</code> Configuration method <code>{method}</code> <code>track { }</code>"},{"location":"user-guide/generated-code-reference.html#package-structure","title":"Package Structure","text":"<p>Generated fakes are in the same package as the annotated interface:</p> <pre><code>com.example.services.Analytics (@Fake)\n\u2192 com.example.services.FakeAnalyticsImpl\n\u2192 com.example.services.fakeAnalytics()\n\u2192 com.example.services.FakeAnalyticsConfig\n</code></pre>"},{"location":"user-guide/generated-code-reference.html#generated-code-location","title":"Generated Code Location","text":"Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code>"},{"location":"user-guide/generated-code-reference.html#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Plugin options</li> <li>Compatibility - Kotlin versions</li> <li>Limitations - Known issues</li> </ul>"},{"location":"user-guide/known-issues.html","title":"Limitations","text":"<p>Known limitations and workarounds.</p>"},{"location":"user-guide/known-issues.html#current-limitations","title":"Current Limitations","text":""},{"location":"user-guide/known-issues.html#data-classes-as-fake-targets","title":"\u274c Data Classes as @Fake Targets","text":"<p>Data classes have compiler-generated implementations and can\u2019t be faked.</p> <p>Workaround: Use builders or <code>copy()</code> for test data.</p> <p>Works as parameter/return types:</p> <pre><code>data class User(val id: String, val name: String)\n\n@Fake  // \u2705 This works\ninterface UserRepository {\n    fun getUser(id: String): User  // \u2705 Data class as return type\n}\n</code></pre>"},{"location":"user-guide/known-issues.html#sealed-classes-as-fake-targets","title":"\u274c Sealed Classes as @Fake Targets","text":"<p>Sealed hierarchies can\u2019t be faked directly.</p> <p>Workaround: Use exhaustive when-expressions or visitor patterns.</p>"},{"location":"user-guide/known-issues.html#default-parameters-in-interface-methods","title":"\u274c Default Parameters in Interface Methods","text":"<p>Interfaces with default parameters are not yet supported.</p> <p>Workaround: Use overloaded methods or remove defaults.</p>"},{"location":"user-guide/known-issues.html#reporting-issues","title":"Reporting Issues","text":"<p>Found a limitation not listed here? Report it on GitHub.</p>"},{"location":"user-guide/known-issues.html#next-steps","title":"Next Steps","text":"<ul> <li>FAQ - Common questions</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"user-guide/migration-from-mocks.html","title":"Migration from Mocks","text":"<p>Migrating from mocking frameworks (MockK, Mockito, Mokkery, Mockative) to Fakt compile-time fakes.</p>"},{"location":"user-guide/migration-from-mocks.html#why-migrate","title":"Why Migrate?","text":"<p>Runtime mocking frameworks (MockK, Mockito) rely on reflection and bytecode manipulation, which do not exist on Native or Wasm targets\u2014they cannot run in <code>commonTest</code> source sets for Kotlin Multiplatform. KSP-based alternatives (Mokkery, Mockative, MocKMP) attempt to solve this through compile-time generation but face critical limitations: Mokkery cannot mock <code>object</code> or <code>sealed</code> types, Mockative broke with Kotlin 2.0 forcing mass migrations, and all impose complex APIs with separate stubbing syntax.</p> <p>Mock-based tests couple to implementation details (verifying how methods are called), breaking on valid refactorings. When you change which method is called but the outcome remains the same, mock tests report false failures. This creates brittle test suites that discourage refactoring and accumulate technical debt.</p> <p>Fakt follows Google\u2019s \u201cNow in Android\u201d directive: \u201cDon\u2019t use mocking frameworks. Instead, use fakes.\u201d Fakt generates clean, type-safe fakes that verify outcomes, work across all KMP targets with zero runtime cost, and use DSL lambdas matching your interface signatures\u2014no separate stubbing APIs to learn.</p> <p>Learn more about Fakt\u2019s design philosophy \u2192</p>"},{"location":"user-guide/migration-from-mocks.html#mockk-fakt","title":"MockK \u2192 Fakt","text":""},{"location":"user-guide/migration-from-mocks.html#basic-usage","title":"Basic Usage","text":"<p>MockK:</p> <pre><code>@Test\nfun `GIVEN mock repository WHEN processing user THEN calls getUser`() {\n    val mock = mockk&lt;UserRepository&gt;()\n    every { mock.getUser(any()) } returns User(\"123\", \"Alice\")\n\n    val service = UserService(mock)\n    service.processUser(\"123\")\n\n    verify(exactly = 1) { mock.getUser(\"123\") }\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN fake repository WHEN processing user THEN calls getUser`() {\n    val fake = fakeUserRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    val service = UserService(fake)\n    service.processUser(\"123\")\n\n    assertEquals(1, fake.getUserCallCount.value)\n}\n</code></pre>"},{"location":"user-guide/migration-from-mocks.html#suspend-functions-with-error-handling","title":"Suspend Functions with Error Handling","text":"<p>MockK:</p> <pre><code>@Test\nfun `GIVEN repository failure WHEN fetching data THEN handles error`() = runTest {\n    val mock = mockk&lt;DataService&gt;()\n    coEvery { mock.fetchData() } throws NetworkException(\"Connection timeout\")\n\n    val viewModel = DataViewModel(mock)\n    viewModel.loadData()\n\n    assertTrue(viewModel.errorState.value is Error.Network)\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN repository failure WHEN fetching data THEN handles error`() = runTest {\n    val fake = fakeDataService {\n        fetchData { throw NetworkException(\"Connection timeout\") }\n    }\n\n    val viewModel = DataViewModel(fake)\n    viewModel.loadData()\n\n    assertTrue(viewModel.errorState.value is Error.Network)\n}\n</code></pre> <p>Key difference: Fakt\u2019s DSL lambda has the same signature as the original interface method. No need to learn separate stubbing APIs (<code>coEvery</code>, <code>every</code>, <code>returns</code>).</p>"},{"location":"user-guide/migration-from-mocks.html#mockito-fakt","title":"Mockito \u2192 Fakt","text":"<p>Mockito:</p> <pre><code>@Test\nfun `GIVEN repository WHEN saving user THEN returns success`() {\n    val mock = mock(UserRepository::class.java)\n    `when`(mock.saveUser(any())).thenReturn(Result.success(Unit))\n\n    val service = UserService(mock)\n    val result = service.createUser(\"Alice\")\n\n    assertTrue(result.isSuccess)\n    verify(mock, times(1)).saveUser(any())\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN repository WHEN saving user THEN returns success`() = runTest {\n    val fake = fakeUserRepository {\n        saveUser { user -&gt; Result.success(Unit) }\n    }\n\n    val service = UserService(fake)\n    val result = service.createUser(\"Alice\")\n\n    assertTrue(result.isSuccess)\n    assertEquals(1, fake.saveUserCallCount.value)\n}\n</code></pre>"},{"location":"user-guide/migration-from-mocks.html#mokkery-fakt","title":"Mokkery \u2192 Fakt","text":"<p>Mokkery:</p> <pre><code>@Test\nfun `GIVEN mock analytics WHEN tracking event THEN records event`() = runTest {\n    val mock = mock&lt;Analytics&gt;()\n    everySuspend { mock.track(any()) } returns Unit\n\n    val service = AnalyticsService(mock)\n    service.logUserAction(\"button_click\")\n\n    verifySuspend { mock.track(\"button_click\") }\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN fake analytics WHEN tracking event THEN records event`() = runTest {\n    val trackedEvents = mutableListOf&lt;String&gt;()\n    val fake = fakeAnalytics {\n        track { event -&gt; trackedEvents.add(event) }\n    }\n\n    val service = AnalyticsService(fake)\n    service.logUserAction(\"button_click\")\n\n    assertEquals(1, fake.trackCallCount.value)\n    assertEquals(\"button_click\", trackedEvents.first())\n}\n</code></pre> <p>Migration notes:</p> <ul> <li>Replace <code>mock&lt;T&gt;()</code> with <code>fakeT {}</code></li> <li>Replace <code>everySuspend { }</code> with DSL lambda configuration</li> <li>Replace <code>verifySuspend { }</code> with StateFlow call counters</li> <li>State-based verification (checking <code>trackedEvents</code>) is more resilient than interaction verification</li> </ul>"},{"location":"user-guide/migration-from-mocks.html#mockative-fakt","title":"Mockative \u2192 Fakt","text":"<p>Mockative:</p> <pre><code>@Test\nfun `GIVEN repository WHEN fetching user THEN returns user`() = runTest {\n    val mock = mock&lt;UserRepository&gt;()\n    given(mock).coroutine { getUser(\"123\") }.thenReturn(User(\"123\", \"Alice\"))\n\n    val viewModel = UserViewModel(mock)\n    viewModel.loadUser(\"123\")\n\n    assertEquals(\"Alice\", viewModel.userName.value)\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN repository WHEN fetching user THEN returns user`() = runTest {\n    val fake = fakeUserRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    val viewModel = UserViewModel(fake)\n    viewModel.loadUser(\"123\")\n\n    assertEquals(\"Alice\", viewModel.userName.value)\n    assertEquals(1, fake.getUserCallCount.value)\n}\n</code></pre>"},{"location":"user-guide/migration-from-mocks.html#generic-repositories","title":"Generic Repositories","text":"<p>MockK:</p> <pre><code>@Test\nfun `GIVEN generic repository WHEN saving item THEN returns success`() {\n    val mock = mockk&lt;Repository&lt;User&gt;&gt;()\n    every { mock.save(any()) } returns Result.success(Unit)\n\n    val service = CrudService(mock)\n    service.createUser(User(\"123\", \"Alice\"))\n\n    verify { mock.save(any&lt;User&gt;()) }\n}\n</code></pre> <p>Fakt:</p> <pre><code>@Test\nfun `GIVEN generic repository WHEN saving item THEN returns success`() {\n    val fake = fakeRepository&lt;User&gt; {\n        save { item -&gt; Result.success(Unit) }\n    }\n\n    val service = CrudService(fake)\n    service.createUser(User(\"123\", \"Alice\"))\n\n    assertEquals(1, fake.saveCallCount.value)\n}\n</code></pre> <p>Type safety: Fakt preserves generic type parameters. The DSL lambda receives <code>item: User</code>, not <code>item: Any</code>.</p>"},{"location":"user-guide/migration-from-mocks.html#next-steps","title":"Next Steps","text":"<ul> <li>Testing Patterns - Best practices for fake-based testing</li> <li>Usage Guide - Core Fakt patterns and examples</li> <li>Performance - Build time impact and optimization</li> </ul>"},{"location":"user-guide/multi-module.html","title":"Multi-Module Support","text":"<p>Fakt\u2019s multi-module support enables fake reuse across multiple Gradle modules through dedicated collector modules.</p> <p>Experimental API</p> <p>Multi-module support is marked <code>@ExperimentalFaktMultiModule</code>. The API is production-ready but may evolve based on real-world feedback. Explicit opt-in is required.</p>"},{"location":"user-guide/multi-module.html#what-is-multi-module-support","title":"What is Multi-Module Support?","text":"<p>Multi-module support allows you to:</p> <ul> <li>Generate fakes once in a producer module with <code>@Fake</code> interfaces</li> <li>Collect fakes in a dedicated collector module</li> <li>Use fakes across multiple consumer modules in tests</li> </ul> <p>This eliminates fake duplication and enables clean dependency management in large projects.</p>"},{"location":"user-guide/multi-module.html#architecture-producer-collector-consumer","title":"Architecture: Producer \u2192 Collector \u2192 Consumer","text":"<p>Fakt\u2019s multi-module pattern uses three distinct roles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PRODUCER MODULE (:core:analytics)                              \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Contains @Fake annotated interfaces                          \u2502\n\u2502  \u2022 Fakt generates fakes at compile-time                         \u2502\n\u2502  \u2022 Output: build/generated/fakt/commonTest/kotlin/              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  COLLECTOR MODULE (:core:analytics-fakes) \u2020                     \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Collects generated fakes from producer                       \u2502\n\u2502  \u2022 FakeCollectorTask copies fakes with platform detection       \u2502\n\u2502  \u2022 Output: build/generated/collected-fakes/{platform}/kotlin/   \u2502\n\u2502  \u2022 Published as standard Gradle dependency                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  CONSUMER MODULES (:app, :features:login, etc.)                 \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550       \u2502\n\u2502  \u2022 Depend on collector module in tests                          \u2502\n\u2502  \u2022 Use fakes via generated factory functions                    \u2502\n\u2502  \u2022 No direct dependency on producer's test code                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u2020 Naming is flexible - can be :analytics-fakes, :analytics-test,\n  :analytics-test-fixtures, or any name you choose\n</code></pre>"},{"location":"user-guide/multi-module.html#when-to-use-multi-module","title":"When to Use Multi-Module?","text":""},{"location":"user-guide/multi-module.html#use-multi-module-when","title":"\u2705 Use Multi-Module When","text":"<ul> <li>Multiple modules need the same fakes (e.g., <code>core/logger</code> used by 10+ feature modules)</li> <li>Publishing fakes as artifacts (Maven Central, internal repository)</li> <li>Strict module boundaries (DDD, Clean Architecture, modular monoliths)</li> <li>Large teams with module ownership (dedicated teams per module)</li> <li>Shared test infrastructure (common fakes for integration tests)</li> </ul>"},{"location":"user-guide/multi-module.html#use-single-module-when","title":"\u274c Use Single-Module When","text":"<ul> <li>Single module or 2-3 closely related modules</li> <li>Fakes only used locally (not shared across modules)</li> <li>Small team or early prototyping (prefer simplicity)</li> <li>Rapid iteration (multi-module adds slight build overhead)</li> </ul>"},{"location":"user-guide/multi-module.html#setup","title":"Setup","text":""},{"location":"user-guide/multi-module.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>\u2705 Kotlin Multiplatform or JVM project with multiple Gradle modules</li> <li>\u2705 Fakt plugin installed (see Getting Started)</li> <li>\u2705 Basic understanding of Gradle module structure</li> <li>\u2705 Type-safe project accessors enabled in <code>settings.gradle.kts</code></li> </ul> <p>Type-Safe Project Accessors</p> <p>If you don\u2019t have type-safe accessors enabled, add to <code>settings.gradle.kts</code>: <pre><code>enableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n</code></pre> Then sync Gradle to generate <code>projects.*</code> accessors.</p>"},{"location":"user-guide/multi-module.html#tutorial-overview","title":"Tutorial Overview","text":"<p>We\u2019ll create a simple multi-module setup:</p> <pre><code>my-project/\n\u251c\u2500\u2500 core/analytics/           # Producer (defines @Fake interfaces)\n\u251c\u2500\u2500 core/analytics-fakes/     # Collector (collects generated fakes)\n\u2514\u2500\u2500 app/                      # Consumer (uses fakes in tests)\n</code></pre> <p>Time: ~15 minutes</p>"},{"location":"user-guide/multi-module.html#step-1-create-producer-module","title":"Step 1: Create Producer Module","text":"<p>The producer module contains <code>@Fake</code> annotated interfaces.</p> <pre><code>// core/analytics/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.21\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-alpha01\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n\n    sourceSets.commonMain.dependencies {\n        implementation(\"com.rsicarelli.fakt:runtime:1.0.0-alpha01\")\n    }\n}\n</code></pre> <p>Define <code>@Fake</code> interface:</p> <pre><code>// core/analytics/src/commonMain/kotlin/Analytics.kt\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    suspend fun identify(userId: String)\n}\n</code></pre> <p>Build the module: <code>./gradlew :core:analytics:build</code></p> <p>Verify fakes generated in <code>build/generated/fakt/commonTest/kotlin/</code></p>"},{"location":"user-guide/multi-module.html#step-2-create-collector-module","title":"Step 2: Create Collector Module","text":"<p>The collector module collects generated fakes and makes them available to other modules. Name it anything (<code>:core:analytics-fakes</code>, <code>:analytics-test</code>, etc.).</p> <pre><code>// core/analytics-fakes/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.21\"\n    id(\"com.rsicarelli.fakt\") version \"1.0.0-alpha01\"\n}\n\nkotlin {\n    jvm()  // MUST match producer's targets\n    iosArm64()\n\n    sourceSets.commonMain.dependencies {\n        api(projects.core.analytics)  // CRITICAL: Use api() to expose types\n        implementation(libs.coroutines)  // Add dependencies used by fakes\n    }\n}\n\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Key points: Use <code>api()</code> for producer dependency, match all producer targets, declare transitive dependencies.</p> <p>Build and verify: <code>./gradlew :core:analytics-fakes:build</code></p> <p>Verify fakes collected in <code>build/generated/collected-fakes/commonMain/kotlin/</code></p> <p>Naming Flexibility</p> <p>The collector module can be named anything you prefer:</p> <ul> <li><code>:core:analytics-fakes</code> \u2705 (recommended convention)</li> <li><code>:core:analytics-test</code> \u2705</li> <li><code>:core:analytics-test-fixtures</code> \u2705</li> <li><code>:test:analytics</code> \u2705</li> <li><code>:testFixtures:analytics</code> \u2705</li> </ul> <p>Fakt doesn\u2019t impose any naming convention. Choose what fits your project best.</p>"},{"location":"user-guide/multi-module.html#step-3-register-modules-in-settingsgradlekts","title":"Step 3: Register Modules in settings.gradle.kts","text":"<p>Add both modules to your project:</p> <pre><code>// settings.gradle.kts\nenableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n\nrootProject.name = \"my-project\"\n\ninclude(\":core:analytics\")\ninclude(\":core:analytics-fakes\")\ninclude(\":app\")\n</code></pre> <p>Sync Gradle to generate type-safe accessors (<code>projects.core.analytics</code>, etc.).</p>"},{"location":"user-guide/multi-module.html#step-4-use-fakes-in-consumer-module","title":"Step 4: Use Fakes in Consumer Module","text":"<p>Now use the collected fakes in your app or feature modules.</p>"},{"location":"user-guide/multi-module.html#configure-appbuildgradlekts","title":"Configure app/build.gradle.kts","text":"<pre><code>// app/build.gradle.kts\nplugins {\n    kotlin(\"multiplatform\") version \"2.2.21\"\n}\n\nkotlin {\n    jvm()\n    iosArm64()\n    iosX64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        commonMain {\n            dependencies {\n                // Main code depends on original interfaces\n                implementation(projects.core.analytics)\n            }\n        }\n\n        commonTest {\n            dependencies {\n                implementation(kotlin(\"test\"))\n\n                // Tests depend on collector module\n                implementation(projects.core.analyticsFakes)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/multi-module.html#write-a-test","title":"Write a Test","text":"<pre><code>// app/src/commonTest/kotlin/com/example/app/AppTest.kt\npackage com.example.app\n\nimport com.example.core.analytics.Analytics\nimport kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AppTest {\n    @Test\n    fun `GIVEN analytics fake WHEN tracking event THEN should capture call`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val analytics: Analytics = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n            identify { userId -&gt; println(\"User: $userId\") }\n        }\n\n        analytics.track(\"user_login\")\n        analytics.track(\"user_signup\")\n\n        assertEquals(listOf(\"user_login\", \"user_signup\"), events)\n        assertEquals(2, analytics.trackCallCount.value)\n    }\n\n    @Test\n    fun `GIVEN analytics fake WHEN identify THEN should call suspend function`() = runTest {\n        val analytics = fakeAnalytics {\n            identify { userId -&gt; println(\"User: $userId\") }\n        }\n\n        analytics.identify(\"user-123\")\n\n        assertEquals(1, analytics.identifyCallCount.value)\n    }\n}\n</code></pre>"},{"location":"user-guide/multi-module.html#run-tests","title":"Run Tests","text":"<pre><code>./gradlew :app:test\n</code></pre> <p>Expected: All tests pass \u2705</p>"},{"location":"user-guide/multi-module.html#step-5-verify-the-setup","title":"Step 5: Verify the Setup","text":""},{"location":"user-guide/multi-module.html#build-entire-project","title":"Build Entire Project","text":"<pre><code>./gradlew build\n</code></pre>"},{"location":"user-guide/multi-module.html#check-generated-code-locations","title":"Check Generated Code Locations","text":"<p>Producer (<code>:core:analytics</code>): <pre><code>core/analytics/build/generated/fakt/\n\u251c\u2500\u2500 commonTest/kotlin/com/example/core/analytics/\n\u2502   \u251c\u2500\u2500 FakeAnalyticsImpl.kt\n\u2502   \u251c\u2500\u2500 fakeAnalytics.kt\n\u2502   \u2514\u2500\u2500 FakeAnalyticsConfig.kt\n</code></pre></p> <p>Collector (<code>:core:analytics-fakes</code>): <pre><code>core/analytics-fakes/build/generated/collected-fakes/\n\u251c\u2500\u2500 commonMain/kotlin/com/example/core/analytics/\n\u2502   \u251c\u2500\u2500 FakeAnalyticsImpl.kt\n\u2502   \u251c\u2500\u2500 fakeAnalytics.kt\n\u2502   \u2514\u2500\u2500 FakeAnalyticsConfig.kt\n\u251c\u2500\u2500 jvmMain/kotlin/  (if JVM-specific fakes exist)\n\u2514\u2500\u2500 iosMain/kotlin/  (if iOS-specific fakes exist)\n</code></pre></p> <p>Consumer (<code>:app</code>): - No generated code (uses compiled fakes from collector dependency)</p>"},{"location":"user-guide/multi-module.html#verify-ide-autocomplete","title":"Verify IDE Autocomplete","text":"<p>In your test file, type <code>fake</code> and verify IDE suggests: - <code>fakeAnalytics()</code></p> <p>If not appearing, try: 1. File \u2192 Reload All Gradle Projects 2. File \u2192 Invalidate Caches \u2192 Invalidate and Restart</p>"},{"location":"user-guide/multi-module.html#multi-producer-example","title":"Multi-Producer Example","text":"<p>For projects with multiple core modules:</p> <p>1. Create additional producers (logger, auth, etc.) with <code>@Fake</code> interfaces</p> <p>2. Create corresponding collectors: <pre><code>// core/logger-fakes/build.gradle.kts\nfakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.logger)\n}\n</code></pre></p> <p>3. Add all collectors as test dependencies: <pre><code>// app/build.gradle.kts\ncommonTest.dependencies {\n    implementation(projects.core.analyticsFakes)\n    implementation(projects.core.loggerFakes)\n    implementation(projects.core.authFakes)\n}\n</code></pre></p> <p>4. Compose multiple fakes in tests: <pre><code>@Test\nfun `test using multiple fakes`() = runTest {\n    val analytics = fakeAnalytics { track { event -&gt; /* ... */ } }\n    val logger = fakeLogger { info { msg -&gt; /* ... */ } }\n    val auth = fakeAuthProvider { login { Result.success(User(\"123\")) } }\n\n    // Test your use case with composed fakes\n}\n</code></pre></p>"},{"location":"user-guide/multi-module.html#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"user-guide/multi-module.html#pattern-1-type-safe-project-accessors-recommended","title":"Pattern 1: Type-Safe Project Accessors (Recommended)","text":"<pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> <p>Benefits: - IDE autocomplete - Compile-time safety - Refactoring support</p>"},{"location":"user-guide/multi-module.html#pattern-2-string-based-paths","title":"Pattern 2: String-Based Paths","text":"<pre><code>fakt {\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(project(\":core:analytics\"))\n}\n</code></pre> <p>Use When: - Type-safe accessors not available - Dynamic module names - Cross-project references</p>"},{"location":"user-guide/multi-module.html#implementation-details","title":"Implementation Details","text":""},{"location":"user-guide/multi-module.html#how-it-works","title":"How It Works","text":"<p>Fakt\u2019s multi-module flow follows three phases:</p> <p>1. Producer generates fakes at compile-time in test source sets (<code>build/generated/fakt/commonTest/</code>)</p> <p>2. Collector copies fakes using <code>FakeCollectorTask</code>: - Discovers generated fakes from producer - Analyzes package structure to detect target platform (e.g., <code>com.example.jvm.*</code> \u2192 <code>jvmMain/</code>) - Copies fakes to collector\u2019s source sets (<code>build/generated/collected-fakes/commonMain/</code>) - Registers as source roots for compilation</p> <p>3. Consumer uses fakes as standard dependencies: <pre><code>dependencies {\n    commonTestImplementation(projects.core.analyticsFakes)\n}\n</code></pre></p> <p>The collector exposes both original interfaces (via <code>api()</code>) and compiled fakes.</p>"},{"location":"user-guide/multi-module.html#real-world-patterns","title":"Real-World Patterns","text":"<p>This producer-collector-consumer pattern is used in production apps and architectural patterns:</p> <ul> <li>Multi-module Android apps like Now in Android (NIA)</li> <li>Clean Architecture projects with strict layer boundaries</li> <li>Domain-Driven Design (DDD) module structures</li> </ul> <p>The pattern enables teams to maintain clear module boundaries while sharing test infrastructure efficiently.</p>"},{"location":"user-guide/multi-module.html#key-benefits","title":"Key Benefits","text":"<ul> <li>Fake Reuse: Generate fakes once in producer, use across multiple consumer modules</li> <li>Clean Dependencies: Standard Gradle dependencies (<code>implementation(projects.core.analyticsFakes)</code>)</li> <li>Publishable Artifacts: Collectors are normal modules that can be published to Maven Central or internal repos</li> <li>Platform Awareness: Automatic platform detection places fakes in correct KMP source sets (jvmMain, iosMain, commonMain)</li> <li>Type Safety: Compile-time errors if interfaces change, preventing broken tests</li> </ul>"},{"location":"user-guide/multi-module.html#next-steps","title":"Next Steps","text":"<p>You\u2019ve successfully set up multi-module support! \ud83c\udf89</p> <p>Learn More:</p> <ul> <li>Troubleshooting - Common issues &amp; solutions</li> <li>Examples - Production-quality kmp-multi-module example (11 modules)</li> <li>Plugin Configuration - Advanced configuration options</li> <li>Performance &amp; Optimization - Build performance tuning</li> </ul>"},{"location":"user-guide/performance.html","title":"Performance","text":"<p>Fakt\u2019s compile-time impact and telemetry system.</p>"},{"location":"user-guide/performance.html#build-time-impact","title":"Build Time Impact","text":"<p>Fakt uses intelligent caching across KMP targets:</p> <p>First target compilation:</p> <pre><code>DISCOVERY: 1ms (100 interfaces, 21 classes)\nGENERATION: 39ms (121 new fakes, avg 333\u00b5s/fake)\nTOTAL: 40ms\n</code></pre> <p>Subsequent targets (cached):</p> <pre><code>compileKotlinJvm:     1ms (121 from cache)\ncompileKotlinAndroid: 1ms (121 from cache)\ncompileKotlinIosX64:  1ms (121 from cache)\n</code></pre>"},{"location":"user-guide/performance.html#telemetry-configuration","title":"Telemetry Configuration","text":"<p>Four log levels for debugging and performance analysis:</p> <pre><code>import com.rsicarelli.fakt.compiler.api.LogLevel\n\nfakt {\n    logLevel.set(LogLevel.INFO)   // Default: concise summary\n    // LogLevel.QUIET  - Zero output (CI/CD)\n    // LogLevel.DEBUG  - Detailed breakdown with FIR + IR details\n}\n</code></pre>"},{"location":"user-guide/performance.html#log-level-outputs","title":"Log Level Outputs","text":"<p>INFO (default):</p> <pre><code>\u2705 10 fakes generated in 1.2s (6 cached)\n   Discovery: 120ms | Analysis: 340ms | Generation: 580ms\n   Cache hit rate: 40% (6/15)\n</code></pre> <p>DEBUG:</p> <pre><code>[DISCOVERY] 120ms - 15 interfaces, 3 classes\n[FILTERING] 85ms - Cache hits: 6/15 (40%)\n[ANALYSIS] 340ms\n  \u251c\u2500 UserRepository (18ms)\n  \u251c\u2500 Analytics (42ms)\n  \u251c\u2500 FIR + IR node inspection, type resolution\n</code></pre> <p>Includes full FIR + IR details, type resolution, etc. (~5-10ms overhead)</p>"},{"location":"user-guide/performance.html#cache-strategy","title":"Cache Strategy","text":"<p>Fakt caches generated code across:</p> <ul> <li>KMP targets (jvm, ios, android, etc.)</li> <li>Incremental compilation runs</li> <li>Clean builds (invalidates cache)</li> </ul>"},{"location":"user-guide/performance.html#best-practices","title":"Best Practices","text":""},{"location":"user-guide/performance.html#use-quiet-in-cicd","title":"\u2705 Use QUIET in CI/CD","text":"<pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)  // Zero overhead\n}\n</code></pre>"},{"location":"user-guide/performance.html#use-debug-for-troubleshooting","title":"\u2705 Use DEBUG for Troubleshooting","text":"<pre><code>fakt {\n    logLevel.set(LogLevel.DEBUG)  // ~5-10ms overhead\n}\n</code></pre>"},{"location":"user-guide/performance.html#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Plugin options</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"user-guide/platform-support.html","title":"Compatibility","text":"<p>Platform and version requirements.</p>"},{"location":"user-guide/platform-support.html#kotlin-version-support","title":"Kotlin Version Support","text":"Fakt Version Kotlin Version Support 1.0.0-alpha01 2.2.21 - 2.2.30 <p>Fakt follows forward compatibility on a best-effort basis (usually N+.2 minor versions).</p>"},{"location":"user-guide/platform-support.html#gradle-version","title":"Gradle Version","text":"<ul> <li>Minimum: Gradle 8.0</li> <li>Recommended: Gradle 8.10+</li> </ul>"},{"location":"user-guide/platform-support.html#jvm-version","title":"JVM Version","text":"<ul> <li>Minimum: JVM 11</li> <li>Recommended: JVM 21+</li> </ul>"},{"location":"user-guide/platform-support.html#platform-support","title":"Platform Support","text":"<p>Works on all Kotlin Multiplatform targets:</p> <ul> <li>\u2705 JVM, Android</li> <li>\u2705 iOS (arm64, x64, simulator)</li> <li>\u2705 macOS, Linux, Windows</li> <li>\u2705 JavaScript (IR), WebAssembly</li> <li>\u2705 watchOS, tvOS</li> </ul> <p>Single-platform projects (JVM-only, Android-only) are fully supported.</p>"},{"location":"user-guide/platform-support.html#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Setup guide</li> <li>Limitations - Known issues</li> </ul>"},{"location":"user-guide/plugin-configuration.html","title":"Plugin Configuration","text":"<p>Complete reference for configuring the Fakt Gradle plugin.</p>"},{"location":"user-guide/plugin-configuration.html#complete-configuration-reference","title":"Complete Configuration Reference","text":"<p>All available configuration options in your module\u2019s <code>build.gradle.kts</code>:</p> <pre><code>// build.gradle.kts\nimport com.rsicarelli.fakt.compiler.api.LogLevel\n\nplugins {\n    alias(libs.plugins.fakt)\n}\n\nfakt {\n    // Enable or disable the plugin (default: true)\n    enabled.set(true)\n\n    // Control logging verbosity (default: INFO)\n    logLevel.set(LogLevel.INFO)  // Options: QUIET, INFO, DEBUG\n\n    // Multi-module: Collect fakes from another module (default: not set)\n    @OptIn(com.rsicarelli.fakt.compiler.api.ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"user-guide/plugin-configuration.html#configuration-properties","title":"Configuration Properties","text":"FlagDefaultExample enabled <code>true</code> <pre><code>fakt {\n    enabled.set(false)\n}\n</code></pre> logLevel <code>INFO</code> <pre><code>fakt {\n    logLevel.set(LogLevel.DEBUG)\n}\n</code></pre> collectFrom Not set <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre>"},{"location":"user-guide/plugin-configuration.html#log-level-details","title":"Log Level Details","text":"LevelDescriptionExample INFO(default)   Concise summary with key metrics. Use for local development and monitoring cache effectiveness.   <pre><code>fakt {\n    logLevel.set(LogLevel.INFO)\n}\n</code></pre> Output: <pre><code>Fakt: 101 fakes generated in 35ms (50 cached)\n  Interfaces: 101 | Classes: 0\n  FIR: 6ms | IR: 29ms\n  Cache: 50/101 (49%)\n</code></pre> DEBUG   Detailed FIR + IR phase timing. Use for troubleshooting, performance analysis, and bug reports.   <pre><code>fakt {\n    logLevel.set(LogLevel.DEBUG)\n}\n</code></pre> Output: <pre><code>Registering FIR extension\nRegistering IR extension with FIR metadata access\nBuilt IR class map with 149 classes\nFIR\u2192IR Transformation (interfaces: 101/101, took 1ms)\nFIR + IR trace\n\u251c\u2500 Total FIR time: 6ms\n\u251c\u2500 Total IR time: 58ms\n\u2502  \u251c\u2500 FIR analysis: 1 type parameters, 6 members (55\u00b5s)\n\u2502  \u2514\u2500 IR generation: FakeDataCacheImpl 83 LOC (766\u00b5s)\n\u2502  \u251c\u2500 FIR analysis: 2 type parameters, 1 members (23\u00b5s)\n\u2502  \u2514\u2500 IR generation: FakeMapTransformerImpl 23 LOC (335\u00b5s)\n</code></pre> QUIET   No output except errors. Use for CI/CD pipelines and production builds.   <pre><code>fakt {\n    logLevel.set(LogLevel.QUIET)\n}\n</code></pre> Output: None (silent)"},{"location":"user-guide/plugin-configuration.html#multi-module-configuration","title":"Multi-Module Configuration","text":"ModeExample Type-safe accessor <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(projects.core.analytics)\n}\n</code></pre> String-based path <pre><code>fakt {\n    @OptIn(ExperimentalFaktMultiModule::class)\n    collectFakesFrom(project(\":core:analytics\"))\n}\n</code></pre> <p>For complete multi-module documentation, see Multi-Module Guide.</p>"},{"location":"user-guide/plugin-configuration.html#ide-integration","title":"IDE Integration","text":""},{"location":"user-guide/plugin-configuration.html#intellij-idea-android-studio","title":"IntelliJ IDEA / Android Studio","text":"<p>Generated fakes appear in <code>build/generated/fakt/</code> and are automatically indexed.</p> <p>Enable K2 Mode for better autocomplete:</p> <ol> <li>Settings \u2192 Languages &amp; Frameworks \u2192 Kotlin</li> <li>Enable K2 mode</li> <li>Restart IDE</li> </ol> <p>K2 mode improves factory function autocomplete and type inference.</p>"},{"location":"user-guide/plugin-configuration.html#generated-sources-location","title":"Generated Sources Location","text":"Source Set Generated Output <code>commonTest/</code> <code>build/generated/fakt/commonTest/kotlin/</code> <code>jvmTest/</code> <code>build/generated/fakt/jvmTest/kotlin/</code> <code>iosTest/</code> <code>build/generated/fakt/iosTest/kotlin/</code> <code>androidUnitTest/</code> <code>build/generated/fakt/androidUnitTest/kotlin/</code>"},{"location":"user-guide/plugin-configuration.html#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Module Setup - Cross-module fakes architecture</li> <li>Usage Guide - Comprehensive usage patterns and examples</li> <li>Troubleshooting - Common configuration issues</li> </ul>"},{"location":"user-guide/testing-patterns.html","title":"Testing Patterns","text":"<p>Best practices for using Fakt-generated fakes in your test suites.</p>"},{"location":"user-guide/testing-patterns.html#isolated-fakes-per-test","title":"Isolated Fakes Per Test","text":"<p>Create fresh fakes for each test to avoid shared state:</p> <pre><code>class UserServiceTest {\n    @Test\n    fun `test case 1`() {\n        val fake = fakeRepository {  // Fresh fake\n            getUser { id -&gt; User(id, \"Alice\") }\n        }\n        // Test with Alice\n    }\n\n    @Test\n    fun `test case 2`() {\n        val fake = fakeRepository {  // Fresh fake\n            getUser { id -&gt; User(id, \"Bob\") }\n        }\n        // Test with Bob\n    }\n}\n</code></pre> <p>Why this matters: - Prevents test pollution (one test affecting another) - Makes tests order-independent - Easier to understand test setup</p>"},{"location":"user-guide/testing-patterns.html#configure-only-what-you-need","title":"Configure Only What You Need","text":"<p>Don\u2019t configure methods you don\u2019t use in the test:</p> <pre><code>@Test\nfun `GIVEN repository WHEN getting user THEN returns user`() {\n    val fake = fakeRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n        // Don't configure saveUser, deleteUser, etc. if not used\n    }\n\n    val user = fake.getUser(\"123\")\n    assertEquals(\"Alice\", user.name)\n}\n</code></pre> <p>Benefits: - Tests are easier to read (only relevant setup visible) - Reduces noise in test code - Smart defaults handle unconfigured methods</p>"},{"location":"user-guide/testing-patterns.html#verify-behavior-not-implementation","title":"Verify Behavior, Not Implementation","text":"<p>Use call counters to verify interactions:</p> <pre><code>@Test\nfun `GIVEN service WHEN processing user THEN calls repository once`() {\n    val fakeRepo = fakeRepository()\n    val service = UserService(fakeRepo)\n\n    service.processUser(\"123\")\n\n    assertEquals(1, fakeRepo.getUserCallCount.value)\n    assertEquals(1, fakeRepo.saveUserCallCount.value)\n}\n</code></pre> <p>State-based verification example:</p> <pre><code>@Test\nfun `GIVEN repository WHEN saving users THEN all users are saved`() {\n    val savedUsers = mutableListOf&lt;User&gt;()\n    val fake = fakeRepository {\n        saveUser { user -&gt;\n            savedUsers.add(user)\n            Result.success(Unit)\n        }\n    }\n\n    val service = UserService(fake)\n    service.batchSave(listOf(alice, bob))\n\n    // Verify OUTCOME (state), not method calls\n    assertEquals(2, savedUsers.size)\n    assertTrue(savedUsers.contains(alice))\n    assertTrue(savedUsers.contains(bob))\n}\n</code></pre>"},{"location":"user-guide/testing-patterns.html#test-edge-cases","title":"Test Edge Cases","text":"<p>Configure fakes to test error handling:</p> <pre><code>@Test\nfun `GIVEN repository failure WHEN saving user THEN handles error`() = runTest {\n    val fake = fakeRepository {\n        saveUser { user -&gt;\n            Result.failure(NetworkException())\n        }\n    }\n    val service = UserService(fake)\n\n    val result = service.createUser(\"Alice\")\n\n    assertTrue(result.isFailure)\n}\n</code></pre>"},{"location":"user-guide/testing-patterns.html#use-turbine-for-reactive-testing","title":"Use Turbine for Reactive Testing","text":"<p>Test StateFlow call counters reactively:</p> <pre><code>@Test\nfun `GIVEN fake WHEN calling repeatedly THEN emits counts`() = runTest {\n    val fake = fakeAnalytics()\n\n    fake.trackCallCount.test {\n        assertEquals(0, awaitItem())\n\n        fake.track(\"event1\")\n        assertEquals(1, awaitItem())\n\n        fake.track(\"event2\")\n        assertEquals(2, awaitItem())\n    }\n}\n</code></pre>"},{"location":"user-guide/testing-patterns.html#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":""},{"location":"user-guide/testing-patterns.html#shared-fakes-across-tests","title":"\u274c Shared Fakes Across Tests","text":"<pre><code>// \u274c BAD: Shared fake\nclass UserServiceTest {\n    private val sharedFake = fakeRepository()  // State leaks between tests\n\n    @Test\n    fun test1() { /* uses sharedFake */ }\n\n    @Test\n    fun test2() { /* uses same sharedFake - FLAKY! */ }\n}\n</code></pre> <pre><code>// \u2705 GOOD: Fresh fake per test\nclass UserServiceTest {\n    @Test\n    fun test1() {\n        val fake = fakeRepository()  // Isolated\n    }\n\n    @Test\n    fun test2() {\n        val fake = fakeRepository()  // Independent\n    }\n}\n</code></pre>"},{"location":"user-guide/testing-patterns.html#over-configuring-fakes","title":"\u274c Over-Configuring Fakes","text":"<pre><code>// \u274c BAD: Configuring unused methods\n@Test\nfun `test getUser only`() {\n    val fake = fakeRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n        saveUser { /* not used in this test */ }\n        deleteUser { /* not used in this test */ }\n        listUsers { /* not used in this test */ }\n    }\n\n    val user = fake.getUser(\"123\")  // Only this is tested\n}\n</code></pre> <pre><code>// \u2705 GOOD: Configure only what's needed\n@Test\nfun `test getUser only`() {\n    val fake = fakeRepository {\n        getUser { id -&gt; User(id, \"Alice\") }\n        // Smart defaults handle the rest\n    }\n\n    val user = fake.getUser(\"123\")\n}\n</code></pre>"},{"location":"user-guide/testing-patterns.html#next-steps","title":"Next Steps","text":"<ul> <li>Migration Guide - From MockK/Mockito to Fakt</li> <li>Performance - Build time impact and optimization</li> <li>Usage Guide - Core patterns and examples</li> </ul>"},{"location":"user-guide/usage.html","title":"Usage Guide","text":"<p>Comprehensive reference for using Fakt-generated fakes in your tests. This guide covers everything from basic patterns to advanced features like coroutines, generics, and call tracking.</p>"},{"location":"user-guide/usage.html#quick-start","title":"Quick Start","text":"<p>The most common use case\u2014a simple interface with methods:</p> <pre><code>// src/commonMain/kotlin/com/example/Analytics.kt\nimport com.rsicarelli.fakt.Fake\n\n@Fake\ninterface Analytics {\n    fun track(event: String)\n    fun identify(userId: String)\n}\n</code></pre> <p>Using in tests:</p> <pre><code>// src/commonTest/kotlin/com/example/AnalyticsTest.kt\nimport kotlin.test.Test\nimport kotlin.test.assertEquals\n\nclass AnalyticsTest {\n    @Test\n    fun `GIVEN fake analytics WHEN tracking events THEN captures calls`() {\n        val events = mutableListOf&lt;String&gt;()\n\n        val fake = fakeAnalytics {\n            track { event -&gt; events.add(event) }\n            identify { userId -&gt; println(\"User: $userId\") }\n        }\n\n        fake.track(\"user_signup\")\n        fake.track(\"user_login\")\n        fake.identify(\"user-123\")\n\n        assertEquals(listOf(\"user_signup\", \"user_login\"), events)\n        assertEquals(2, fake.trackCallCount.value)\n        assertEquals(1, fake.identifyCallCount.value)\n    }\n}\n</code></pre>"},{"location":"user-guide/usage.html#return-types-default-behaviors","title":"Return Types &amp; Default Behaviors","text":""},{"location":"user-guide/usage.html#return-values","title":"Return Values","text":"<p>Configure return values for methods:</p> <pre><code>@Fake\ninterface UserRepository {\n    fun getUser(id: String): User?\n    fun getAllUsers(): List&lt;User&gt;\n    fun count(): Int\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN configured repository WHEN fetching users THEN returns configured values`() {\n    val testUser = User(\"123\", \"Alice\")\n\n    val fake = fakeUserRepository {\n        getUser { id -&gt;\n            if (id == \"123\") testUser else null\n        }\n        getAllUsers { listOf(testUser) }\n        count { 1 }\n    }\n\n    assertEquals(testUser, fake.getUser(\"123\"))\n    assertNull(fake.getUser(\"456\"))\n    assertEquals(1, fake.getAllUsers().size)\n    assertEquals(1, fake.count())\n}\n</code></pre>"},{"location":"user-guide/usage.html#smart-defaults","title":"Smart Defaults","text":"<p>Fakt generates smart defaults. You only configure what you need:</p> <pre><code>@Fake\ninterface Settings {\n    fun getTheme(): String\n    fun getFontSize(): Int\n    fun isEnabled(): Boolean\n}\n</code></pre> <p>Using defaults:</p> <pre><code>@Test\nfun `GIVEN unconfigured fake WHEN calling methods THEN uses defaults`() {\n    val fake = fakeSettings()  // No configuration\n\n    assertEquals(\"\", fake.getTheme())      // String default: \"\"\n    assertEquals(0, fake.getFontSize())    // Int default: 0\n    assertEquals(false, fake.isEnabled())  // Boolean default: false\n}\n</code></pre> <p>Override defaults:</p> <pre><code>@Test\nfun `GIVEN configured fake WHEN calling methods THEN uses custom behavior`() {\n    val fake = fakeSettings {\n        getTheme { \"dark\" }\n        isEnabled { true }\n        // getFontSize not configured, uses default: 0\n    }\n\n    assertEquals(\"dark\", fake.getTheme())\n    assertEquals(true, fake.isEnabled())\n    assertEquals(0, fake.getFontSize())  // Default\n}\n</code></pre>"},{"location":"user-guide/usage.html#nullable-types","title":"Nullable Types","text":"<p>Handle nullable types naturally with <code>null</code> defaults:</p> <pre><code>@Fake\ninterface UserService {\n    fun findUser(id: String): User?\n    fun findByEmail(email: String): User?\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN user service fake WHEN finding users THEN handles nulls correctly`() {\n    val testUser = User(\"123\", \"Alice\")\n\n    val fake = fakeUserService {\n        findUser { id -&gt;\n            if (id == \"123\") testUser else null\n        }\n        // findByEmail not configured, default: null\n    }\n\n    assertNotNull(fake.findUser(\"123\"))\n    assertNull(fake.findUser(\"456\"))\n    assertNull(fake.findByEmail(\"alice@example.com\"))  // Default: null\n}\n</code></pre>"},{"location":"user-guide/usage.html#result-types","title":"Result Types","text":"<p>Fakt handles <code>Result&lt;T&gt;</code> with sensible defaults:</p> <pre><code>@Fake\ninterface ApiClient {\n    fun fetchData(id: String): Result&lt;Data&gt;\n    fun upload(data: Data): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN API client fake WHEN fetching data THEN returns configured Result`() {\n    val testData = Data(\"123\", \"content\")\n\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            if (id == \"123\") Result.success(testData)\n            else Result.failure(NotFoundException())\n        }\n        upload { data -&gt;\n            Result.success(Unit)\n        }\n    }\n\n    val result1 = fake.fetchData(\"123\")\n    assertTrue(result1.isSuccess)\n    assertEquals(testData, result1.getOrNull())\n\n    val result2 = fake.fetchData(\"456\")\n    assertTrue(result2.isFailure)\n\n    val result3 = fake.upload(testData)\n    assertTrue(result3.isSuccess)\n}\n</code></pre>"},{"location":"user-guide/usage.html#collection-types","title":"Collection Types","text":"<p>Smart defaults for collections:</p> <pre><code>@Fake\ninterface Repository {\n    fun getAll(): List&lt;Item&gt;\n    fun getTags(): Set&lt;String&gt;\n    fun getMetadata(): Map&lt;String, String&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN repository fake WHEN fetching collections THEN uses defaults or configured values`() {\n    val fake = fakeRepository {\n        getAll { listOf(Item(\"1\"), Item(\"2\")) }\n        // getTags not configured, default: emptySet()\n        // getMetadata not configured, default: emptyMap()\n    }\n\n    assertEquals(2, fake.getAll().size)\n    assertTrue(fake.getTags().isEmpty())      // Default\n    assertTrue(fake.getMetadata().isEmpty())  // Default\n}\n</code></pre>"},{"location":"user-guide/usage.html#unit-return-type","title":"Unit Return Type","text":"<p>Methods returning <code>Unit</code> get no-op defaults:</p> <pre><code>@Fake\ninterface EventBus {\n    fun publish(event: Event)\n    fun subscribe(handler: EventHandler)\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN event bus fake WHEN publishing events THEN executes configured behavior`() {\n    val receivedEvents = mutableListOf&lt;Event&gt;()\n\n    val fake = fakeEventBus {\n        publish { event -&gt; receivedEvents.add(event) }\n        // subscribe not configured, default: { } (no-op)\n    }\n\n    fake.publish(Event(\"test-event\"))\n    fake.subscribe(mockHandler)  // No-op default\n\n    assertEquals(1, receivedEvents.size)\n    assertEquals(1, fake.publishCallCount.value)\n    assertEquals(1, fake.subscribeCallCount.value)\n}\n</code></pre>"},{"location":"user-guide/usage.html#method-parameters","title":"Method Parameters","text":"<p>Methods with multiple parameters work as expected:</p> <pre><code>@Fake\ninterface Calculator {\n    fun add(a: Int, b: Int): Int\n    fun divide(numerator: Double, denominator: Double): Double\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN calculator fake WHEN calling methods THEN uses provided parameters`() {\n    val fake = fakeCalculator {\n        add { a, b -&gt; a + b }\n        divide { numerator, denominator -&gt;\n            if (denominator == 0.0) Double.NaN\n            else numerator / denominator\n        }\n    }\n\n    assertEquals(5, fake.add(2, 3))\n    assertEquals(2.5, fake.divide(5.0, 2.0))\n    assertTrue(fake.divide(10.0, 0.0).isNaN())\n}\n</code></pre>"},{"location":"user-guide/usage.html#suspend-functions","title":"Suspend Functions","text":"<p>Fakt fully supports Kotlin coroutines and suspend functions without any special configuration.</p>"},{"location":"user-guide/usage.html#basic-suspend-functions","title":"Basic Suspend Functions","text":"<p>Suspend functions work naturally in generated fakes:</p> <pre><code>@Fake\ninterface ApiClient {\n    suspend fun fetchData(id: String): Result&lt;Data&gt;\n    suspend fun upload(data: Data): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage in tests:</p> <pre><code>import kotlinx.coroutines.test.runTest\nimport kotlin.test.Test\nimport kotlin.test.assertTrue\n\nclass ApiClientTest {\n    @Test\n    fun `GIVEN API client fake WHEN fetching data THEN suspends correctly`() = runTest {\n        val testData = Data(\"123\", \"content\")\n\n        val fake = fakeApiClient {\n            fetchData { id -&gt;\n                delay(100)  // Suspends correctly\n                Result.success(testData)\n            }\n            upload { data -&gt;\n                delay(50)\n                Result.success(Unit)\n            }\n        }\n\n        val result = fake.fetchData(\"123\")\n\n        assertTrue(result.isSuccess)\n        assertEquals(testData, result.getOrNull())\n        assertEquals(1, fake.fetchDataCallCount.value)\n    }\n}\n</code></pre>"},{"location":"user-guide/usage.html#suspend-non-suspend-mix","title":"Suspend + Non-Suspend Mix","text":"<p>Interfaces can mix suspend and regular functions:</p> <pre><code>@Fake\ninterface UserRepository {\n    fun getLocalUser(id: String): User?\n    suspend fun fetchRemoteUser(id: String): Result&lt;User&gt;\n    suspend fun syncUsers(): Result&lt;Unit&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN repository WHEN calling mixed functions THEN works correctly`() = runTest {\n    val fake = fakeUserRepository {\n        getLocalUser { id -&gt; User(id, \"Local\") }\n        fetchRemoteUser { id -&gt;\n            delay(100)\n            Result.success(User(id, \"Remote\"))\n        }\n        syncUsers {\n            delay(200)\n            Result.success(Unit)\n        }\n    }\n\n    // Regular function (no suspend)\n    val local = fake.getLocalUser(\"123\")\n    assertEquals(\"Local\", local?.name)\n\n    // Suspend functions\n    val remote = fake.fetchRemoteUser(\"456\")\n    val syncResult = fake.syncUsers()\n\n    assertTrue(remote.isSuccess)\n    assertTrue(syncResult.isSuccess)\n}\n</code></pre>"},{"location":"user-guide/usage.html#suspend-properties","title":"Suspend Properties","text":"<p>Properties with suspend getters are supported:</p> <pre><code>@Fake\ninterface AsyncConfig {\n    suspend fun loadConfig(): Map&lt;String, String&gt;\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN async config WHEN loading THEN suspends correctly`() = runTest {\n    val fake = fakeAsyncConfig {\n        loadConfig {\n            delay(50)\n            mapOf(\"key\" to \"value\")\n        }\n    }\n\n    val config = fake.loadConfig()\n\n    assertEquals(\"value\", config[\"key\"])\n}\n</code></pre>"},{"location":"user-guide/usage.html#exception-handling","title":"Exception Handling","text":"<p>Suspend functions can throw exceptions naturally:</p> <pre><code>@Test\nfun `GIVEN API client WHEN fetch fails THEN throws exception`() = runTest {\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            delay(100)\n            throw NetworkException(\"Connection failed\")\n        }\n    }\n\n    assertFailsWith&lt;NetworkException&gt; {\n        fake.fetchData(\"123\")\n    }\n}\n</code></pre>"},{"location":"user-guide/usage.html#coroutine-context","title":"Coroutine Context","text":"<p>Fakt-generated fakes work with all coroutine contexts:</p> <pre><code>@Test\nfun `GIVEN repository WHEN using different dispatchers THEN works correctly`() = runTest {\n    val fake = fakeRepository {\n        fetchData { id -&gt;\n            withContext(Dispatchers.Default) {\n                // Computation\n                Data(id)\n            }\n        }\n    }\n\n    val data = fake.fetchData(\"123\")\n    assertEquals(\"123\", data.id)\n}\n</code></pre>"},{"location":"user-guide/usage.html#best-practices-for-suspend-functions","title":"Best Practices for Suspend Functions","text":""},{"location":"user-guide/usage.html#use-runtest-for-suspend-tests","title":"Use runTest for Suspend Tests","text":"<p>Always wrap suspend function tests in <code>runTest</code>:</p> <pre><code>@Test\nfun `test suspend function`() = runTest {  // \u2705 Required\n    val fake = fakeApiClient()\n    fake.fetchData(\"123\")\n}\n</code></pre>"},{"location":"user-guide/usage.html#use-delay-for-testing-timing","title":"Use delay() for Testing Timing","text":"<p>Test timing-sensitive code with <code>delay()</code>:</p> <pre><code>@Test\nfun `GIVEN slow API WHEN fetching THEN handles timeout`() = runTest {\n    val fake = fakeApiClient {\n        fetchData { id -&gt;\n            delay(5000)  // Simulate slow response\n            Result.success(Data(id))\n        }\n    }\n\n    withTimeout(1000) {\n        assertFailsWith&lt;TimeoutCancellationException&gt; {\n            fake.fetchData(\"123\")\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/usage.html#properties","title":"Properties","text":"<p>Fakt generates fakes for both read-only (<code>val</code>) and mutable (<code>var</code>) properties with automatic call tracking.</p>"},{"location":"user-guide/usage.html#read-only-properties-val","title":"Read-Only Properties (val)","text":"<pre><code>@Fake\ninterface Config {\n    val apiUrl: String\n    val timeout: Int\n}\n\nval fake = fakeConfig {\n    apiUrl { \"https://api.example.com\" }\n    timeout { 30 }\n}\n\nassertEquals(\"https://api.example.com\", fake.apiUrl)\nassertEquals(1, fake.apiUrlCallCount.value)\n</code></pre>"},{"location":"user-guide/usage.html#mutable-properties-var","title":"Mutable Properties (var)","text":"<p>Mutable properties track both getter and setter calls separately:</p> <pre><code>@Fake\ninterface Settings {\n    var theme: String\n    var fontSize: Int\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n    fontSize { 14 }\n}\n\n// Getter tracking\nassertEquals(\"dark\", fake.theme)\nassertEquals(1, fake.getThemeCallCount.value)\n\n// Setter tracking\nfake.theme = \"light\"\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"user-guide/usage.html#generics","title":"Generics","text":"<p>Fakt fully supports generic type parameters at both class and method levels.</p>"},{"location":"user-guide/usage.html#class-level-generics","title":"Class-Level Generics","text":"<pre><code>@Fake\ninterface Repository&lt;T&gt; {\n    fun save(item: T): Result&lt;Unit&gt;\n    fun getAll(): List&lt;T&gt;\n}\n\nval fake = fakeRepository&lt;User&gt; {\n    save { item -&gt; Result.success(Unit) }\n    getAll { emptyList() }\n}\n</code></pre>"},{"location":"user-guide/usage.html#method-level-generics","title":"Method-Level Generics","text":"<pre><code>@Fake\ninterface Transformer {\n    fun &lt;T, R&gt; transform(input: T, mapper: (T) -&gt; R): R\n}\n\nval fake = fakeTransformer {\n    transform { input, mapper -&gt; mapper(input) }\n}\n</code></pre>"},{"location":"user-guide/usage.html#generic-constraints","title":"Generic Constraints","text":"<pre><code>@Fake\ninterface ComparableRepository&lt;T : Comparable&lt;T&gt;&gt; {\n    fun findMax(items: List&lt;T&gt;): T?\n}\n\nval fake = fakeComparableRepository&lt;Int&gt; {\n    findMax { items -&gt; items.maxOrNull() }\n}\n</code></pre>"},{"location":"user-guide/usage.html#variance","title":"Variance","text":"<p>Fakt supports variance modifiers (<code>out</code>, <code>in</code>):</p> <pre><code>@Fake\ninterface Producer&lt;out T&gt; {\n    fun produce(): T\n}\n\n@Fake\ninterface Consumer&lt;in T&gt; {\n    fun consume(item: T)\n}\n</code></pre>"},{"location":"user-guide/usage.html#call-tracking","title":"Call Tracking","text":"<p>Every Fakt-generated fake includes automatic, thread-safe call tracking via Kotlin StateFlow.</p>"},{"location":"user-guide/usage.html#basic-call-tracking","title":"Basic Call Tracking","text":"<p>Every method automatically tracks calls:</p> <pre><code>@Fake\ninterface Logger {\n    fun log(message: String)\n    fun error(message: String)\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN fake logger WHEN logging messages THEN tracks call counts`() {\n    val fake = fakeLogger {\n        log { message -&gt; println(message) }\n        error { message -&gt; System.err.println(message) }\n    }\n\n    fake.log(\"Info message\")\n    fake.log(\"Another info\")\n    fake.error(\"Error occurred\")\n\n    assertEquals(2, fake.logCallCount.value)\n    assertEquals(1, fake.errorCallCount.value)\n}\n</code></pre>"},{"location":"user-guide/usage.html#stateflow-integration","title":"StateFlow Integration","text":"<p>Call counters are <code>StateFlow&lt;Int&gt;</code>, enabling reactive testing:</p> <pre><code>import app.cash.turbine.test\n\n@Test\nfun `GIVEN fake WHEN calling methods THEN counter updates reactively`() = runTest {\n    val fake = fakeRepository()\n\n    fake.getUserCallCount.test {\n        assertEquals(0, awaitItem())\n\n        fake.getUser(\"123\")\n        assertEquals(1, awaitItem())\n\n        fake.getUser(\"456\")\n        assertEquals(2, awaitItem())\n    }\n}\n</code></pre>"},{"location":"user-guide/usage.html#property-call-tracking","title":"Property Call Tracking","text":"<p>Properties track both getter and setter calls:</p> <pre><code>@Fake\ninterface Settings {\n    var theme: String\n}\n\nval fake = fakeSettings {\n    theme { \"dark\" }\n}\n\nval _ = fake.theme  // Getter\nassertEquals(1, fake.getThemeCallCount.value)\n\nfake.theme = \"light\"  // Setter\nassertEquals(1, fake.setThemeCallCount.value)\n</code></pre>"},{"location":"user-guide/usage.html#thread-safety","title":"Thread Safety","text":"<p>All call counters are thread-safe via <code>MutableStateFlow.update</code>:</p> <pre><code>@Test\nfun `GIVEN fake WHEN calling from multiple threads THEN counts correctly`() = runTest {\n    val fake = fakeAnalytics()\n\n    withContext(Dispatchers.Default) {\n        repeat(1000) {\n            launch {\n                fake.track(\"event\")\n            }\n        }\n    }\n\n    assertEquals(1000, fake.trackCallCount.value)\n}\n</code></pre>"},{"location":"user-guide/usage.html#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"user-guide/usage.html#inheritance","title":"Inheritance","text":"<p>Fakt handles inherited methods correctly:</p> <pre><code>interface BaseService {\n    fun start(): Boolean\n    fun stop(): Boolean\n}\n\n@Fake\ninterface UserService : BaseService {\n    fun getUser(id: String): User\n}\n</code></pre> <p>Usage:</p> <pre><code>@Test\nfun `GIVEN service fake WHEN calling inherited methods THEN works correctly`() {\n    val fake = fakeUserService {\n        start { true }\n        stop { true }\n        getUser { id -&gt; User(id, \"Alice\") }\n    }\n\n    assertTrue(fake.start())\n    assertEquals(\"Alice\", fake.getUser(\"123\").name)\n    assertTrue(fake.stop())\n\n    assertEquals(1, fake.startCallCount.value)\n    assertEquals(1, fake.getUserCallCount.value)\n    assertEquals(1, fake.stopCallCount.value)\n}\n</code></pre>"},{"location":"user-guide/usage.html#reconfiguring-fakes","title":"Reconfiguring Fakes","text":"<p>You can reconfigure behavior mid-test if needed:</p> <pre><code>@Test\nfun `GIVEN fake WHEN reconfiguring behavior THEN uses new behavior`() {\n    val fake = fakeUserRepository()\n\n    // Initial configuration\n    fake.configureGetUser { id -&gt; User(id, \"Alice\") }\n    assertEquals(\"Alice\", fake.getUser(\"123\").name)\n\n    // Reconfigure\n    fake.configureGetUser { id -&gt; User(id, \"Bob\") }\n    assertEquals(\"Bob\", fake.getUser(\"123\").name)\n}\n</code></pre> <p>Advanced Usage</p> <p>Reconfiguring via <code>configureXxx()</code> methods is an advanced pattern. Prefer creating new fakes for different test scenarios.</p>"},{"location":"user-guide/usage.html#next-steps","title":"Next Steps","text":"<p>Learn More: - Testing Patterns - GIVEN-WHEN-THEN, isolated fakes, verification strategies - Multi-Module - Cross-module fake sharing with collector modules - Migration from Mocks - Migrating from MockK or Mockito - Performance - Build performance and optimization</p> <p>Advanced Configuration: - Plugin Configuration - Compiler plugin configuration and log levels - Generated Code Reference - Understanding generated fake implementations - Platform Support - KMP target support and platform-specific patterns</p>"}]}